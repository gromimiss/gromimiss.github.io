<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gromimiss&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gromimiss.github.io/"/>
  <updated>2019-06-25T07:39:25.504Z</updated>
  <id>https://gromimiss.github.io/</id>
  
  <author>
    <name>Gromimiss</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>表情编辑器组件的简单实现</title>
    <link href="https://gromimiss.github.io/2019/06/24/emojiEditor/"/>
    <id>https://gromimiss.github.io/2019/06/24/emojiEditor/</id>
    <published>2019-06-23T16:00:00.000Z</published>
    <updated>2019-06-25T07:39:25.504Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中遇到需要用到表情编辑器的需求，看到老后台里面的表情编辑器一堆 Bug，正好这个项目要迁移新后台，就想着重构一版，原本以为挺简单的一玩意，但是真正开发的过程中遇到了很多问题。之前也没有这块的经验，都是直接使用的网上现成的库，所以这次想着记录一下摸索的过程。</p><a id="more"></a><h2 id="基本功能介绍"><a href="#基本功能介绍" class="headerlink" title="基本功能介绍"></a>基本功能介绍</h2><p>这个表情编辑器不同于别的富文本编辑器，它只支持插入表情，功能比较单一，正也是因为需要支持表情，涉及到标签，所以不能通过 textarea 来写。并且前期我一直在考虑这个编辑器是否要双向绑定，如果双向绑定就意味着要去区分这个值是在哪里改变的，因为 value(真正的数据，会传到数据库的数据，不带标签) 和 content(展示在页面上的数据，带标签，展示表情图) 是不同的，而 value 改变，content 就要改变，所以需要监听 value 是组件内的改变还是组件外的改变，若是组件内的改变，则不应该触发 content 的改变。最后考虑到如果使用传入默认值的形式，那么就只能暴露出方法，每次有改动都需要调用这个方法去改变值，相较于双向绑定，使用起来没有那么方便，并且表情编辑器也是表单组件中的一部分，所以还是做成双向绑定更为合适。</p><p>根据项目需要，分析出编辑器需要有以下可配置项：</p><ul><li>value 编辑器的 value 值</li><li>width 编辑器的宽度，默认 100%</li><li>height 编辑器的高度</li><li>max 编辑器最多可输入的字符数</li><li>placeholder 编辑器未输入时显示的提示字符</li></ul><p>UI 展示如下：</p><center><br>    <img src="/assets/emojiEditor/1.jpg" width="40%"><br></center><h2 id="主要实现"><a href="#主要实现" class="headerlink" title="主要实现"></a>主要实现</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ol><li>准备表情合成的雪碧图、表情字符和对应类名间的映射文件</li><li>基本 HTML 结构：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;cus-emoji-editor&quot; :style=&quot;styleObj&quot; @click.stop=&quot;&quot;&gt;</span><br><span class="line">    &lt;!-- 工具栏：插入表情的按钮 --&gt;</span><br><span class="line">    &lt;div class=&quot;cus-emoji-editor__toolbar&quot;&gt;</span><br><span class="line">        &lt;span </span><br><span class="line">            id=&quot;emojiBtn&quot; </span><br><span class="line">            class=&quot;cus-emoji-editor__btn-emoji&quot;</span><br><span class="line">            @click=&quot;insertAutoFocus&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;ui-popover </span><br><span class="line">            target=&quot;#emojiBtn&quot;</span><br><span class="line">            ref=&quot;emojiPopover&quot; </span><br><span class="line">            placement=&quot;top&quot;</span><br><span class="line">            trigger=&quot;click&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ui-menu </span><br><span class="line">                    :menu=&quot;menu&quot; </span><br><span class="line">                    class=&quot;cus-emoji-editor__emoji-menu line&quot; </span><br><span class="line">                    @emit=&quot;menuChange&quot;</span><br><span class="line">                    current-menu=&quot;emoji&quot;&gt;&lt;/ui-menu&gt;</span><br><span class="line">                &lt;div class=&quot;cus-emoji-editor__emoji-body&quot;&gt;</span><br><span class="line">                    &lt;i </span><br><span class="line">                        v-for=&quot;(item, key) in emojData&quot; </span><br><span class="line">                        :key=&quot;key&quot; </span><br><span class="line">                        :class=&quot;item&quot; </span><br><span class="line">                        :title=&quot;key + &apos;_web&apos;&quot; </span><br><span class="line">                        @click=&quot;insertEmoji(key, item)&quot;&gt;&lt;/i&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/ui-popover&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 编辑区域--&gt;</span><br><span class="line">    &lt;div class=&quot;cus-emoji-editor__content&quot;&gt;</span><br><span class="line">        &lt;div </span><br><span class="line">            class=&quot;cus-emoji-editor__placeholder&quot; </span><br><span class="line">            v-if=&quot;placeholder &amp;&amp; !hasVal &amp;&amp; !isFocus&quot; </span><br><span class="line">            @click=&quot;focus&quot;&gt;&#123;&#123;placeholder&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div </span><br><span class="line">            class=&quot;cus-emoji-editor__input&quot;</span><br><span class="line">            v-html=&quot;content&quot;</span><br><span class="line">            contenteditable=&quot;true&quot;</span><br><span class="line">            ref=&quot;input&quot;</span><br><span class="line">            @focus=&quot;isFocus = true&quot;</span><br><span class="line">            @blur=&quot;isFocus = false&quot;</span><br><span class="line">            @input=&quot;handleInput&quot;</span><br><span class="line">            @paste=&quot;handlePaste&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;cus-emoji-editor__len&quot; v-if=&quot;max&quot;&gt;</span><br><span class="line">            &#123;&#123;len&#125;&#125;/&#123;&#123;max&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>通过背景图位置的设置控制表情图的显示，比如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.qqemoji &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 28px;</span><br><span class="line">    height: 28px;</span><br><span class="line">    background: url(xxx.png) 0 0 no-repeat;</span><br><span class="line">    zoom: 1;</span><br><span class="line">    background-size: 1900%;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    box-sizing: content-box;</span><br><span class="line">&#125;</span><br><span class="line">.qqemoji-1 &#123;</span><br><span class="line">    background-position: -4px -4px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑器的主体功能"><a href="#编辑器的主体功能" class="headerlink" title="编辑器的主体功能"></a>编辑器的主体功能</h3><h4 id="相关属性及-api-复习"><a href="#相关属性及-api-复习" class="headerlink" title="相关属性及 api 复习"></a>相关属性及 api 复习</h4><p>想要了解所有 API，可见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection" target="_blank" rel="noopener">文档</a>.</p><ul><li>Selection 对象：表示用户选择的文本范围或插入符号的当前位置，可能横跨多个元素。</li><li>Range 对象：用户选择的某个区域（某个连续的一部分），通常情况下用户只能选择一个范围，但是用户也可以通过 control 键并选多个区域（chrome 中禁止了这个动作）。</li><li>anchor：一个选区的起始点，即鼠标按下瞬间的那个点。</li><li>focus：一个选区的终点，即鼠标松开瞬间所记录的那个点</li><li>window.getSelection() 获取选中对象，在firefox、safari、chrome、opera、ie9+下使用</li><li>document.selection 获取选中对象,在 ie9 以下使用</li><li>selection.getRangeAt(0) 选中的第一个区域</li><li>selection.removeAllRanges() 将所有区域从选区中移除</li><li>selection.addRange() 添加一个区域对象到选区</li><li>range.insertNode(el) 在选中位置起点处插入元素</li><li>range.cloneRange() 克隆一个选中区域</li><li>range.setStart(el, 1) 设置 range 对象的起点，el 为 range 的起始位置，1 为从 el 开始位置算起的偏移量</li><li>range.setEnd(el, 1) 设置 range 对象的终点</li><li>range.setStartBefore(el) 将某个节点的起点位置设置为 range 对象的起点位置</li><li>range.setStartAfter(el) 将某个节点的终点位置设置为 range 对象的起点位置</li><li>range.setEndBefore(el) 将某个节点的起点位置设置为 range 对象的终点位置</li><li>range.setEndAfter(el) 将某个节点的终点位置设置为 range 对象的终点位置</li><li>range.collapse(true) true 光标向 start 折叠为一个点，false 光标向 end 折叠为一个点</li><li>range.deleteContents() 从文档中移除 range 中的内容</li></ul><h4 id="主体功能实现"><a href="#主体功能实现" class="headerlink" title="主体功能实现"></a>主体功能实现</h4><p>一个表情编辑器主要考虑三点，一是输入文字、二是插入表情、三是复制粘贴。整个流程是这样的：</p><ul><li>输入文字 -&gt; 计算字符数 -&gt; 组件内部设置 value -&gt; 反应到组件外</li><li>插入表情 -&gt; 组件内部设置 value -&gt; 反应到组件外</li><li>复制粘贴 -&gt; 组件内部设置 value -&gt; 反应到组件外</li><li>用户设置 value -&gt; 触发 content 的设置</li></ul><p>下面是细节实现：</p><ul><li>输入文字是上面三个点中最简单的一个，它只需要保证光标是在一个 div 中（用于分行）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">handleInput(ev) &#123;</span><br><span class="line">    let firstChild = this.$refs.input.firstChild;</span><br><span class="line">    if (!firstChild || firstChild.nodeName !== &apos;DIV&apos;) &#123;</span><br><span class="line">        this.$refs.input.innerHTML = &apos;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    // TODO：输入中文时到输入完成才触发值的改变</span><br><span class="line">    if (this.max || this.max === 0) &#123;</span><br><span class="line">        // 设置值</span><br><span class="line">        this.setVal();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 防抖设置值</span><br><span class="line">        this.debounceSetVal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">setVal() &#123;</span><br><span class="line">    this.isInner = true;</span><br><span class="line">    const children = this.$refs.input.children;</span><br><span class="line">    let val = &apos;&apos;;</span><br><span class="line">    // 分行</span><br><span class="line">    for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">        val = i !== children.length - 1 ?</span><br><span class="line">            `$&#123;val&#125;$&#123;children[i].textContent&#125;\n` : `$&#123;val&#125;$&#123;children[i].textContent&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value = val;</span><br><span class="line">    this.$emit(&apos;input&apos;, this.value);</span><br><span class="line">    this.$emit(&apos;change&apos;, this.value);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>插入表情里有很多需要注意的点:</li></ul><ol><li>当没有进入编辑器的焦点时，选择表情也应该可以插入表情，并且要考虑到编辑器是否有值，默认聚焦光标会在编辑器的起始点，所以需要我们手动将光标移动到文本最后。</li><li>当编辑器插入表情或者粘贴时，它会被添加到 <code>&lt;br&gt;</code> 后面，这个 <code>&lt;br&gt;</code> 不会被自动去掉。<code>&lt;br&gt;</code> 的作用是光标定位，在 <code>&lt;div&gt;</code> 里面加一个 <code>&lt;br&gt;</code> 可以让光标定位到 <code>&lt;div&gt;</code> 里面，但是要注意的是输入字符浏览器会自动去掉 <code>&lt;br&gt;</code>，而插入表情和复制粘贴需要我们自己手动去除。</li><li>表情图片的展示必须使用 img 标签，否则光标没法正确的展示，但是 img 标签还是会有一个问题，由于没有设置 src 属性，它会有一个边框，通过设置 border 也没有办法去掉，只能通过在 src 上添加一个空白图片。</li><li>表情字符要存在一个标签中，这样之后就可以通过 textContent 属性获取所有文本内容，它包含了子孙元素中的文本。</li><li>每个编辑器的类名必须要区分开来，否则若一个编辑器设置了 this.range，另一个编辑器也会拿到那个 range 的值，导致 range 混乱，插入表情出现问题（我这里是加了一个 manage.js，管理所有编辑器的 uid）。</li><li>选中文本插入表情，选中文本应该被清除。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// 处理首次进入页面，还没有保存 range 对象的情况，解决第一个问题</span><br><span class="line">insertAutoFocus() &#123;</span><br><span class="line">    if (!this.range) &#123;</span><br><span class="line">        this.$refs.input.focus();</span><br><span class="line">        // 默认进入焦点焦点会在内容区的起始位置，所以要将光标移到内容区的最后</span><br><span class="line">        this.moveCursorToLast(this.$refs.input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">moveCursorToLast(el) &#123;</span><br><span class="line">    if (!el.lastChild) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (window.getSelection) &#123;</span><br><span class="line">        let range = window.getSelection();</span><br><span class="line">        range.selectAllChildren(el.lastChild); // range 选择obj下所有子内容</span><br><span class="line">        range.collapseToEnd(); // 光标移至最后</span><br><span class="line">    &#125; else if (document.selection) &#123; // 兼容 IE</span><br><span class="line">        let range = document.selection.createRange();</span><br><span class="line">        range.moveToElementText(el.lastChild);</span><br><span class="line">        range.collapse(false);</span><br><span class="line">        range.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 若选区是在编辑区的，则保存这个选区</span><br><span class="line">getCursor() &#123;</span><br><span class="line">    const selection = this.getSelection();</span><br><span class="line">    const anchorNode = selection.anchorNode;</span><br><span class="line">    const inputClass = `cus-emoji-editor__input--$&#123;this.uid&#125;`;</span><br><span class="line">    const placeholderClass = `cus-emoji-editor__placeholder--$&#123;this.uid&#125;`;</span><br><span class="line">    const aNCls = anchorNode.className || &apos;&apos;;</span><br><span class="line">    const aNParentCls = anchorNode.parentNode.className || &apos;&apos;;</span><br><span class="line">    const ancestorCls = anchorNode.parentNode.parentNode.className || &apos;&apos;;</span><br><span class="line">    // 这里要区分不同编辑器</span><br><span class="line">    if (anchorNode &amp;&amp;</span><br><span class="line">        (aNCls.indexOf(inputClass) &gt; -1 ||</span><br><span class="line">            aNCls.indexOf(placeholderClass) &gt; -1 ||</span><br><span class="line">            aNParentCls.indexOf(inputClass) &gt; -1 ||</span><br><span class="line">            ancestorCls.indexOf(inputClass) &gt; -1)) &#123;</span><br><span class="line">        this.range = selection.getRangeAt(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">insertEmoji(key, className) &#123;</span><br><span class="line">    this.$refs.emojiPopover.hide();</span><br><span class="line">    let range = this.range;</span><br><span class="line">    if (!range) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 显示表情图</span><br><span class="line">    let el = document.createElement(&apos;img&apos;);</span><br><span class="line">    el.className = className;</span><br><span class="line">    // 存放表情字符</span><br><span class="line">    let elText = document.createElement(&apos;span&apos;);</span><br><span class="line">    elText.style.display = &apos;none&apos;;</span><br><span class="line">    elText.innerText = key;</span><br><span class="line">    // 删除之前选中区域的内容</span><br><span class="line">    range.deleteContents();</span><br><span class="line">    // 插入表情和字符</span><br><span class="line">    range.insertNode(el);</span><br><span class="line">    range.insertNode(elText);</span><br><span class="line">    // 将光标位置移动到插入的表情后</span><br><span class="line">    this.moveRange(el);</span><br><span class="line">    this.setVal();</span><br><span class="line">    this.removeBr(el, elText);</span><br><span class="line">&#125;,</span><br><span class="line">removeBr(el, elText) &#123;</span><br><span class="line">    // 当首次没有进入编辑器焦点，点击插入表情，表情会插入到 &lt;br&gt; 后</span><br><span class="line">    if (elText) &#123;</span><br><span class="line">        const prev = elText.previousSibling;</span><br><span class="line">        if (prev &amp;&amp; prev.nodeName === &apos;BR&apos; &amp;&amp; prev.parentNode.nodeName === &apos;DIV&apos;) &#123;</span><br><span class="line">            prev.parentNode.removeChild(prev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当编辑器插入表情或者粘贴时，后面的 &lt;br&gt; 不会自动被去掉</span><br><span class="line">    const next = el.nextSibling;</span><br><span class="line">    if (next &amp;&amp; next.nodeName === &apos;BR&apos; &amp;&amp; next.parentNode.nodeName === &apos;DIV&apos;) &#123;</span><br><span class="line">        next.parentNode.removeChild(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">moveRange(el, range) &#123;</span><br><span class="line">    range = (range || this.range).cloneRange();</span><br><span class="line">    if (el) &#123;</span><br><span class="line">        range.setStartAfter(el);</span><br><span class="line">    &#125;</span><br><span class="line">    range.collapse(true);</span><br><span class="line">    let selection = this.getSelection();</span><br><span class="line">    selection.removeAllRanges();</span><br><span class="line">    selection.addRange(range);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>复制粘贴：</li></ul><p>复制粘贴要考虑的是不需要将样式，图片等一起粘贴过来，我们只需要文本和表情，而表情就是一个图片，这一点暂时还没有处理，目前只支持复制文本。</p><p>小细节：toolbar 中表情 tool 可以使用 button 按钮，当你选中某些文本的时候就会有选中的效果，如果使用 span 标签，选中效果会被清除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">handlePaste(ev) &#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">    let data = ev.clipboardData.getData(&apos;text&apos;);</span><br><span class="line">    let selection = this.getSelection();</span><br><span class="line">    if (selection &amp;&amp; data !== &apos;&apos; &amp;&amp; data !== null) &#123;</span><br><span class="line">        let textNode = document.createTextNode(data);</span><br><span class="line">        // 删除选中文本</span><br><span class="line">        this.range.deleteContents();</span><br><span class="line">        // 插入文本</span><br><span class="line">        this.range.insertNode(textNode);</span><br><span class="line">        this.moveRange(textNode);</span><br><span class="line">        this.setVal();</span><br><span class="line">        this.removeBr(textNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="其他实现及注意点"><a href="#其他实现及注意点" class="headerlink" title="其他实现及注意点"></a>其他实现及注意点</h4><ul><li>有这样一个场景：在表格列表中点击某条记录中的编辑，打开编辑 dialog，dialog 中有表情编辑器，那么多条记录是共用的一个 dialog，编辑器也是同一个，只是编辑器的值会改变，此时需要在每次 dialog 打开时（即用户设置值的时候），将 range 清空，否则在没有聚焦时插入表情就会出现问题。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    value(newVal, oldVal) &#123;</span><br><span class="line">        if (this.isInner) &#123;</span><br><span class="line">            this.isInner = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.setContent(newVal);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    setContent(val) &#123;</span><br><span class="line">        let parseVal = parseEmojiMessage(val);</span><br><span class="line">        let eles = parseVal.split(/\n/);</span><br><span class="line">        let ele = &apos;&apos;;</span><br><span class="line">        for (let index = 0; index &lt; eles.length; index++) &#123;</span><br><span class="line">            const element = eles[index];</span><br><span class="line">            if (element) &#123;</span><br><span class="line">                ele += `&lt;div&gt;$&#123;element&#125;&lt;/div&gt;`;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.$refs.input.innerHTML = ele || &apos;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&apos;;</span><br><span class="line">        // 一定要清空</span><br><span class="line">        this.range = null;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文本删除时，div会被一并删除，所以当文本为空时要手动加上 <code>&lt;div&gt;&lt;br&gt;&lt;/div&gt;</code></li><li><code>&lt;br&gt;</code> 的作用只能是光标定位，换行会新增 <code>&lt;div&gt;&lt;br/&gt;&lt;/div&gt;</code>，但是当换行后又添加文字时 <code>&lt;br&gt;</code> 会被去掉，所以不能通过替换 <code>&lt;br&gt;</code> 为 \n 传到数据库，我们需要确保每一行都在一个 div 中，通过 div 来换行</li><li>列表中显示表情编辑器的内容时，需要将 emoji 字符 替换为表情图。由于 replace 会替换掉所有符合的字符串，所以一定要加匹配到的表情字符去重，以防止二次替换（将 <span> 中的表情字符再次替换掉）。</span></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const parseEmojiMessage = (content) =&gt; &#123;</span><br><span class="line">    if (!content) &#123;</span><br><span class="line">        return &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    let regx = /\[[\u2E80-\u9FFF|BQXK|BQTS|BQHL|BQJX|BQBA|BQMS|BQBG|BQBT|BQJR|BQQZ|BQLW]+\]/g; </span><br><span class="line">    // 匹配文本中表情相关信息</span><br><span class="line">    let matchList = content.match(regx);</span><br><span class="line">    let noRepeatMatch = [];</span><br><span class="line">    // 去重，防止替换过的在 span 标签中的表情字符被再次替换</span><br><span class="line">    matchList &amp;&amp; matchList.forEach((item) =&gt; &#123;</span><br><span class="line">        if (noRepeatMatch.indexOf(item) &lt;= -1) &#123;</span><br><span class="line">            noRepeatMatch.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    noRepeatMatch.forEach((item) =&gt; &#123;</span><br><span class="line">        let className = qqEmoj[item] || wxEmoj[item];</span><br><span class="line">        let str = `\\$&#123;item.substring(0, item.length - 1)&#125;\\]`;</span><br><span class="line">        content = content.replace(new RegExp(str, &apos;g&apos;), `&lt;span style=&quot;display: none;&quot;&gt;$&#123;item&#125;&lt;/span&gt;&lt;img class=&quot;$&#123;className&#125;&quot; /&gt;`);</span><br><span class="line">    &#125;);</span><br><span class="line">    return content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="未实现的优化"><a href="#未实现的优化" class="headerlink" title="未实现的优化"></a>未实现的优化</h4><ul><li>输入中文时到确认输入完成才触发值的改变</li><li>在 img 上添加空白图（解决边框的问题）</li><li>复制 emoji 表情</li><li>由于宽度设置的是百分比，当英文单词放不下时，width会自动拉长</li><li>目前点击表情 tool 时编辑器会失焦，光标消失，最好编辑器还是聚焦的状态</li><li>每次符合条件的 range 对象都会被记录下来以至于之后失焦时点击插入表情都会插入在失焦时的位置，而首次没有 range 对象时点击插入表情会插入到文本末尾，这里可以考虑统一插入到最后（由于点击表情的时候编辑器就会失焦，所以没办法去区分是聚焦的时候点击的表情，还是失焦的时候点击的表情）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看似简单的表情编辑器在真正开发的过程中遇到的问题还挺多的，并且结合场景还会发现一些平时注意不到的问题。以上只是一个表情编辑器的简单实现，还有很多细节需要去继续优化，后续再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中遇到需要用到表情编辑器的需求，看到老后台里面的表情编辑器一堆 Bug，正好这个项目要迁移新后台，就想着重构一版，原本以为挺简单的一玩意，但是真正开发的过程中遇到了很多问题。之前也没有这块的经验，都是直接使用的网上现成的库，所以这次想着记录一下摸索的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://gromimiss.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>由于分页组件引发的一些思考</title>
    <link href="https://gromimiss.github.io/2019/05/21/page/"/>
    <id>https://gromimiss.github.io/2019/05/21/page/</id>
    <published>2019-05-20T16:00:00.000Z</published>
    <updated>2019-05-21T05:47:57.556Z</updated>
    
    <content type="html"><![CDATA[<p>之前在写组件库的时候就一直想不好对传入的不同的 prop 应该做怎么样的处理，最近总结了一下。</p><a id="more"></a><h2 id="prop-有哪些处理情况？"><a href="#prop-有哪些处理情况？" class="headerlink" title="prop 有哪些处理情况？"></a>prop 有哪些处理情况？</h2><p>前不久，在使用公司内部的组件库时遇到一个问题：它默认初始化时会触发一次页码 change 事件，而我在进入页面时会调用一次获取列表数据的接口，并且在页码 change 事件中也会调用一次获取列表数据的接口，这就导致了页面进入时会触发两次获取列表数据的接口，去找架构组同事沟通了下，他说这是考虑到了前端将列表数据存在本地，通过页码 change 事件去获取列表数据，这让我想到了关于组件 prop 的一些问题：</p><p>在组件中会使用到很多的 prop，通过传入的 prop 去判断是否要支持某个功能或者是作为一个组件的值。以 page 当前页为例，有以下3种情况：</p><ol><li>page 是一个双向绑定的值，在组件内部和外部传入的变量是永远保持一致的，即内部改变则外部也改变，外部改变内部也改变（双向）</li><li>page 由外部传入，组件内部通过 watch 这个属性来做一些内部数据的更新（不会影响到外部的数据，单向）</li><li>page 是外部传入的一个初始值，组件内部会在初次传入时将值赋给内部的一个变量，后期即便外部改变传入的变量值，内部也不再接收这个改变（首次有效）</li></ol><p>而分页组件中的 page 一般是作为一个初始值，在页码 change 事件中会携带一个当前页码的值，以供外部获取，而作为一个默认初始值，它后来没有改变，也就不应该去触发页码 change 事件。即便有一种特殊情况，用户将数据存在本地，通过获取页码信息的接口返回的页码信息来获取到本地对应页，也应该由用户通过 js 去改变 page 来触发 页码 change 事件然后获取列表数据。</p><h2 id="什么情况下应该触发-change-事件"><a href="#什么情况下应该触发-change-事件" class="headerlink" title="什么情况下应该触发 change 事件"></a>什么情况下应该触发 change 事件</h2><p>在组件中一个值改变有 3 种情况： </p><ol><li>用户改变（比如在 input 中输入文字）</li><li>组件内部改变（比如开发者通过组件暴露的一个方法去设置值）</li><li>它是一个双向绑定的值，开发者直接改变传入的变量则组件内部也接收到了改变</li></ol><p>change 事件是只要值改变就应该触发而不考虑是哪种情况下改变的值，但是这样会有一个问题：有部分业务场景下，我们只需要用户通过输入/选择改变值才触发 change 事件，然后去做一些特殊的处理，这个时候若只是原来那个 change 事件就没有办法去区分了，所以是否有必要去再添加一个额外的 change 事件更合适呢。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然，vue 中对数据的订阅发布触发视图的更新也是不考虑数据是哪里改变的，如何改变的，但是作为开发者，我们是可以知道在哪里做了数据的改变的，并且在代码中可以做一些额外的处理，而组件库作为基于 vue 的一些组件的封装，我们是没有办法在特定的场景做一些特定的操作的，因为 vue 是面向开发者的，而业务开发是面向用户的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在写组件库的时候就一直想不好对传入的不同的 prop 应该做怎么样的处理，最近总结了一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://gromimiss.github.io/tags/vue/"/>
    
      <category term="组件库" scheme="https://gromimiss.github.io/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染过程及前端页面性能分析优化</title>
    <link href="https://gromimiss.github.io/2019/04/29/performance/"/>
    <id>https://gromimiss.github.io/2019/04/29/performance/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-06-25T04:44:33.751Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在浏览器输入网站域名，并按下回车之后的一段时间里，其实发生了很多事情，比如协议补全、域名解析、TCP 三次握手、发送请求、页面解析等等，因此这一过程可优化的点也很多。本文旨在阐述浏览器渲染网页时的一系列过程，在对浏览器如何工作足够了解的基础上，使用调试工具来分析页面性能，借此找到阻碍浏览器性能的问题点，从而做出相应优化。</p><a id="more"></a><h2 id="输入-URL-并回车后发生了什么"><a href="#输入-URL-并回车后发生了什么" class="headerlink" title="输入 URL 并回车后发生了什么"></a>输入 URL 并回车后发生了什么</h2><h3 id="浏览器解析-URL"><a href="#浏览器解析-URL" class="headerlink" title="浏览器解析 URL"></a>浏览器解析 URL</h3><p>当输入 URL 并回车后，浏览器首先会对 URL 进行解析，获取协议、主机、端口、路径，根据不同协议进行不同的处理。</p><h3 id="浏览器检查本地缓存"><a href="#浏览器检查本地缓存" class="headerlink" title="浏览器检查本地缓存"></a>浏览器检查本地缓存</h3><p>浏览器通过 Expires 和 Cache-control 来检查缓存是否新鲜，若命中缓存则直接从缓存中拉取资源信息，否则则发送新的请求。</p><p>Expires：HTTP 1.0 中提供，会比对此字段返回的时间和客户端时间，若在此之前则命中缓存。</p><p>Cache-control：HTTP 1.1 中新增，通过 设置 max-age 指定缓存多久后过期（它会根据第一次请求的时间和设置的有效期计算出过期时间，在过期时间之前就能命中缓存）。若同时有 Cache-control 和 Expires，则Cache-control 的优先级更高，因为 Expires 设置的是服务器的时间，可能会和客户端时间不一致，导致缓存出错。<br>其他常见配置项：</p><ul><li>no-cache：不使用本地缓存</li><li>no-store：禁止浏览器缓存数据，每次请求资源都会向服务器发送请求，并重新下载完整资源</li><li>public：可被所有用户缓存，包括终端用户和 CDN 等中间代理服务器</li><li>private：只能被终端用户的浏览器缓存</li></ul><h3 id="浏览器组装一个-HTTP-请求报文"><a href="#浏览器组装一个-HTTP-请求报文" class="headerlink" title="浏览器组装一个 HTTP 请求报文"></a>浏览器组装一个 HTTP 请求报文</h3><p>一个 HTTP 请求报文包含了请求行、请求头、请求体，这一步浏览器会组装一个完整的请求报文以备后续发送请求。</p><p>请求行：包含了请求方法、请求 url、http 版本。</p><p>请求头：用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。服务器会以此获取客户端信息。</p><p>常见请求头：</p><ul><li>Accept：告诉服务器，客户端接受什么类型的响应</li><li>Cookie：通过这个请求头将 cookie 传递给服务器</li><li>Referer：表示这个请求是从哪个 URL 过来的</li><li>Cache-Control：对缓存进行控制</li><li>User-Agent：告诉服务器发起请求的应用程序名称</li><li>Host：给出接受请求的服务器的主机名和端口号</li></ul><p>请求体：传递请求数据，比如图片、视频等等。</p><h3 id="DNS-域名解析，获取-ip-地址"><a href="#DNS-域名解析，获取-ip-地址" class="headerlink" title="DNS 域名解析，获取 ip 地址"></a>DNS 域名解析，获取 ip 地址</h3><p>因为计算机更擅长处理一长串数字，而 ip 地址又不方便用户记忆和沟通，所以就诞生了域名，用户可以通过域名来访问网站，通过 DNS 服务解析为 ip 地址，最后访问到网站所在的 ip 地址。DNS 用于 TCP/IP 网络，它会将主机名和域名转换为 ip 地址。</p><p>浏览器获取 ip 地址会有以下过程，若查找到则不会再执行后面的几步：</p><ul><li>从浏览器中检查缓存</li></ul><p>在 chrome 中可以通过 chrome://net-internals/#dns 查看各域名的 DNS 缓存信息，默认每个域名缓存 60 s。<br>在 firefox 中可以通过 about:config 查看 DNS 的缓存数量及缓存时间，默认每个域名缓存 60 s。<br>注：DNS 记录会有一个 TTL 值（记录最大有效期，单位：s），os 缓存会参考此值，但是不完全等于此值，而浏览器 DNS 缓存的时间和此值无关，每种浏览器都使用了一个固定值。（<a href="https://dyn.com/blog/web-browser-dns-caching-bad-thing/" target="_blank" rel="noopener">参考此文章</a>）</p><ul><li>从系统中检查缓存</li><li>检查本地的 hosts 文件是否有这个网址的映射关系</li><li>路由器缓存</li><li>ISP（电信运营商） DNS 缓存</li><li>DNS 递归查询</li></ul><p>本地 DNS 一般是指电脑上网时 IPv4 或 IPv6 设置中填写的 DNS，这个可以手动指定也可以由 DHCP 自动分配。如果电脑是直连运营商网络的，一般默认情况下 DNS 为 DHCP 分配到的运营商的服务器地址，若电脑和运营商之间还加了路由器，则它分配给下面电脑的 DNS 地址就是它自身，一般是 192.168.1.1，并且很有可能路由器本身还内置了一个 DNS 转发器，它会将发往它所有的 DNS 请求转发到上层 ISP 的 DNS。</p><p>在设置路由器的时候一般都会在 WAN 口设置中看到一个选项：手动设置 DNS 服务器，当我们未设置 DNS 服务器时，访问网络的情况如下（未转发）：</p><center><br>    <img src="/assets/performance/1.png" width="50%"><br></center><p>而当我们设置了本地网络供应商提供的 DNS 地址，则可以最大限度提升电脑与网络的交换速度，提高网络访问速度（转发）：</p><center><br>    <img src="/assets/performance/2.jpeg" width="50%"><br></center><p>DNS 服务器查询过程：</p><ol><li><p>主机向本地域名服务器递归查询：主机所询问的本地域名服务器若不知道被查询域名的 ip 地址，它就会以客户的身份，向其他根域名服务器继续发出查询请求，主机不用管后续过程，只会接收最终结果。</p></li><li><p>本地域名服务器向根域名服务器迭代查询:当本地域名服务器向根域名服务器查询时，根域名服务器若查询到了具体的 ip 地址则会直接给出，若未查询到则会告诉本地域名服务器下一步要去哪个域名服务器下进行查询，让本地域名服务器进行后续的查询。（全球 DNS 根服务器只有 13 台）</p></li></ol><p>这个过程，主机就相当于是老板，而本地域名服务器是员工，老板只需要接收最终的结果，员工则负责和部门同事 A 沟通，若沟通无果则和部门同事 B 沟通，直到问出结果，再将结果告诉老板。</p><center><br>    <img src="/assets/performance/3.png" width="40%"><br></center><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>HTTP 基于 TCP 协议，浏览器需要在三次握手后才能捎带 HTTP 请求报文，达到真正的建立连接。</p><p>TCP 三次握手图示：</p><center><br>    <img src="/assets/performance/5.png" width="40%"><br></center><ul><li>ACK 标志位：标志确认号 ack 是否有效，当 ACK = 1 时，确认号有效。</li><li>SYN 标志位：连接建立时用于同步序号。SYN = 1，ACK = 0 表示是一个连接请求报文段，如同意连接，则在响应报文段中使 SYN = 1，ACK = 1，握手完成后会被重新置为0。</li><li>序列号 seq：标记数据段的顺序，TCP 把连接中发送的所有数据字节都编上序号，发送给另一端。这个序号主要是用来保证有序的，当 A 向 B 发送一个数据包的时候，seq 会叠加，每一个传输方在传送数据时都会带上这个信息，另一端按照这个序号来排序收到信息的顺序，从而保证信息的传递是有序的，也可以确认有没有丢包的情况。</li><li>确认号 ack：确认号是另一端对对方 seq 的一个回应，一般会把对方给的 seq + 1 然后下一次发包的时候带上，这样对方就知道我们是收到了前面的消息的。</li></ul><p>为什么要是 3 次握手？</p><p>只有 2 次的情况下，若客户端想和服务器端建立连接，但是数据传输过程因为网络问题在某节点被阻塞了，客户端只能再发送一遍，此时服务器端就会收到 2 次请求，并持续等待两个客户端请求向它发送数据，就导致服务器端会有 2 个响应，造成极大的资源浪费。</p><h3 id="SSL-连接"><a href="#SSL-连接" class="headerlink" title="SSL 连接"></a>SSL 连接</h3><p>若使用的 HTTPS 协议就需要建立 SSL 连接。</p><h3 id="服务器检查缓存"><a href="#服务器检查缓存" class="headerlink" title="服务器检查缓存"></a>服务器检查缓存</h3><p>HTTP 请求发送成功后服务器会检查缓存：</p><p>Last-Modified：HTTP 1.0 中提供，浏览器第一次发起请求时，服务器会在 Last-Modified 响应头中携带文件最后更新的时间（服务器时间），而后浏览器再次发起请求时，就会在 If-Mofified-Since 请求头中将之前 Last-Modified 中的时间传递给服务器，服务器检查缓存后发生若文件没有更新，则直接返回一个 304 的响应头，减少响应数据量，提高响应速度。</p><p>ETag：HTTP 1.1 中新增，它是文件的一个唯一标识符，只要文件发生改变，这个标识就会发生改变。服务器会将比对 If-None-Match 请求头，若文件没有更新，也直接返回一个 304 响应头。若同时有 Last-Modified 和 ETag，则 ETag 的优先级更高，因为在一些特殊的情况下 Last-Modified 可能会缓存出错：服务器时钟出错，服务器时钟进行了修改，在本地打开了缓存文件，但并没有进行修改，又或者在不可感知的时间内对文件进行了修改（Last-Modify 只能以 s 计时）。</p><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><p>处理程序接收请求并做处理，比如一些数据库增删查改操作，然后将响应报文通过 tcp 连接发送回浏览器。</p><h3 id="浏览器接收-HTTP-响应"><a href="#浏览器接收-HTTP-响应" class="headerlink" title="浏览器接收 HTTP 响应"></a>浏览器接收 HTTP 响应</h3><p>在 HTTP 1.0 中使用的是短连接，每次请求都会使用新的 TCP 连接，而在 HTTP 1.1 中使用的是长连接，当并发请求时最多会创建 6 个 TCP 连接，之后的请求就需要等待前面的请求完成才能开始（浏览器在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数的请求会被阻塞，在 chrome 中这个限制数是 6 个），而在 HTTP 2.0 中则新增了多路复用，基于二进制分层， 可以在共享 TCP 连接的基础上同时发送请求和响应。HTTP 消息被分解为独立的帧而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。</p><p>HTTP 1.1 图示：</p><center><br>    <img src="/assets/performance/4.png" width="80%"><br></center><p>现在一般默认都是 HTTP 1.1，所以浏览器接收 HTTP 响应后会根据情况来选择是否要关闭 tcp 连接，关闭 tcp 连接的话就要进行 4 次挥手。</p><p>TCP 4 次挥手图示：</p><center><br>    <img src="/assets/performance/6.png" width="40%"><br></center><p>FIN：释放一个连接，FIN = 1 表示此报文段的发送方的数据已经发送完毕，要求释放连接。</p><p>为什么挥手需要 4 次？</p><p>因为 tcp 是全双工的，即 A 在给 B 发信息的同时，B 同时也在给 A 发信息，所以当断开的时候，必须要求双方都得知道。客户端发送一个 FIN 信号给服务器端，表示想要关闭连接，服务器端收到关闭信息告诉客户端还有数据没发好，让客户端等一下，然后服务器端再发送一个信息给客户端，表示可以关闭连接了，客户端回应服务端你关闭吧，不用理我，然后进入 time_wait 状态，服务器端收到 ack 信息就关闭了，客户端在等待 2MSL 后，服务端没东西给过来就也关闭连接。</p><h3 id="浏览器检查响应状态码"><a href="#浏览器检查响应状态码" class="headerlink" title="浏览器检查响应状态码"></a>浏览器检查响应状态码</h3><p>常见状态码：</p><ul><li>200 请求成功</li><li>301 永久重定向，浏览器需要重新发送一个 HTTP 请求到服务器返回的新地址</li><li>304 请求资源并没有改变</li><li>400 错误请求，预发或参数有误</li><li>401 未授权</li><li>403 禁止，拒绝请求</li><li>404 找不到资源</li><li>405 请求方法不被允许</li><li>500 服务器内部错误</li><li>502 错误网关</li></ul><h3 id="对响应进行解码"><a href="#对响应进行解码" class="headerlink" title="对响应进行解码"></a>对响应进行解码</h3><p>若文件很大，那下载就会比较慢，特别是网速慢的时候，所以一般会对响应数据进行压缩。浏览器发送请求一般都会携带 Accept-Encoding: gzip,deflate，若服务器对响应内容进行压缩，则会在响应头中返回 Content-Encoding: gzip，浏览器接收到响应，发现响应头中包含了 Content-Encoding 就会将响应内容进行解压。</p><h3 id="资源下载、处理"><a href="#资源下载、处理" class="headerlink" title="资源下载、处理"></a>资源下载、处理</h3><p>浏览器收到响应数据，进行渲染：</p><ol><li>DOM 树构建（parse HTML）：浏览器接收到网络传输的字节数据，会将这些字节数据转换为字符串，之后再将这些字符串通过词法分析转换为标记，标记化后将这些标记转换为 node，最后这些 node 会根据不同 node 之间的联系构建为一颗 DOM 树。</li><li>构建 CSSOM 树（Recaculate Style）：这个过程其实是一个样式的重新计算，因为浏览器本身有一套内置样式表，所以最终的 CSSOM 树其实是浏览器样式和页面所有样式的重新计算。（浏览器确定节点的样式是自右向左的，比如 div span 会先找到所有的 span，再去找到 div，然后给复合条件的 span 标签设置样式，所以我们应该尽可能避免写过于具体的 CSS）</li><li>合并 DOM 树和 CSSOM 树为 Render 树：只包括渲染页面需要的节点（不包括 display: none 的节点还有 <code>&lt;head&gt; &lt;meta&gt;</code> 等节点）。</li><li>布局（Layout）：各元素尺寸、位置的计算。</li><li>绘制（Paint）：结合渲染树和布局信息绘制实际像素。</li><li>复合图层化（Composite）：渲染层合并，由于对页面中 DOM 元素的绘制是在多个层上进行的，所以在每个层绘制完后，浏览器会将所有层按照合理的顺序合并成一个图层，显示到屏幕上。图层化是浏览器为了充分利用已有的渲染成果，最小化 GPU 运算，将 “脏区” 提升为复合图层，隔离变化影响的操作（GPU 有自己的处理器和存储器及数据处理模型）。</li></ol><p>浏览器将元素提升为一个复合层有多种原因：</p><ul><li>3D 或透视变换 css 属性，如 translate3d</li><li><code>&lt;video&gt;、&lt;iframe&gt;、&lt;canvas&gt;、&lt;webgl&gt;</code> 等元素</li><li>元素自身的 opacity 和 transform 做 css 动画</li><li>使用 will-change 属性：提前告诉浏览器要变化，这样浏览器会做一些优化工作</li><li>filters</li><li>position:fixed</li><li>元素在复合层上渲染（隐式合成）</li></ul><h2 id="性能优化要点"><a href="#性能优化要点" class="headerlink" title="性能优化要点"></a>性能优化要点</h2><p>输入 URL 之后的过程其实做了很多处理，因此在这个过程中，其实可以发现很多可以优化的地方。</p><ul><li>对资源进行强缓存，若页面代码更新，则通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新的资源</li><li>域名预解析，对页面中不在同一个域的域名进行预获取，并且缓存结果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link ref=&quot;dns-prefetch&quot; href=&quot;域名&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>使用 HTTP 2.0 （HTTP 2.0 做了很多优化，比如首部压缩、多路复用、二进制分帧等）</li><li>协商缓存</li><li>启用 GZIP</li><li>将静态资源部署到 CDN 节点上，避免图片、js、css等资源文件的请求携带 cookie</li><li>减少页面请求，如：合并 css/js 文件；将背景图合并成一个文件，通过 background-image 和 background-position 来显示；行内图片使用 Data URI Scheme，它不会被浏览器缓存，但若放在 css 的 background 中，会随着 css 被一起缓存，并且它的体积是原数据体积的 4/3，在图片很小、网络受限的时候使用最好</li><li>延迟加载：对于首屏不需显示的资源可以延迟加载</li><li>css 不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染和 js 的执行，所以应尽量扁平层级，优化选择器</li><li>js 会阻塞 DOM 的解析和渲染，所以应该将 js 放在 body 底部，或者使用 defer 延迟加载，使用 async 异步执行</li><li>压缩 js、css、图片等资源</li><li>尽量避免重排（影响布局，需要重新计算每个元素的尺寸和位置）和重绘（元素更改外观但不影响布局，不影响其他元素，比如 color）：不一条条的去修改 dom 样式，尽量使用 className 一次修改；当必须要改变一个节点会导致重排的样式时，尽量让重排次数减少，可以将节点设置 dispaly: none，做完大量修改后，再让这个元素显示，或者克隆一个节点，做完修改后，再替换文档树中的节点；避免强制同步布局（在获取某个样式——比如高度之前做了样式的更改，就会导致浏览器去提前执行布局的计算，造成多次重排），应该尽量批量读取样式，然后执行样式的修改；避免布局抖动（循环读取一个样式值，然后使用此值来更新样式，造成重复重排)；动画使用 transform，而不是修改 left 或 top</li><li>不使用 table 布局，一次小改动导致整个 table 重新布局</li><li>尽量使用 flexbox，它的运行速度更快</li><li>避免隐式合成导致的额外内存占用</li><li>尽量避免使用 setTimeout 和 setInterval，而是使用 requestAnimationFrame</li></ul><p>强制同步布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 错误写法</span><br><span class="line">el.classList.add(&apos;test&apos;);</span><br><span class="line">console.log(el.offsetWidth);</span><br><span class="line"></span><br><span class="line">// 正确写法</span><br><span class="line">console.log(el.offsetWidth);</span><br><span class="line">el.classList.add(&apos;test&apos;);</span><br></pre></td></tr></table></figure><p>布局抖动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 错误写法</span><br><span class="line">for (let i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">    list[i].style.width = el.offsetWidth + &apos;px&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确写法</span><br><span class="line">let width = el.offsetWidth;</span><br><span class="line">for (let i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">    list[i].style.width = width + &apos;px&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="chrome-开发者工具"><a href="#chrome-开发者工具" class="headerlink" title="chrome 开发者工具"></a>chrome 开发者工具</h3><p><a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">附上开发者工具文档</a></p><p>network 中请求的 waterfall 列详解：</p><blockquote><p>Queueing。 浏览器在以下情况下对请求排队：</p><ul><li>存在更高优先级的请求。</li><li>此源已打开六个 TCP 连接，达到限值。 仅适用于 HTTP/1.0 和 HTTP/1.1。</li><li>浏览器正在短暂分配磁盘缓存中的空间<br>Stalled。 请求可能会因 Queueing 中描述的任何原因而停止。<br>DNS Lookup。 浏览器正在解析请求的 IP 地址。<br>Proxy negotiation。 浏览器正在与代理服务器协商请求。<br>Request sent。 正在发送请求。<br>ServiceWorker Preparation。 浏览器正在启动 Service Worker。<br>Request to ServiceWorker。 正在将请求发送到 Service Worker。<br>Waiting (TTFB)。 浏览器正在等待响应的第一个字节。 TTFB 表示 Time To First Byte（至第一字节的时间）。 此时间包括 1 次往返延迟时间及服务器准备响应所用的时间。<br>Content Download。 浏览器正在接收响应。<br>Receiving Push。 浏览器正在通过 HTTP/2 服务器推送接收此响应的数据。<br>Reading Push。 浏览器正在读取之前收到的本地数据。</li></ul></blockquote><p>Performance 面板：结合 FPS、CPU、Main等来分析页面存在什么性能问题。</p><ul><li>蓝色(Loading)：网络通信和 HTML 解析</li><li>黄色(Scripting)：JavaScript执行</li><li>紫色(Rendering)：样式计算和布局，即重排</li><li>绿色(Painting)：重绘</li><li>灰色(other)：其它事件花费的时间</li><li>白色(Idle)：空闲时间</li></ul><p>注意 FPS 中的红色区块和 Main 中事件右上角的小三角，它们都表示对应的事件可能存在性能问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器渲染网页的过程涵盖了很多内容，这其中的每一块内容都值得我们花费更多的精力深入理解。基于底层和原理的探索，能让我们更快地在工作中定位问题，找到更好更快的解决方案，节约项目团队的开发和执行成本，或许仅仅是某个微小的进步与改变，都能给团队带来不可估量的效益与价值。同时，建立在对浏览器原理的理解上，我们能更好地与运维、后端同事进行跨职业的沟通，进一步提升工作效率，也可以更容易的寻找到项目优化的突破点，提升用户体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在浏览器输入网站域名，并按下回车之后的一段时间里，其实发生了很多事情，比如协议补全、域名解析、TCP 三次握手、发送请求、页面解析等等，因此这一过程可优化的点也很多。本文旨在阐述浏览器渲染网页时的一系列过程，在对浏览器如何工作足够了解的基础上，使用调试工具来分析页面性能，借此找到阻碍浏览器性能的问题点，从而做出相应优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="chrome" scheme="https://gromimiss.github.io/tags/chrome/"/>
    
      <category term="优化" scheme="https://gromimiss.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>移动端的一些小问题</title>
    <link href="https://gromimiss.github.io/2019/04/11/autofocus/"/>
    <id>https://gromimiss.github.io/2019/04/11/autofocus/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2019-04-14T13:17:46.152Z</updated>
    
    <content type="html"><![CDATA[<p>刚接到一个需求，只是一个很简单的页面，只包含一个输入框，却遇到了挺多的问题，有些甚至还没解决，在这里记录一下。</p><a id="more"></a><p>问题：</p><ol><li>autofocus 在 ios 上有什么解决方案吗</li></ol><p>尝试了网上的一些解决方案，发现并不起作用。</p><ol start="2"><li><p>placeholder 设置不生效（在公司原生 APP 上）</p></li><li><p>因为要在 input 中有值并且聚焦状态时显示删除 icon，所以需要去判断是否聚焦</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">focus</span>=<span class="string">"focus"</span> @<span class="attr">blur</span>=<span class="string">"blur"</span> <span class="attr">autofocus</span>=<span class="string">"autofocus"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        isFocus: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    focus() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isFocus = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    blur() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isFocus = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会有一个问题：在 ios 上 autofocus 在页面上并不会产生聚焦的效果，但是会触发 focus 事件，所以它也会显示 icon。</p><p>刚开始打算用以下方式解决的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">focus</span>=<span class="string">"focus"</span> @<span class="attr">blur</span>=<span class="string">"blur"</span> <span class="attr">autofocus</span>=<span class="string">"autofocus"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        isFocus: <span class="literal">false</span>,</span><br><span class="line">        isFirstEnter: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    focus() &#123;</span><br><span class="line">        <span class="keyword">const</span> isIOS = !!navigator.userAgent.match(<span class="regexp">/(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</span><br><span class="line">        <span class="keyword">if</span> (IOS &amp;&amp; <span class="keyword">this</span>.isFirstEnter) &#123;</span><br><span class="line">            <span class="keyword">this</span>.isFirstEnter = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.isFocus = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    blur() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isFocus = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是试了之后发现 ios 在第一次用户点击触发页面上的聚焦效果时，并不会触发 focus 事件，这就导致只能通过判断系统决定是否要设置 autofocus了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">focus</span>=<span class="string">"focus"</span> @<span class="attr">blur</span>=<span class="string">"blur"</span> <span class="attr">:autofocus</span>=<span class="string">"isIOS ? 'autofocus' : undefined"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        isFocus: <span class="literal">false</span>,</span><br><span class="line">        isIOS: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isIOS = !!navigator.userAgent.match(<span class="regexp">/(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此，就算基本的解决了这个问题，但是从根本上来讲，还是应该解决在 ios 上不 autofocus 的问题，没了这个问题也就不会有之后的一系列问题了，目前是考虑可以用 div 去模拟一个 input，这样的话样式，聚焦就都可控了，后期优化再补上。</p><ol start="4"><li>因为这个页面是在公司原生 APP 上使用的，修改之后需要返回到之前的页面，再让之前的页面的数据能够刷新，这是两个页面，返回不会刷新页面，所以也没法去触发更新数据,目前是进入修改页B前会关闭当前页A，修改完成后关闭B打开A，但是这样会有一个问题——这样是一个打开新页面的效果，而不是一个返回的效果，在移动端打开一个页面时从左到右的切换效果，而返回则是从右到左的切换效果，并且不会有刷新的问题，目前在想有没有什么两个页面间的通讯方式。</li></ol><h1 id="localStorage：因为是完全独立的两个页面，所以-localStorage-无效"><a href="#localStorage：因为是完全独立的两个页面，所以-localStorage-无效" class="headerlink" title="localStorage：因为是完全独立的两个页面，所以 localStorage 无效"></a>localStorage：因为是完全独立的两个页面，所以 localStorage 无效</h1><h1 id="window-opener"><a href="#window-opener" class="headerlink" title="window.opener"></a>window.opener</h1><h1 id="postMessage-但是是切换页面，不是两个窗口，不知道还可不可行"><a href="#postMessage-但是是切换页面，不是两个窗口，不知道还可不可行" class="headerlink" title="postMessage 但是是切换页面，不是两个窗口，不知道还可不可行"></a>postMessage 但是是切换页面，不是两个窗口，不知道还可不可行</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚接到一个需求，只是一个很简单的页面，只包含一个输入框，却遇到了挺多的问题，有些甚至还没解决，在这里记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="移动端" scheme="https://gromimiss.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>记录 OAuth 机制</title>
    <link href="https://gromimiss.github.io/2019/03/29/oauth/"/>
    <id>https://gromimiss.github.io/2019/03/29/oauth/</id>
    <published>2019-03-28T16:00:00.000Z</published>
    <updated>2019-03-30T04:45:54.385Z</updated>
    
    <content type="html"><![CDATA[<p>之前在 H5 上使用过微信的网页授权，但只是按着文档中写的流程完成了一下，并没有去注意文档中写的 OAuth 机制，最近面试被提问到，所以就去了解了下，在此记录。（本文是看了阮一峰的 oAuth 2.0 记录的，<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">原文在这里</a>）。</p><a id="more"></a><h2 id="为什么使用-OAuth"><a href="#为什么使用-OAuth" class="headerlink" title="为什么使用 OAuth"></a>为什么使用 OAuth</h2><p>OAuth 可以用来解决第三方应用获取服务提供商的资源时所需的权限问题。</p><p>第三方应用获取服务提供商的资源，有以下两种方式：</p><ul><li><p>普通方式：将服务提供商上的用户名和密码告诉第三方应用，这样就会有以下几个问题：</p><ul><li>第三方应用会保存用户的密码，导致安全问题</li><li>服务供应商需要部署密码登录，但是单纯的密码登录并不安全</li><li>第三方应用拥有了获取用户存在服务供应商上所有资料的权利，但是用户并不能限制第三方应用获得授权的范围和有效期</li><li>用户只有修改密码，才能收回权利，但是若这样做，会导致其他获得了用户授权的第三方应用也都全部失效</li><li>只有其中一个第三方应用程序被破解，就会导致用户密码泄露，以及所有的资料被泄露</li></ul></li><li><p>OAuth 方式：它会通过一个授权服务器，让第三方应用安全可控的获取用户的授权，和服务提供商进行互动</p></li></ul><h2 id="OAuth-的大概思路"><a href="#OAuth-的大概思路" class="headerlink" title="OAuth 的大概思路"></a>OAuth 的大概思路</h2><p>在第三方应用和服务提供商之间设置一个授权服务器，第三方应用不能直接登录到服务提供商，而是只能登录到授权服务器，通过得到的令牌去获取服务供应商上用户的资料，并且用户可以指定授权令牌的权限范围和有效期。</p><h2 id="OAuth-的四种授权方式"><a href="#OAuth-的四种授权方式" class="headerlink" title="OAuth 的四种授权方式"></a>OAuth 的四种授权方式</h2><ul><li>授权码模式</li></ul><p>是功能最完整、流程最严密的授权模式，通过第三方应用的后台服务器与服务提供商的授权服务器进行互动。</p><p>步骤：</p><center><br>    <img src="/assets/oauth/1.png" width="80%"><br></center><ol><li><p>用户访问第三方应用</p></li><li><p>第三方应用将用户导向授权服务器</p></li><li><p>让用户选择是否授权，若用户同意授权，则授权服务器会重定向到第三方应用事先指定的重定向 uri 上，并且在 uri 的后面加上参数授权码</p></li><li><p>第三方应用收到授权码，带着应用的唯一标识、密钥、授权码以及重定向的 uri，向授权服务器申请令牌（在第三方应用的后台和服务器上完成，用户不可见）</p></li><li><p>授权服务器核对授权码和 uri，确认无误后，向第三方应用返回 access token 和 refresh token</p></li></ol><ul><li>隐式授权模式</li></ul><p>不通过第三方应用的服务器，直接在浏览器中向认证服务器申请令牌，跳过了授权码这个步骤，令牌对访问者是可见的。</p><p>步骤：</p><ol><li><p>第三方应用将用户导向授权服务器</p></li><li><p>用户选择是否给予第三方应用授权</p></li><li><p>若用户给予授权，则授权服务器会将用户导向之前第三方应用指定的重定向 uri，并在 uri 的 hash 部分包含了 access_token</p></li><li><p>浏览器向服务供应商发出请求，服务供应商返回一个网页，其中包含了可以获取 hash 值中的令牌</p></li><li><p>浏览器执行上一步获得的脚本，提取出令牌，将令牌发给客户端</p></li></ol><ul><li>密码模式</li></ul><p>用户向第三方应用提供自己的用户名和密码，第三方应用使用这些信息向服务提供商索要授权，但不能存储密码，通常在用户对第三方应用高度信任的时候使用。</p><ul><li>客户端认证模式</li></ul><p>第三方应用以自己的名义，向服务提供商进行认证，这种模式下，用户直接在第三方应用注册，第三方应用以自己的名义要求服务提供商提供服务，其实是不存在授权问题的</p><h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>若第三方应用的 access_token 过期，则要使用之前返回的 refresh_token 来重新申请一个新的 access_token。</p><h2 id="微信授权流程"><a href="#微信授权流程" class="headerlink" title="微信授权流程"></a>微信授权流程</h2><p>微信公众号就是通过 OAuth2.0 机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权 access_token），通过网页授权的 access_token 进行授权后接口调用，如获取用户基本信息。</p><p>若开发者有多个公众号，或者在公众号、移动应用之间有统一用户账号的需求，需要前往开发者平台绑定公众号后，利用 UnionID 机制来满足上述需求：开发者拥有多个移动应用、公众账号，可通过获取用户基本信息中的 UnionID 来区分用户的唯一性，因为同一用户，对同一个微信开发平台下的不同应用 unionid 是相同的。</p><p>微信授权步骤如下：</p><ol><li><p>引导用户进入授权页面同意授权，（传入 scope、redirect_url、appid、response_type、state）调用接口后会跳转到传入的 redirect_url，url 的后面会带上 code 和 state 参数</p></li><li><p>code作为换取 access_token 的票据，每次用户授权带上的 code 都不一样，只能使用一次，5分钟未使用就会自动过期，通过 code 换取网页授权 access_token 和 openid（要传入 appid、secret、code、grant_type）</p></li><li><p>若需要，可以刷新网页授权 access_token，避免过期（使用之前获取到的 refresh_token 进行刷新，它的有效期是 30 天）</p></li><li><p>通过网页授权 access_token 和 openid 获取用户基本信息（若 scope 为 snsapi_userinfo，通过传入参数 open_id 和 access_token拉取用户信息，包含了 unionid）</p></li></ol><p>scope 有两种：snsapi_base 静默授权，可以获取 openid，用户感知不到，能感知到的就是直接进入了回调页，snsapi_userinfo 是用来获取用户的基本信息的，但是这种授权需要用户手动同意，并且如果已经关注公众号的用户，如果从公众号的会话或者是自定义菜单中进入本公众号的网页授权页，即便 scope 是 snapi_userinfo 也是静默授权，用户无感知。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在 H5 上使用过微信的网页授权，但只是按着文档中写的流程完成了一下，并没有去注意文档中写的 OAuth 机制，最近面试被提问到，所以就去了解了下，在此记录。（本文是看了阮一峰的 oAuth 2.0 记录的，&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文在这里&lt;/a&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OAuth" scheme="https://gromimiss.github.io/tags/OAuth/"/>
    
      <category term="微信授权" scheme="https://gromimiss.github.io/tags/%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>自己手写一个 Promise</title>
    <link href="https://gromimiss.github.io/2019/03/23/promise/"/>
    <id>https://gromimiss.github.io/2019/03/23/promise/</id>
    <published>2019-03-22T16:00:00.000Z</published>
    <updated>2019-03-30T04:27:17.461Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 作为异步回调地狱的解决方案，在项目中用到的特别多。但是之前从来没有去研究过它的实现原理，这次就想对照着规范一步步的实现，加深对 Promise 的理解，也可以了解到更多可能平常项目中很少遇到的情况。</p><a id="more"></a><h2 id="Promise-A-规范："><a href="#Promise-A-规范：" class="headerlink" title="Promise/A+ 规范："></a>Promise/A+ 规范：</h2><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">规范原文在这里</a>。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li>promise 是一个符合这个规范的拥有 then 方法的对象或是函数</li><li>thenable 是声明了 then 方法的对象或函数</li><li>value 可以是任意合法的 js 值（包括了 undefined，thenable 对象或者是一个 promise）</li><li>exception 是使用 throw 语法抛出的一个值</li><li>reason 是指明为什么 promise 被 rejected 的一个值</li></ul><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li><p>Promise 状态：一个 promise 必须是 3 个状态中的一个（pending，fullfilled，rejected）</p><ul><li>当 pending，一个 promise 可能转变为 fullfilled 或是 rejected</li><li>当 fulfilled，一个 promise 不能再转变成其他状态，并且会得到一个也不能改变的 value（不包括对象的属性改变）</li><li>当 rejected，一个 promise 不能再转变成其他状态，并且会得到一个也不能改变的 reason（不包括对象的属性改变）</li></ul></li><li><p>then 方法：一个 promise 需要提供一个 then 方法去访问它当前或是最终的 value 或 reason，它接受两个参数 onFulfilled 和 onRejected</p><ul><li>onFulfilled 和 onRejected 都是可选的参数，当它们不是一个函数或者没有传入时，都会被包装为一个函数</li><li>若 onFulfilled 是一个函数，它必须在 promise 为 fulfilled 状态后被调用，并且将 promise 的 value 作为它的第一个参数，并且不能被调用多次</li><li>若 onRejected 是一个函数，它必须在 promise 为 rejected 状态后被调用，并且将 promise 的 reason 作为它的第一个参数，并且不能被调用多次</li><li>在下一个 stack 中被调用</li><li><p>then 在相同的 promise 上可能会被多次调用（定义一个 promise， 在这个 promise 上多次调用 then），当 promise 是 fulfilled 状态时，会按绑定时 then 的顺序来依次调用 onFulfilled 回调；当 promise 是 rejected 状态时，也会按绑定时 then 的顺序来依次调用 onRejected 回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">200</span>);</span><br><span class="line">    &#125;, <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));</span><br><span class="line">p1.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)); <span class="comment">// 执行多次会被存放在回调列表中</span></span><br></pre></td></tr></table></figure></li><li><p>then 必须返回一个 promise</p><ul><li>若 onFulfilled 或者 onRejected 返回一个值 x，则执行 promise 解决程序</li><li>若它们抛出一个异常 e 则 promise2 必须将 e 作为原因被 rejected</li><li>如果 onFulfilled 不是一个函数并且 promise1 已经 fulfilled，promise2 必须用 promise1 中的值作为参数传给 promise2 中的 then</li><li>如果 onRejected 不是一个函数并且 promise1 已经 rejected，promise2 必须用 promise1 中的错误原因作为参数传给 promise2 中的 then</li></ul></li></ul></li><li><p>promise 解决程序：promise 解决函数会将 promise 和 value 作为参数，若 x 是一个 thenable 对象，它会尝试让 promise 采用 x 的状态，不然就会用 x 来完成 promise（thenable 允许我们可以实现 promise 间的互操作，只要它们提供 Promise/A+ 规范的 then 方法，并且使用合理的方法同化不一致的实现）。</p><ul><li><p>若 promise 和 x 是同一个对象，则将一个 TypeError 作为 promise reject 的原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);  <span class="comment">// 会执行 onRejected 回调，打印 TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>若 x 是一个 promise 并且还在 pending 状态时，会继续验证 x 中的值 y，递归调用 resolution(promise, y)，直到最后是一个不为对象或函数的值，而若 x 已经是 fulfilled 或 rejected 时，则说明 x 的值肯定为一个最后的值了，就将 promise2 的 resolve 传递给 x.then 的 onFulfilled，promise2 的 reject 传递给 x.then 的 onRejected（由 x 去调用 promise2 的处理）</p></li><li>若 x 是一个对象或者是函数<ul><li>若 x.then 的结果抛出一个异常 e，则将 e 作为参数 reject promise</li><li>若 x.then 是一个函数，则将 x 作为 this ，resolvePromise 作为第一个参数，rejectPromise 作为第二个参数执行，当 resolvePromise 将 y 作为参数被调用时， 执行 resolution(promise, y)，当 rejectPromise 将 r 作为参数被调用时，将 r 作为参数 reject promise，并且 resolvePromise 和 rejectPromise 中只有一个会被调用，晚调用的会被忽略，若 x.then 调用时抛出了异常，resolvePromise 和 rejectPromise 会被忽略，将异常作为参数 reject promise</li></ul></li><li>若 x 不是一个对象或者函数，则直接fulfill promise</li></ul></li></ul><p>注：将 resolve 和 reject 中的代码放在 setTimeout 中，意味着要下次事件循环才会执行(状态的变更已经回调调用)，那么 then 就会被先调用，此时 then 中的 state 肯定是 pending，所以只用 then 调用是在 setTimeout（下一个事件循环中），then 中的 state 才会是 fulfilled 或 rejected 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)); <span class="comment">// 这个时候 state 为 pending</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p1.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)); <span class="comment">// 这个时候 state 为 rejected 了</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="基本的-Promise"><a href="#基本的-Promise" class="headerlink" title="基本的 Promise"></a>基本的 Promise</h2><p>根据上面 Promise/A+ 来写一个规范的 Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义三个常量状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.resolvedCbs = [];</span><br><span class="line">    <span class="keyword">this</span>.rejectedCbs = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用在 Promise 的构造函数中传入的函数：所以 Promise 传入函数中的代码是立即执行的</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在下个事件循环中改变state、value的值，并且执行之前在等待状态时未调用的函数</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">                self.state = RESOLVED;</span><br><span class="line">                self.value = value;</span><br><span class="line">                self.resolvedCbs.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">                self.state = REJECTED;</span><br><span class="line">                self.value = value;</span><br><span class="line">                self.rejectedCbs.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. then中传入的函数就是需要在状态变为完成后调用的（即回调）</span></span><br><span class="line"><span class="comment">// 2. 若状态还是等待中，在当前 promise 对象中添加回调</span></span><br><span class="line"><span class="comment">//    这个回调中会将当前 promise 对象的 value 作为参数，</span></span><br><span class="line"><span class="comment">//    执行传入的函数（所以第二个 then 会等前一个 then 执行后才被调用,并且会得到第一个 then 中的 value），</span></span><br><span class="line"><span class="comment">//    再返回一个新的promise对象</span></span><br><span class="line"><span class="comment">// 3. 若状态已经是完成，则直接调用传入的函数</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled: <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> &#123; <span class="keyword">throw</span> r &#125;;</span><br><span class="line">    <span class="keyword">if</span> (self.state === PENDING) &#123;</span><br><span class="line">        <span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            self.resolvedCbs.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> x = onFulfilled(self.value);</span><br><span class="line">                    <span class="comment">// 兼容不同的Promise，如JQuery和ES6的</span></span><br><span class="line">                    _resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            self.rejectedCbs.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> x = onRejected(self.value);</span><br><span class="line">                    _resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.state === RESOLVED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> x = onFulfilled(self.value);</span><br><span class="line">                    _resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.state === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> x = onRejected(self.value);</span><br><span class="line">                    _resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 防止循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>));</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        x.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            _resolutionProcedure(promise2, value, resolve, reject);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否已经调用过函数</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                then.call(</span><br><span class="line">                    x,</span><br><span class="line">                    val =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        _resolutionProcedure(promise2, val, resolve, reject);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    e =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以若 then 中有 reject 回调，则 catch 将不会被触发</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p>检验自己手写的 Promise 是否写的规范，可以使用 promises-aplus-tests。</p><ul><li>下载 promises-aplus-tests</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i promises-aplus-tests -g</span><br></pre></td></tr></table></figure><ul><li>在 promise.js 中添加一个方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.deferred = <span class="built_in">Promise</span>.defer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> defer = &#123;&#125;;</span><br><span class="line">    defer.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        defer.resolve = resolve;</span><br><span class="line">        defer.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> defer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在项目中执行命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests promise.js</span><br></pre></td></tr></table></figure><h2 id="Promise-上的其他方法"><a href="#Promise-上的其他方法" class="headerlink" title="Promise 上的其他方法"></a>Promise 上的其他方法</h2><p>添加在类上的一些方法。</p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>返回一个给定值解析后的 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>返回一个带有拒绝原因的 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>当 Promise.all 传入的 promises 数组中都成功的时候才会执行 onFulfilled 回调，并且回调中会带一个参数 —— promises 解析后的值组成的数组（按传入 promises 的顺序），只有其中有一个 promise 失败，就会执行 onRejected 回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">i, data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 按存入的 promise 顺序存放结果</span></span><br><span class="line">            result[i] = data;</span><br><span class="line">            <span class="keyword">if</span> (++count === promises.length) &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(done.bind(<span class="keyword">this</span>, i), reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>当其中有一个 promise 成功或失败就会返回，当多个接口都不稳定时，可取多个接口，谁先回来用谁的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            promises[i].then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Promise 中的 resolutionProcedure 还是挺绕的，有的时候真的是想不到这么多情况，所以还是需要多思考多学习，不断的加深印象，当理解之后使用它就变得特别轻松了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise 作为异步回调地狱的解决方案，在项目中用到的特别多。但是之前从来没有去研究过它的实现原理，这次就想对照着规范一步步的实现，加深对 Promise 的理解，也可以了解到更多可能平常项目中很少遇到的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="异步" scheme="https://gromimiss.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 4 总结</title>
    <link href="https://gromimiss.github.io/2019/03/19/webpack/"/>
    <id>https://gromimiss.github.io/2019/03/19/webpack/</id>
    <published>2019-03-18T16:00:00.000Z</published>
    <updated>2019-03-23T01:19:01.856Z</updated>
    
    <content type="html"><![CDATA[<p>以前用的 webpack 版本还是 2.6.1，现在 webpack 都更新到 4.29.6 了。最近学习了下 webpack 4，并且动手使用了下，感觉其中改变还蛮大的，就此作出一个总结。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="为什么要使用-webpack？"><a href="#为什么要使用-webpack？" class="headerlink" title="为什么要使用 webpack？"></a>为什么要使用 webpack？</h3><p>随着功能点的增加，浏览器本身又不提供模块管理的机制，为了简化开发的复杂度，提升开发效率，模块化、CSS 预处理器、各种框架层出不穷，并且还有 JS 的一些还没被浏览器支持的新特性，所以一整个项目里会包含着一大堆的 JS 代码和依赖包，前端项目越来越臃肿，越来越难以维护，而这个时候 webpack 出现了。</p><h3 id="什么是-webpack"><a href="#什么是-webpack" class="headerlink" title="什么是 webpack"></a>什么是 webpack</h3><p>webpack 可以看做是一个模块打包机，它会分析你的项目结构，将一堆文件中的每个文件都作为一个模块，找出他们的依赖关系，将 js 模块以及其他一些浏览器不能直接运行的拓展语言（typescript、sass等）打包为合适的格式供浏览器来使用。</p><p>它拥有着庞大的社区，可以用来进行代码转换、文件优化、代码分割、模块合并、自动刷新、代码校验、自动发布等。</p><h3 id="与其他工具的对比"><a href="#与其他工具的对比" class="headerlink" title="与其他工具的对比"></a>与其他工具的对比</h3><p>Grunt/Gulp: 都属于 Task Runner，一般用来优化前端工作流程，比如自动刷新页面、压缩 css、压缩 js、编译 sass等。它的工作方式是：在一个配置文件中，指明对某些文件进行类似编译、组合、压缩等任务的具体步骤，之后工具就会自动完成这些任务。</p><p>Webpack: 是一种模块化的解决方案，通过项目中的依赖关系产出最后的静态资源，它能拆分依赖树并按需加载，上面工具完成的工作它都可以胜任。</p><h2 id="webpack-的使用"><a href="#webpack-的使用" class="headerlink" title="webpack 的使用"></a>webpack 的使用</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li>Entry：入口，作为 webpack 构建的第一步来找出依次的依赖关系</li><li>Module：模块，在 webpack 中一切皆模块，一个模块对应着一个文件，webpack 会通过 Entry 开始递归找出所有依赖的模块</li><li>Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并及分割</li><li>Loader：模块转换器，将模块原内容按需转换成新内容</li><li>Plugin：扩展插件，在构建流程中的特定时机注入扩展逻辑来改变构建结果</li><li>Output：输出结果，在经过一系列处理并得到最终想要的代码后输出结果</li></ul><p>Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module，每找到一个 Module，就会根据配置的 Loader 去找对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 会被分到一个 Chunk。最后 webpack 会将所有 Chunk 转换成文件输出，在整个流程中 webpack 会在恰当的时机执行 Plugin 里定义的逻辑。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ol><li><p>webpack 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure><p>执行 webpack 可以通过两种方式：</p><ul><li>npx 可以直接运行 node_modules/.bin目录下面的命令</li><li>通过配置 package.json 中的 script: { “build”: “webpack”}</li></ul></li><li></li></ol><ul><li>mode: 模式，有两种（production development），默认是 production</li><li><p>entry: 打包的入口文件</p><p>单入口(只打包一个文件)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: <span class="string">'./src/index.js'</span></span><br></pre></td></tr></table></figure><p>多入口打包成多个文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123; </span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    base: <span class="string">'./src/base.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多入口打包成一个文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: [<span class="string">'./src/index.js'</span>, <span class="string">'jquery'</span>] <span class="comment">// 相当于 entry: &#123; main: ['./src/index.js', 'jquery']&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>output: 出口配置<br>filename中的 name 是 entry 中对象的属性名，若 entry 是字符串或者是数组，则默认会是 main，hash 则是根据打包后的文件内容计算出来的 hash 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>) <span class="comment">// 打包后的文件的输出目录</span></span><br><span class="line">    publicPath: <span class="string">''</span> <span class="comment">// 当资源托管到 CDN 时可使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>module: 在 module 中可以配置 loader，loader 的执行顺序是从右向左，从下向上的;也可以配置 noParse，指定的包不用去解析其中的依赖关系（若这个包中没有依赖项）</p></li><li><p>devServer：开发服务器的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    port: <span class="number">8080</span>, <span class="comment">// 端口号</span></span><br><span class="line">    progress: <span class="literal">true</span>, <span class="comment">// 是否显示进度条</span></span><br><span class="line">    contentBase: <span class="string">'./build'</span>, <span class="comment">//</span></span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">// 启动服务器的 gzip 压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>externals：指定某些包是外部引入的，不需要打包</p></li><li><p>devtool：增加映射文件，帮我们调试源代码</p><ul><li>source-map：会单独生成一个 sourcemap 文件，出错了会显示当前报错的行和列</li><li>eval-source-map：不会产生单独的文件（集成到源文件中），但是可以显示行和列</li><li>cheap-module-source-map：不会显示列，会生成一个单独的映射文件，没有调试的功能，产生后可以保留起来以便之后调试</li><li>cheap-module-eval-source-map：不会产生文件，集成在打包文件中，会定位到行，不会定位到列</li></ul></li><li><p>resolve：解析第三方包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">'node_modules'</span>)], <span class="comment">// 只需要从这个目录中查找第三方包</span></span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.css'</span>], <span class="comment">// 若导入时没有添加扩展名，会根据这里的配置顺序去查找文件</span></span><br><span class="line">    alias: &#123; <span class="comment">// 别名</span></span><br><span class="line">        bootstrap: <span class="string">'bootstrap/dist/css/bootstrap.css'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mainFields: [<span class="string">'style'</span>, <span class="string">'main'</span>] <span class="comment">// 先找package.json中的 style，再找 main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>optimization：优化</p><p>比如：多页应用可以将公共的代码抽离出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123; <span class="comment">// 分割代码块</span></span><br><span class="line">        cacheGroups: &#123; <span class="comment">// 缓存组</span></span><br><span class="line">            common: &#123; <span class="comment">// 公共的代码</span></span><br><span class="line">                chunks: <span class="string">'initial'</span>,</span><br><span class="line">                minSize: <span class="number">0</span>,</span><br><span class="line">                minChunks: <span class="number">2</span> <span class="comment">// 引入 2 次及以上就被抽离</span></span><br><span class="line">            &#125;,</span><br><span class="line">            vendor: &#123;</span><br><span class="line">                priority: <span class="number">1</span>, <span class="comment">// 先抽离第三方模块</span></span><br><span class="line">                test: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                chunks: <span class="string">'initial'</span>,</span><br><span class="line">                minSize: <span class="number">0</span>,</span><br><span class="line">                minChunks: <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>watch: 在初始构建之后，webpack 将继续监听任何已解析文件的更改，若有更新就重新打包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: <span class="literal">true</span>,</span><br><span class="line">watchOptions: &#123;</span><br><span class="line">    aggregateTimeout: <span class="number">300</span>, <span class="comment">// 当第一个文件更改，会在重新构建前增加延迟，它允许 webpack 将这段时间内进行的任何其他更改都聚合到一次重新构建里</span></span><br><span class="line">    poll: <span class="number">1000</span> <span class="comment">// 每秒检查一次变动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用的-loader"><a href="#常用的-loader" class="headerlink" title="常用的 loader"></a>常用的 loader</h3><p>loader 一般都是单个 loader 负责单一的功能</p><ul><li><p>expose-loader：把一个模块暴露为一个全局变量 <code>expose-loader?$!jquery</code></p></li><li><p>url-loader：可以在文件较小的时候，直接变成 base64 字符串内嵌到页面中（体积会比源文件大1/3，但是可以减少 http请求）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(png|jpg|gif|bmp|svg)$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            limit: <span class="number">9</span> * <span class="number">1024</span>,</span><br><span class="line">            outputPath: <span class="string">'images/'</span><span class="comment">// 输出目录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>file-loader：解析图片地址，会将图片从原位置拷贝到目标位置并且修改原引用位置</p></li><li><p>html-withimg-loader：将 html 中引用的图片地址替换为实际的路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">    use: <span class="string">'html-withimg-loader'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>css-loader：解析 css 中的 @import/require 这种语法</p></li><li><p>sass-loader：把 sass 解析为 css</p></li><li><p>style-loader：将 css 插入到 html 的 head 中</p></li><li><p>postcss-loader：使用 PostCSS 加载和转译 CSS 文件，可以用来添加浏览器前缀（当然不止这个功能）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        <span class="string">'css-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>babel-loader：将 ES6 语法转换成浏览器都支持的 ES5</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除不需要转译的目录</span></span><br><span class="line">    use: &#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">            plugins: [<span class="string">'@babel/transform-runtime'</span>] <span class="comment">// 引入 babel runtime 作为一个独立模块，来避免重复引入（若不使用，babel 会自动对每个文件 runtime 注入）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@babel/core: 核心 api</li><li>@babel/preset-flow: 删除静态类型注释</li><li>@babel/cli: 允许你从终端使用 babel</li><li>@babel/preset-env: 将 ES6+ 转换为 ES5，默认转换语法，不转换新的 API</li><li>@babel/polyfill: 会污染全局环境，在不支持某些 API 的浏览器中添加全局函数，比如像 Array.from 或 Object.assign，它是需要在源代码之前运行的 polyfill，下载时要 –save，可以配合 useBuiltIns 选项，当它设置为 usage 时，Babel 将检查你的所有代码，以查找目标环境中缺少的功能，并仅包含所需的 polyfill</li><li>@babel/runtime: 只包含 helpers，要和 @babel/plugin-transform-runtime 一起用，它不会在每个用到某个特性的文件中都使用指定的函数，而是会引入 helpers 库中的函数</li></ul></li></ul><ul><li><p>eslint-loader: 校验 js 代码</p></li><li><p>vue-loader: 解析 vue 文件，将其中的 script、style、template提取出来，交给对应的 loader 去处理（它会根据 lang 特性以及你 webpack 配置中的规则自动推断出要使用的 loader）</p></li></ul><h3 id="常用的-plugin"><a href="#常用的-plugin" class="headerlink" title="常用的 plugin"></a>常用的 plugin</h3><ul><li><p>html-webpack-plugin: 自动产出 html 文件，配置了 title，则可以在模板文件的 title 标签中添加 <code>&lt;%= htmlWebpackPlugin.options.title %&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">'./src/index.html'</span>, <span class="comment">// 模板文件</span></span><br><span class="line">    filename: <span class="string">'index.html'</span>, <span class="comment">// 产出 html 的文件名称</span></span><br><span class="line">    title: <span class="string">'hello world'</span>, <span class="comment">// html 中 title 标签存放的标题</span></span><br><span class="line">    hash: <span class="literal">true</span>, <span class="comment">// 资源文件后会加一串 hash 值，若引入的资源文件有更新，则会重新加载，而不是从缓存中取</span></span><br><span class="line">    chunks: [<span class="string">'index'</span>, <span class="string">'vendor'</span>], <span class="comment">// 在产出的 html 中引入的代码块</span></span><br><span class="line">    minify: &#123; <span class="comment">// 对 html 做压缩处理</span></span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span>, <span class="comment">// 删除属性的双引号</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span> <span class="comment">// 一行显示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>mini-css-extract-plugin: 将 css 抽离出来输出到一个文件中，若要抽离成多个可以多 new 几个（原来都是用 extract-text-webpack-plugin，但如今这个插件和 webpack 4 不太兼容）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                MiniCssExtractPlugin.loader,</span><br><span class="line">                <span class="string">'css-loader'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">'index.css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>optimize-css-assets-webpack-plugin：压缩 CSS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimizations: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">        <span class="keyword">new</span> OptimizeCss()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uglifyjs-webpack-plugin: 压缩 js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">optimizations: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">        <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">            cache: <span class="literal">true</span>, <span class="comment">// 是否使用缓存</span></span><br><span class="line">            paraller: <span class="literal">true</span>, <span class="comment">// 是否并发打包</span></span><br><span class="line">            sourceMap: <span class="literal">true</span> <span class="comment">// 是否添加映射文件</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>webpack.ProvidePlugin: 在每个模块中注入一个变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: <span class="string">'jquery'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>clean-webpack-plugin：在打包之前删除原先打包的文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">    cleanOnceBeforeBuildPatterns: path.resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>copy-webpack-plugin: 将某文件夹复制一份到打包目录下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CopyWebpackPlugin([&#123;</span><br><span class="line">    <span class="keyword">from</span>: <span class="string">'./doc'</span>,</span><br><span class="line">    to: <span class="string">'./doc'</span></span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure></li><li><p>webpack.BannerPlugin: 在打包后的 js 文件中添加版权声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure></li><li><p>webpack.DefinePlugin: 定义全局变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    DEV: <span class="built_in">JSON</span>.stringify(<span class="string">'production'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>webpack.DLLPlugin: 抽离第三方库（比较稳定、不会轻易改变），这样在浏览器中就只会在第一次加载，之后都会缓存，它只需要初构建的时候打包一次(经测试速度快了 2 倍多，但就是两个地方不好：一是需要自己手动在模板文件中引入第三方库，二则是若第三方包有更新，还要自己手动再去执行第三方库的打包，有时候可能会忘记)，而 commons-chunk-plugin 主要用来提取公共包，它每次构建都会重新打包，就会增加编译时间（现使用 splitChunks）</p><p>在另一个打包配置文件下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'vue'</span>, <span class="string">'vuex'</span>, <span class="string">'vue-router'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'_dll_[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    library: <span class="string">'_dll_[name]'</span> <span class="comment">// 产生的变量名</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DLLplugin(&#123;</span><br><span class="line">        name: <span class="string">'_dll_[name]'</span>, <span class="comment">// name === library</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'build'</span>, <span class="string">'manifest.json'</span>) <span class="comment">// 输出的清单目录</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在主打包配置文件中引入打包出来的第三方库：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DLLReferencePlugin(&#123; <span class="comment">// 先去清单中找变量，找不到再去真正打包</span></span><br><span class="line">    manifest: path.resolve(__dirname, <span class="string">'build'</span>, <span class="string">'manifest.json'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>happypack：可以实现多线程打包(项目大的时候可以使用，项目小的时候可能打包时间反而会更久，因为分配线程的过程中也会浪费一些性能)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: <span class="string">'Happypack/loader?id=js'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Happypack(&#123;</span><br><span class="line">    id: <span class="string">'js'</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            presets: [</span><br><span class="line">                <span class="string">'@babel/preset-env'</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>webpack.HotModuleReplacementPlugin: 热更新插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure></li></ul><h3 id="scope-hosting"><a href="#scope-hosting" class="headerlink" title="scope hosting"></a>scope hosting</h3><p>scope hosting: 作用域提升，在 webpack 3 中新增的功能，它会自动省略一些可以简化的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = a + b;</span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 会变成 console.log(1 + 2)</span></span><br></pre></td></tr></table></figure><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>import(): 属于 es6 草案中的语法，通过 jsonp 实现动态加载，会返回一个 Promise 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./src/index.js'</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.default); <span class="comment">// ./src/index.js' 中导出的数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="适用于-vue-项目的优化配置"><a href="#适用于-vue-项目的优化配置" class="headerlink" title="适用于 vue 项目的优化配置"></a>适用于 vue 项目的优化配置</h3><h4 id="将开发环境与生产环境分离："><a href="#将开发环境与生产环境分离：" class="headerlink" title="将开发环境与生产环境分离："></a>将开发环境与生产环境分离：</h4><ul><li>开发时产生的debug或者是测试的代码不应出现在生产环境中</li><li>将页面部署到服务器时，会对代码进行各种优化，破坏代码可读性，不利于debug等工作</li><li>数据源差异，开发时，读取的往往是本地mock的数据</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>DllPlugin + DllReferencePlugin 和 splitChunks 可以一起使用，通过 splitChunks 把公共的部分抽离出来，DllPlugin 则抽离不易变动的第三方库，本来想尝试下在开发环境上加上 DllPlugin ，但是由于起服务使用内存来存储webpack开发环境下的打包文件，找不到另外打包出来的第三方库，并且开发环境上本来也是热更新的，所以就不再加了。</p><ol><li><p>先创建一个基础的配置文件 webpack.base.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> resolveCur = <span class="function"><span class="keyword">function</span>(<span class="params">...p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(__dirname, ...p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        resolve: &#123;</span><br><span class="line">            modules: [resolveCur(<span class="string">'../node_modules'</span>)],</span><br><span class="line">            extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">            alias: &#123; <span class="attr">vue$</span>: <span class="string">'vue/dist/vue.common.js'</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        resolveLoader: &#123; <span class="attr">modules</span>: [resolveCur(<span class="string">'../node_modules'</span>)] &#125;,</span><br><span class="line">        <span class="built_in">module</span>: &#123;</span><br><span class="line">            rules: [</span><br><span class="line">                &#123;</span><br><span class="line">                    test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                    use: <span class="string">'vue-loader'</span></span><br><span class="line">                &#125;,</span><br><span class="line">            </span><br><span class="line">                &#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                    use: [</span><br><span class="line">                        &#123; </span><br><span class="line">                            loader: <span class="string">'babel-loader'</span> </span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">                            options: &#123; </span><br><span class="line">                                ignorePattern: eslintIgnore, <span class="comment">// 不需要检验的正则匹配</span></span><br><span class="line">                                formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>),</span><br><span class="line">                                useEslintrc: <span class="literal">false</span>,</span><br><span class="line">                                parser: <span class="string">'babel-eslint'</span>,</span><br><span class="line">                                parserOptions: &#123; <span class="attr">sourceType</span>: <span class="string">'module'</span> &#125;,</span><br><span class="line">                                env: [<span class="string">'browser'</span>],</span><br><span class="line">                                plugins: [</span><br><span class="line">                                    <span class="string">'html'</span></span><br><span class="line">                                ],</span><br><span class="line">                                rules: eslintRules <span class="comment">// rules 配置文件</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">                    use: <span class="string">'html-withimg-loader'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    test: <span class="regexp">/\.(png|jpe?g|gif|bmp|svg)(\?.*)?$/</span>,</span><br><span class="line">                    use: &#123;</span><br><span class="line">                        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                        options: &#123; </span><br><span class="line">                            limit: <span class="number">9</span> * <span class="number">1024</span>,</span><br><span class="line">                            outputPath: <span class="string">'images/[name].[hash:7].[ext]'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    test: <span class="regexp">/\.(woff2|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">                    use: &#123;</span><br><span class="line">                        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                        options: &#123; </span><br><span class="line">                            limit: <span class="number">9</span> * <span class="number">1024</span>,</span><br><span class="line">                            outputPath: <span class="string">'fonts/[name].[hash:7].[ext]'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> VueLoaderPlugin(), <span class="comment">// 会将你定义过的其它规则复制并应用到 .vue 文件里相应语言的块</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>创建开发环境的配置文件 webpack.dev.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>)();</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> FriendlyErrorsPlugin = <span class="built_in">require</span>(<span class="string">'friendly-errors-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: [</span><br><span class="line">            <span class="string">'webpack-hot-middleware/client?reload=true&amp;quiet=true'</span>, </span><br><span class="line">            path.resolve(__dirname, <span class="string">'../src/dev/index.js'</span>) </span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">        publicPath: <span class="string">'/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        noEmitOnErrors: <span class="literal">true</span>, <span class="comment">//在编译出现错误时跳过输出阶段,确保输出资源不会包含错误</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'vue-style-loader'</span>,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                    <span class="string">'postcss-loader'</span>, <span class="comment">// 会从样式文件所在目录慢慢往上找，直到根目录</span></span><br><span class="line">                    <span class="string">'sass-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'vue-style-loader'</span>,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                    <span class="string">'postcss-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'template.html'</span>,</span><br><span class="line">            filename: <span class="string">'index.html'</span>, <span class="comment">// 产出 html 的文件名称</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> FriendlyErrorsPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建起服务的文件 dev-server.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./check-version'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">'ora'</span>);</span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> staticMiddleware = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackMiddleware = <span class="built_in">require</span>(<span class="string">'koa-webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> historyFallback = <span class="built_in">require</span>(<span class="string">'koa2-history-api-fallback'</span>);</span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.dev'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(webpackConfig);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> staticPath = path.posix.join(process.cwd(), webpackConfig.output.publicPath);</span><br><span class="line">    </span><br><span class="line">app.use(staticMiddleware(staticPath));</span><br><span class="line">app.use(historyFallback());</span><br><span class="line"><span class="keyword">const</span> webpackMiddlewareInstance = webpackMiddleware(&#123;</span><br><span class="line">    compiler,</span><br><span class="line">    hot: &#123; <span class="attr">log</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    dev: &#123;</span><br><span class="line">        quiet: <span class="literal">true</span>,</span><br><span class="line">        publicPath: webpackConfig.output.publicPath</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(webpackMiddlewareInstance);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spinner = <span class="keyword">new</span> ora(<span class="string">'等待 webpack 打包完成...'</span>);</span><br><span class="line">spinner.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> port = <span class="number">8080</span>;</span><br><span class="line">app.listen(port).on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="string">'EADDRINUSE'</span>) &#123;</span><br><span class="line">        port += <span class="number">1</span>;</span><br><span class="line">        app.listen(port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">webpackMiddlewareInstance.dev.waitUntilValid(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    spinner.stop();</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`http://localhost:<span class="subst">$&#123;port&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'opn'</span>)(url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建 vendor 的配置文件 webpack.vendor.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        vendor: [<span class="string">'vue/dist/vue.common.js'</span>, <span class="string">'vue-router'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'_dll_[name].js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">        library: <span class="string">'_dll_[name]'</span> <span class="comment">// 产生的变量名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            name: <span class="string">'_dll_[name]'</span>, <span class="comment">// name === library</span></span><br><span class="line">            context: __dirname,</span><br><span class="line">            path: path.resolve(__dirname, <span class="string">'../dist'</span>, <span class="string">'manifest.json'</span>) <span class="comment">// 输出的清单目录</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>创建生产环境的配置文件 webpack.prod.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>)();</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCssPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">    mode: <span class="string">'production'</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: path.resolve(__dirname, <span class="string">'../src/dev/index.js'</span>) </span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">        filename: <span class="string">'js/[name].[chunkhash:8].js'</span> <span class="comment">// hash：每次重新编译都会变化 chunkhash：内容不变就不会</span></span><br><span class="line">    &#125;,</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                common: &#123;</span><br><span class="line">                    chunks: <span class="string">'initial'</span>,</span><br><span class="line">                    minSize: <span class="number">0</span>,</span><br><span class="line">                    minChunks: <span class="number">2</span></span><br><span class="line">                &#125;,</span><br><span class="line">                vendor: &#123;</span><br><span class="line">                    priority: <span class="number">1</span>, <span class="comment">// 先抽离第三方模块</span></span><br><span class="line">                    test: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                    chunks: <span class="string">'initial'</span>,</span><br><span class="line">                    minSize: <span class="number">0</span>,</span><br><span class="line">                    minChunks: <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                cache: <span class="literal">true</span>,</span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">                uglifyOptions: &#123;</span><br><span class="line">                    output: &#123; <span class="comment">// 删除注释</span></span><br><span class="line">                        comments: <span class="literal">false</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    compress: &#123; <span class="comment">// 删除 config 和 debugger 以及警告</span></span><br><span class="line">                        warnings: <span class="literal">false</span>,</span><br><span class="line">                        drop_debugger: <span class="literal">true</span>,</span><br><span class="line">                        drop_console: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> OptimizeCssPlugin()</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                    <span class="string">'postcss-loader'</span>, <span class="comment">// 会从样式文件所在目录慢慢往上找，直到根目录</span></span><br><span class="line">                    <span class="string">'sass-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader,</span><br><span class="line">                    <span class="string">'css-loader'</span>,</span><br><span class="line">                    <span class="string">'postcss-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'template.html'</span>,</span><br><span class="line">            filename: <span class="string">'index.html'</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeComments: <span class="literal">true</span>,</span><br><span class="line">                removeEmptyAttributes: <span class="literal">true</span>,</span><br><span class="line">                removeAttributeQuotes: <span class="literal">true</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">            manifest: path.resolve(__dirname, <span class="string">'../dist'</span>, <span class="string">'manifest.json'</span>),</span><br><span class="line">            context: __dirname</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(&#123; </span><br><span class="line">            cleanOnceBeforeBuildPatterns: [<span class="string">'**/*'</span>, <span class="string">'!_dll_vendor.js'</span>, <span class="string">'!manifest.json'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123; <span class="attr">filename</span>: <span class="string">'css/[name].[chunkhash:8].css'</span> &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li><p>在这里遇到了个问题，一直报错，解析不了 jsx，一开始还以为是 babel 版本的问题，结果后来发现把项目中的 babel 相关降到原来的样子也还是报错，仔细一看是因为 babel-loader 中的规则增加了 jsx 的缘故，只包含 js，问题就没有了（我觉得应该是因为 vue-loader 中会解析 vue 文件，将相应的模块交给适合的 loader 去解析，而 vue 文件中的 render 函数部分就交给了 jsx，但是并没有相关的插件能去解析它，所以就报错了）</p></li><li><p>exports is not defined 去查了下看到说是因为在 .babelrc 中的 modules: false 阻止了 babel 进行模块转化，于是去掉之后发现还是报错，没法把 commonjs 解析成功，也试过 babel-plugin-transform-commonjs 插件，但是会报新的错误：Duplicate export ‘default’，好像是因为我项目里也用了 ES6 Module，所以导致重复编译？最后决定将那几个使用了 commonjs 的代码都变成 ES6 的，问题就解决了</p></li><li><p>使用 DllPlugin + DllReferencePlugin 时碰到一个问题：最后打包时还是将依赖打包了进去，之后发现我在项目中用的是 vue.common.js，但是第三方库中 vendor 引用 vue 会自动引入 vue 中的 vue.runtime.esm.js，所以导致第三方还是被一起打包在了里面，所以要在配置文件中添加上 vue/dist/vue.common.js</p></li><li><p>clean-webpack-plugin：建议可以自己写一个删除某个目录下的文件，这个的匹配规则实在是，试了好几种，都没办法把某个目录下的文件都保留，得把文件放到 dist 打包根目录下，再排除，不知道正确的匹配规则是什么，呼~</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>webpack 4 中改动还是挺大的，也导致了挺多插件不能用了，所以在插件的使用上可能会碰到很多问题，需要花上挺多的时间，若之后发现新的好用的插件再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前用的 webpack 版本还是 2.6.1，现在 webpack 都更新到 4.29.6 了。最近学习了下 webpack 4，并且动手使用了下，感觉其中改变还蛮大的，就此作出一个总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="webpack" scheme="https://gromimiss.github.io/tags/webpack/"/>
    
      <category term="打包" scheme="https://gromimiss.github.io/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>记对 Vue 中 nextTick 的理解及总结</title>
    <link href="https://gromimiss.github.io/2019/03/16/next-tick/"/>
    <id>https://gromimiss.github.io/2019/03/16/next-tick/</id>
    <published>2019-03-15T16:00:00.000Z</published>
    <updated>2019-03-16T12:42:21.452Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间面试被问到对 nextTick 的理解，虽说之前有看过源码，但是一来内容多，看的较浅，二来时间过去挺久了，脑海中只模糊记得用了 setTimeout。说到底，还是理解不够深，所以这次决定整理一下，把它彻底搞明白！</p><a id="more"></a><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>nextTick: 在下次 DOM 更新循环结束之后执行延迟回调。  </p><p>最近又看了下更新的源码，发现 MutationObserver 又被使用上了，MessageChannel 被移除了(捂脸)。先简单介绍下 nextTick 中用到的一些 api以及事件循环的概念，知道了这些才能更好的理解 nextTick。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise：用于表示一个异步操作的最终状态，以及该异步操作的结果值。可以解决回调函数的异步执行和嵌套问题。它接受一个带 resolve函数和 reject 函数两个参数的函数，有三种状态： pending、 fulfilled、 rejected。</p><ul><li>resolve 会将对象的状态从 pending 变为 fulfilled，异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</li><li>reject 会将对象的状态从 pending 变为 rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li></ul><p>但它也有一些缺点：</p><ul><li>一旦新建就会立即执行，无法中途取消</li><li>若不设置回调，内部抛出的错误不会反应到外部</li><li>当处于 pending 状态时无法得知目前进展到哪个阶段</li></ul><p>兼容性见<a href="https://www.caniuse.com/#search=Promise" target="_blank" rel="noopener">这里</a>。</p><h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><p>MutationObserver：监听页面中 DOM 元素的变化。它和事件很接近，但本质上不同，事件是同步触发，一有变动就立刻触发相应事件，而 MutationObserver 则是异步触发， DOM 的变动会等到当前所有 DOM 操作都结束才触发。</p><p>特点如下：</p><ul><li>等待所有脚本任务完成后，才会运行</li><li>当有多个 DOM 操作时，会把 DOM 变动记录封装成一个数组进行处理（只会触发一次回调，回调中会将变动记录作为参数传进来）</li><li>可以观察 DOM 的所有类型变动</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">'outer'</span>);</span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations, observer</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mutations);</span><br><span class="line">&#125;).observe(outer, &#123;</span><br><span class="line">    attributes: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 只会触发一次</span></span><br><span class="line">outer.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random());</span><br><span class="line">outer.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random());</span><br></pre></td></tr></table></figure><p>很强大，但是它也有挺严重的兼容性问题，并且在 ie11 中也存在 bug，兼容性看<a href="https://www.caniuse.com/#search=MutationObserver" target="_blank" rel="noopener">这里</a>。</p><h3 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate"></a>setImmediate</h3><p>setImmediate：将一些需要长时间运行的操作放在一个回调函数里面，在浏览器完成后面的其他语句后，立刻执行这个回调函数。它只在 IE 上支持，兼容性看<a href="https://www.caniuse.com/#search=setImmediate" target="_blank" rel="noopener">这里</a>。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JS 是一种单线程语言，所有任务都在一个线程上完成，这样一旦遇到大量任务或者是一个耗时的任务，网页就会出现“假死”。那为什么js不能实现多线程呢 —— 作为浏览器脚本语言，若多线程的话，一个线程添加 DOM，一个线程删除 DOM，浏览器就不好判断了。而单线程就意味着所有的任务都需要排队，前一个任务执行完，才会执行后一个任务，若前一个任务耗时很长，后面的任务都会一直等着，直到前一个任务完成。并且有时并不是因为计算量大，CPU 忙不过来，而是因为 IO 设备很慢，所以之后就引入了事件循环的机制。</p><p>首先在主线程上排队执行任务，而任务队列由异步任务在有了运行结果后放置的事件组成，一旦主线程中的任务执行完，就会读取任务队列，对应的异步任务在结束等待状态之后进入主线程，开始执行。每次主线程空了就会去读取任务队列。任务队列是一个先进先出的数据结构，排在前面的事件优先读取。</p><p>具体运行机制如下：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程外存在一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件</li><li>当执行栈中的任务完成，就会读取任务队列中的任务，依次进入执行栈执行</li><li>下一次事件循环开始</li></ol><p>（参考了<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">阮一峰的 eventloop</a>）</p><p>事件队列中有两种任务源：微任务 (microtask) 和宏任务(macrotask)，当执行完同步代码后执行栈为空，会先执行微任务，执行完所有的微任务后，如有必要渲染页面，然后再执行任务队列中的宏任务，也意味着新一轮事件循环的开始。</p><p>(macro)task -&gt; microtask -&gt; 渲染 -&gt; (macro)task</p><p>(macro)task：script setTimeout MessageChannel postMessage setInterval setImmediate I/O UI渲染<br>microtask：process.nextTick promise.then MutationObserver</p><p>小总结：看了<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">这篇文章</a>，从第二个例子中才发现用户触发 click 和 js 调用 click 事件是不同的，js 调用 click 就导致会等到两次 click 结束，主线程才算是清空，才开始执行任务队列中的事件，这也就让两次 click 中推到任务队列的那些微任务在同一个事件循环中了，因此 MutationObserver 就只会触发一次（一个事件循环中多次 DOM 操作只会增加变动记录，而不会触发多次事件）。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>了解完涉及到的知识点后，开始进入主题 —— 看 nextTick 的源码。</p><h3 id="flushCallbacks"><a href="#flushCallbacks" class="headerlink" title="flushCallbacks"></a>flushCallbacks</h3><p>从头往下看，先是 flushCallbacks，上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">        copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是在异步任务被执行的时候触发的回调：将 pending 状态重新设置为 false，执行回调列表，清空回调列表（为下一次异步队列做准备）。</p><h3 id="异步的选择"><a href="#异步的选择" class="headerlink" title="异步的选择"></a>异步的选择</h3><p>重点就是关于异步 api 使用的选择了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">        timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            p.then(flushCallbacks)</span><br><span class="line">            <span class="comment">// In problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">            <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">            <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">            <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">            <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">            <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">        &#125;</span><br><span class="line">        isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">        isNative(MutationObserver) ||</span><br><span class="line">        <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">        MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">    )) &#123;</span><br><span class="line">        <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">        <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">        <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">        <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">        <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">        observer.observe(textNode, &#123;</span><br><span class="line">            characterData: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">            textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">        &#125;</span><br><span class="line">        isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">        <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">        <span class="comment">// Techinically it leverages the (macro) task queue,</span></span><br><span class="line">        <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">        timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setImmediate(flushCallbacks)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">        timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要优先使用 microtask 呢？macrotask 中两个不同任务之间可能穿插着 UI 的重渲染，所以需要在 microtask 中把所有 UI 重渲染之前将需要更新的数据全部更新，这样只需要一次重渲染就可以得到最新的 DOM。microtask 中最优的选择是使用 Promise，当浏览器不支持 Promise 再降级为 Mutation Observer，要注意的是 Mutation Observer 在 IE11 中是存在 Bug 的，见 <a href="https://github.com/vuejs/vue/issues/6466" target="_blank" rel="noopener">issue #6466</a>，所以在非 IE 的时候并且支持这个 API 才会使用，若这两个microtask 都不支持，那只能退而求其次，使用 macrotask 了。macrotask 中首选是 setImmediate，它比 setTimeout 拥有更好的性能，不需要不停的做超时检测，但是它只有 IE 兼容，<del>其次是 MessageChannel，一个MessageChannel实例对象拥有两个属性port1和port2，我们只需要将其中一个port监听message事件，另一个port通过postMessage向前一个port发送消息，这样前一个port的message事件就会被注册为macrotask，由于它也不需要做任何检测工作，所以性能也比setTimeout，</del>最后的选择则是setTimeout。</p><p>但是这里我又想到了一个问题，既然 nextTick 是为了在数据更新后解决操作最新 DOM 的问题，那这必然就已经发生了一次重渲染，而从这里看又希望把数据更新尽量放在一起重渲染，这不是相矛盾了吗？于是我又仔细的看了下源码，发现当数据赋新的值时，通知相关依赖响应更新时，除非将 sync 设置为 true了，否则会调用 scheduler.js 中的 queueWathcer 方法，若队列中没有保存这个更新 watcher，则将更新 watcher 给保存到一个队列中，设置 nextTick(flushScheduleQueue)，当执行栈为空时才真正调用 wachter。当真正调用 watcher 时，则会触发视图的重新渲染(run() -&gt; getAndInvoke() -&gt; get() -&gt; getter() -&gt; updateComponent())，用户调用的 nextTick 只是和 flushSchedulerQueue 放在了一个回调列表中，并且 flushSchedulerQueue 会先执行，所以后面的回调能获取到更新后的 DOM。</p><p>来个例子，直观一点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.name = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resove().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'3'</span>);&#125;</span><br><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的运行结果为：1 -&gt; 4 -&gt; 3 -&gt; 2。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _resolve</span><br><span class="line">    callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cb.call(ctx)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">        _resolve(ctx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">        pending = <span class="literal">true</span></span><br><span class="line">        timerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// $flow-disable-line</span></span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        _resolve = resolve</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 nextTick 函数一开始 pending 为 false，会执行 timerFunc，也就是说把回调放到了任务队列中，然后将 pending 设置为true，接下来的调用的 this.$nextTick 其实还是在调用 nextTick，此时 timerFunc 已经生成，它只会把传入的 cb 放到 callbacks 中，此时 callbacks 中就会有2个成员，flushSchedulerQueue 和另一个 cb，所以这里的顺序会先打印 1，再打印 4，接着执行 3 和 2。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>  可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。<br>例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p></blockquote><p>在 beforeMount 生命周期后会创建一个 watcher 观察者实例，这个 watcher 中会把 updateComponent 函数传入，watcher 实例就会对 updateComponent 函数求值，而执行 updateCompontnt 函数会间接触发渲染函数(vm.$options.render)的执行，继而触发数据属性的 get 拦截器函数，从而将依赖收集。当依次有多个属性更改时，比如 this.name 修改值，就会收集渲染函数的观察者，然后又修改了 this.age，就又会收集一次渲染函数的观察者，但是因为队列中已经收集了渲染函数的观察者了，就不会再重复添加，所以最后只会触发一次重渲染。</p><p>后面添加的 this.$nextTick 会和 flushSchedulerQueue(即渲染函数观察者或者还有定义的 watch等)一起被加到回调函数中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间面试被问到对 nextTick 的理解，虽说之前有看过源码，但是一来内容多，看的较浅，二来时间过去挺久了，脑海中只模糊记得用了 setTimeout。说到底，还是理解不够深，所以这次决定整理一下，把它彻底搞明白！&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://gromimiss.github.io/tags/vue/"/>
    
      <category term="源码" scheme="https://gromimiss.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JS 中的基本类型和引用类型</title>
    <link href="https://gromimiss.github.io/2019/03/15/type/"/>
    <id>https://gromimiss.github.io/2019/03/15/type/</id>
    <published>2019-03-14T16:00:00.000Z</published>
    <updated>2019-03-15T16:32:53.393Z</updated>
    
    <content type="html"><![CDATA[<p>JS 中包含看两种类型：基本类型（原始类型）和引用类型。本文主要来总结下这两种类型的区别以及类型转换。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型：按值访问，可操作保存在变量中实际的值，指的是简单的数据段。<br>它有6种： undefined、 null、 string、 number、 boolean、 symbol( es6 中新增)。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型：<strong>当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。</strong><br>除了基本类型，其他都是引用类型，包括了：Object、 Array、 RegExp、 Date、 Function、 特殊的基本包装类型（String、 Number、Boolean）以及单体内置对象（Global、 Math）。<br>引用类型变量存放的是地址，当创建一个对象类型的时候，计算机会在内存中开辟一个空间来存放值，我们需要通过一个地址来找到这个空间。所以当复制这个变量的时候其实复制的是存放这个对象空间的地址，当修改数据的时候，就导致了两个变量的值都发生了改变。</p><center><br>    <img src="http://poed019cr.bkt.clouddn.com/type/2.jpg" width="80%"><br></center><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>除了上面的按值访问和按址访问的区别，还有以下区别：</p><ol><li><p>基本类型按值访问，引用类型按址访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="string">'b'</span>;</span><br><span class="line">alert(b); <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用类型值,以数组为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 对其中一个变量直接赋值不会影响到另一个变量（并未操作引用的对象）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// 重新赋值，指向的就不是原来的哪个对象了</span></span><br><span class="line">alert(a); <span class="comment">// 1,2,3,4</span></span><br><span class="line">alert(b); <span class="comment">// 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用push(操作了引用的对象)</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.push(<span class="number">4</span>);</span><br><span class="line">alert(a); <span class="comment">// 1,2,3,4</span></span><br><span class="line">alert(b); <span class="comment">// 1,2,3,4</span></span><br></pre></td></tr></table></figure></li><li><p>引用类型可添加属性和方法，而基本类型不可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为引用类型值添加属性</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">p.age = <span class="number">11</span>;</span><br><span class="line">alert(p.age); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为基本类型值添加属性</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'a'</span>;</span><br><span class="line">name.age = <span class="number">11</span>;</span><br><span class="line">alert(name.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>传递参数：当变量为基本类型时，将变量赋值作为函数的参数（局部变量），在里面对局部变量进行操作时，不会影响到函数外部的值，而若参数为引用类型时，除非在内部重写了参数，否则外部的变量和函数内局部变量会引用同一个对象，内部发生改变也会影响到外部的变量</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    a += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> result = add(num);</span><br><span class="line">alert(num); <span class="comment">//10</span></span><br><span class="line">alert(result); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">'a'</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">'b'</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> p2 = setName(p);</span><br><span class="line">alert(p.name); <span class="comment">// a</span></span><br><span class="line">alert(p2.name); <span class="comment">// b</span></span><br></pre></td></tr></table></figure><h2 id="typeof-vs-instanceof"><a href="#typeof-vs-instanceof" class="headerlink" title="typeof vs instanceof"></a>typeof vs instanceof</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof 可用于判断基本类型，除了 null，其他都可以显示正确的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/hello/</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> num); <span class="comment">// number</span></span><br><span class="line">alert(<span class="keyword">typeof</span> a); <span class="comment">// string</span></span><br><span class="line">alert(<span class="keyword">typeof</span> b); <span class="comment">// undefined</span></span><br><span class="line">alert(<span class="keyword">typeof</span> flag); <span class="comment">// boolean</span></span><br><span class="line">alert(<span class="keyword">typeof</span> o); <span class="comment">// object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> fn); <span class="comment">// function</span></span><br><span class="line">alert(<span class="keyword">typeof</span> rg); <span class="comment">// object(sarari5、chrome7前返回function)</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 可以判断一个对象的正确类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span> ];</span><br><span class="line">alert(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true</span></span><br><span class="line">alert(a <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>但它也不是完全可信的，因为通过 Symbol.hasInstance 我们可以自定义 instanceof 的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimitiveString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [symbol.hasInstance](x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">'string'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="JS中的类型转换"><a href="#JS中的类型转换" class="headerlink" title="JS中的类型转换"></a>JS中的类型转换</h3><p>JS 中类型转换只有三种情况：</p><ul><li>转为布尔值</li><li>转为字符串</li><li>转为数字</li></ul><p>在转 Boolean 中，除了 null/undefined/0/-0//NaN/false/‘’，其他值都转为 true。</p><p>转换对象时，会调用内置的 [[ToPrimitive]] 函数，先调用 valueOf，若未返回基本类型，再调用 toString。</p><h3 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h3><ol><li>加法运算符</li></ol><ul><li>若运算中其中一方为字符串，则将另一方也转换为字符串；</li><li>若双方都不是字符串并且不是对象，运算中其中一方为数字，则将另一方也转换成数字</li><li>若双方都不是字符串，其中一方是对象，则会将对象先转换为基本类型，再通过以上2点比较</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// '11'</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">// '41,2'</span></span><br><span class="line">&#123;&#125; + <span class="number">0</span> <span class="comment">// 0 &#123;&#125; 会被当做一个空代码块，所以结果不是 '[object Object]0'</span></span><br><span class="line">a + + <span class="string">'b'</span> <span class="comment">// 'aNaN' 相当于 a 加上 + 'b'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>其他运算符，只要其中一方是数字，另一方就会转成数字</li></ol><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>当使用 == 时的类型转换，会将两值都转成数字，见下图：</p><p><img src="http://poed019cr.bkt.clouddn.com/2d0d90f2d9549f5f13ad53be3f75ace8_r.jpg" alt></p><p>使用上图规则解析 [] == ![], !会将变量转换成 boolean 类型，所以 ![] 会转成 false, [] == false -&gt; [] == 0 -&gt; ‘’ == 0 -&gt; 0 == 0 -&gt; true</p><h2 id="特殊问题"><a href="#特殊问题" class="headerlink" title="特殊问题"></a>特殊问题</h2><ul><li><p>null 不是一个对象类型，虽然 <code>typeof null === &#39;object&#39;</code>，但是这只是 JS 存在的一个悠久 Bug。因为最初 JS 使用的是      32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头的代表对象，而 null 表示为全零，所以就错误的判断了。</p></li><li><p><code>0.1 + 0.2 !== 0.3</code> 在计算机中数字都是以多位二进制存储的，而除了那些可以表示成x / 2^n的数可以被精确表示，其余小数<br>都是以近似值的方式存在，可以使用以下方式计算浮点数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFloat</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aLen,bLen;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        aLen = a.toString().split(<span class="string">'.'</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        aLen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bLen = b.toString().split(<span class="string">'.'</span>)[<span class="number">1</span>].length;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        bLen = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="built_in">Math</span>.max(aLen, bLen);</span><br><span class="line">    <span class="keyword">return</span> (a * max + b * max) / max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 中包含看两种类型：基本类型（原始类型）和引用类型。本文主要来总结下这两种类型的区别以及类型转换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>记录 hexo + github pages 搭建博客过程</title>
    <link href="https://gromimiss.github.io/2019/03/14/hexo/"/>
    <id>https://gromimiss.github.io/2019/03/14/hexo/</id>
    <published>2019-03-13T16:00:00.000Z</published>
    <updated>2019-05-27T07:40:05.481Z</updated>
    
    <content type="html"><![CDATA[<p>一直想搞个博客，总是被各种事情阻扰，然后继续被搁置着。现在闲了，终于决定自己动手做一个。本文主要记录使用 hexo + github pages 搭建博客的过程及遇到的一些小问题（cu xin）。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为什么用 hexo + github pages？<br>hexo: 一个快速、简洁且高效的博客框架，目前拥有 288 个插件以及 246 个主题可供选择。<br>github pages：由 github 提供的一项功能，可以创建一个专属域名来展示自己的一些项目，考虑到域名备案还是比较麻烦，所以还是选择了这个。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>确保已经下载安装了 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node</a> 以及 <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a></p></li><li><p>安装 Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>新建一个 github 仓库，利用这个仓库来使用 github pages功能</p><center><br>    <img src="http://poed019cr.bkt.clouddn.com/image/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-15%20%E4%B8%8B%E5%8D%884.19.24.png" width="80%"><br></center></li><li><p>建立本地和远程仓库的关联</p><p>创建 ssh，id_rsa 是个人电脑上的私人密钥，id_rsa.pub 是公共密钥，将公共密钥放到 github 上，这样连接 github 账户时，就会根据公钥来匹配电脑上的私钥，相互匹配时，才能顺利通过 git 上传文件到 github 上。</p><ul><li><p>可以先检查本机是否已经存在 ssh。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/. ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure></li><li><p>若不存在，则创建:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key <span class="comment"># 输入用于保存生成的SSH key的文件名，按回车则使用默认的</span></span><br></pre></td></tr></table></figure></li><li><p>将 id_rsa.pub 文件中的密钥复制到 github -&gt; settings -&gt; SSH and GPGkeys -&gt; New SSH key 中</p></li><li><p>验证是否关联成功（注意：这个就是 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，不要把 git 换成自己的 username），显示 hi, your username     就说明成功了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="创建博客项目"><a href="#创建博客项目" class="headerlink" title="创建博客项目"></a>创建博客项目</h2><p>这里可以选择先创建一个博客文件夹，再进入到这个文件夹执行命令 hexo init，也可以在指定文件夹中 hexo init blogname，我跟着网上的教程走，也没仔细看，就跟着复制粘贴，就出现了一个问题：我先新建了一个 myblog 文件夹，然后进入到这个文件夹执行了上面的指令后初始化 hexo init myblog，直接打开了外面的myblog，没有注意到刚才的指令其实是在 myblog 里面又创建了一个 myblog，所以在外面的 myblog 文件夹中就只有三个指令 —— init，help，version，到里面的myblog才会有 generate、server 等属性（所以说还是要动动脑子，不要只去复制粘贴）。</p><p>init后会出现一个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 配置文件</span></span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds <span class="comment"># 模板文件夹</span></span><br><span class="line">├── <span class="built_in">source</span> <span class="comment"># 资源文件夹</span></span><br><span class="line">|   ├── _drafts <span class="comment"># 草稿箱</span></span><br><span class="line">|   └── _posts <span class="comment"># 发布</span></span><br><span class="line">└── themes <span class="comment"># 主题文件夹</span></span><br></pre></td></tr></table></figure><p>根据自己的需求去修改配置文件中的信息。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>主题可以自行去 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a> 寻找自己喜欢的，本人更喜欢简约一点的，所以选择了 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git</span><br></pre></td></tr></table></figure><p>将主题下载下来后放到 themes 目录中，再将站点中 _config.yml 的 theme 属性改成新添加的主题名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>这样就可以看到效果了。<br>在 themes/新添加的主题 目录下也会有个 _config.yml，在里面可以根据个人的需求来调整，具体见 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">这里</a>。</p><p>要特别说一下的是，如果要使用首页只显示前几行的话可以在文章中通过 <code>&lt;!-- more --&gt;</code> 来自定义自己想在首页显示的内容，并且需要将主题配置文件中的 <code>excerpt_link: more</code> 注释掉，并且要注意的是文章中 <code>&lt;!-- more --&gt;</code> 上面需要有内容（注释掉的也可以），否则会发现文章又显示全部内容了。</p><h2 id="live2d-动画"><a href="#live2d-动画" class="headerlink" title="live2d 动画"></a>live2d 动画</h2><p>已经记不得是在哪个博客中看到了 live2d，觉得很可爱，就想着也加一个。</p><ol><li><p>先下载 live2d 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-helper-live2d</span><br></pre></td></tr></table></figure></li><li><p>选择自己喜欢的 <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">模型</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save live2d-widget-model-模型名</span><br></pre></td></tr></table></figure></li><li><p>在站点的 _config.yml 中添加配置信息,将 model 改为你选择的模型包名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">scriptFrom: <span class="built_in">local</span></span><br><span class="line">pluginRootPath: live2dw/</span><br><span class="line">pluginJsPath: lib/</span><br><span class="line">pluginModelPath: assets/</span><br><span class="line">tagMode: <span class="literal">false</span></span><br><span class="line">debug: <span class="literal">false</span></span><br><span class="line">model:</span><br><span class="line">    use: live2d-widget-model-tororo</span><br><span class="line">display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 100</span><br><span class="line">    height: 200</span><br><span class="line">    hOffset: 30</span><br><span class="line">    vOffset: -60</span><br><span class="line">mobile:</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">react:</span><br><span class="line">    opacityDefault: 1</span><br><span class="line">    opacityOnHover: 0.7</span><br></pre></td></tr></table></figure></li></ol><p>可以根据自己想要的样子去调整一些属性，如位置、透明度等，详细见 <a href="https://github.com/xiazeyu/live2d-widget.js" target="_blank" rel="noopener">这里</a>。</p><h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p>评论系统我使用了 Valine，为什么选择它 —— 好吧，我完全只是喜欢它的颜值而已。<br>看了我使用的 yilia 主题，发现配置文件中只有多说、网易云跟帖、畅言、Disqus、Gitment这五种评论系统可以配置，就去 github 上看一下，发现在2017年的时候就新增了对 Valine 的支持，使用如下：</p><ol><li><p>注册 <a href="https://leancloud.cn" target="_blank" rel="noopener">Leancloud</a>，创建应用</p></li><li><p>在站点的 _config.yml 中增加配置信息，appId和 appKey 可以在 创建的应用 -&gt; 设置 -&gt; 应用 key 中找到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#6、Valine https://valine.js.org</span></span><br><span class="line">valine: </span><br><span class="line">appid:  <span class="comment">#Leancloud应用的appId</span></span><br><span class="line">appkey:  <span class="comment">#Leancloud应用的appKey</span></span><br><span class="line">verify: <span class="literal">false</span> <span class="comment">#验证码</span></span><br><span class="line">notify: <span class="literal">false</span> <span class="comment">#评论回复提醒</span></span><br><span class="line">avatar: mm <span class="comment">#评论列表头像样式：''/mm/identicon/monsterid/wavatar/retro/hide</span></span><br><span class="line">placeholder: Just go go <span class="comment">#评论框占位符</span></span><br></pre></td></tr></table></figure></li><li><p>在主题中的 layout/_partial/article.ejs 中添加代码（注意：要加在 <code>&lt;% if (!index &amp;&amp; post.comments){ %&gt;</code> 后       面，否则会出现首页也出现评论框的问题）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;</span><br><span class="line">&lt;section id=<span class="string">"comments"</span> class=<span class="string">"comments"</span>&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    .comments&#123;margin:30px;padding:10px;background:<span class="comment">#fff&#125;</span></span><br><span class="line">    @media screen and (max-width:800px)&#123;.comments&#123;margin:auto;padding:10px;background:<span class="comment">#fff&#125;&#125;</span></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;%- partial(<span class="string">'post/valine'</span>, &#123;</span><br><span class="line">    key: post.slug,</span><br><span class="line">    title: post.title,</span><br><span class="line">    url: config.url+url_for(post.path)</span><br><span class="line">    &#125;) %&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加 layout/_partial/post/valine.ejs 文件，文件内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"vcomment"</span> class=<span class="string">"comment"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"//unpkg.com/valine/dist/Valine.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var notify = <span class="string">'&lt;%= theme.valine.notify %&gt;'</span> == <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    var verify = <span class="string">'&lt;%= theme.valine.verify %&gt;'</span> == <span class="literal">true</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    window.onload = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        new Valine(&#123;</span><br><span class="line">            el: <span class="string">'#vcomment'</span>,</span><br><span class="line">            notify: notify,</span><br><span class="line">            verify: verify,</span><br><span class="line">            app_id: <span class="string">"&lt;%= theme.valine.appid %&gt;"</span>,</span><br><span class="line">            app_key: <span class="string">"&lt;%= theme.valine.appkey %&gt;"</span>,</span><br><span class="line">            placeholder: <span class="string">"&lt;%= theme.valine.placeholder %&gt;"</span>,</span><br><span class="line">            avatar:<span class="string">"&lt;%= theme.valine.avatar %&gt;"</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="开启智能菜单中所有文章及标签的搜索"><a href="#开启智能菜单中所有文章及标签的搜索" class="headerlink" title="开启智能菜单中所有文章及标签的搜索"></a>开启智能菜单中所有文章及标签的搜索</h2><ol><li><p>下载 hexo-generator-json-content 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-generator-json-content</span><br></pre></td></tr></table></figure></li><li><p>在站点的 _config.yml 中添加配置信息</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jsonContent:</span><br><span class="line">meta: <span class="literal">false</span></span><br><span class="line">pages: <span class="literal">false</span></span><br><span class="line">posts:</span><br><span class="line">title: <span class="literal">true</span></span><br><span class="line">date: <span class="literal">true</span></span><br><span class="line">path: <span class="literal">true</span></span><br><span class="line">text: <span class="literal">true</span></span><br><span class="line">raw: <span class="literal">false</span></span><br><span class="line">content: <span class="literal">false</span></span><br><span class="line">slug: <span class="literal">false</span></span><br><span class="line">updated: <span class="literal">false</span></span><br><span class="line">comments: <span class="literal">true</span></span><br><span class="line">link: <span class="literal">false</span></span><br><span class="line">permalink: <span class="literal">false</span></span><br><span class="line">excerpt: <span class="literal">false</span></span><br><span class="line">categories: <span class="literal">false</span></span><br><span class="line">tags: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="添加归档"><a href="#添加归档" class="headerlink" title="添加归档"></a>添加归档</h2><ol><li>在文件夹中 <code>hexo new page archives</code></li><li>在主题下的 _config.yml 中添加 menu</li></ol><h2 id="字数-阅读时长-阅读量统计"><a href="#字数-阅读时长-阅读量统计" class="headerlink" title="字数/阅读时长/阅读量统计"></a>字数/阅读时长/阅读量统计</h2><p>在文章标题下增加字数/阅读时长/阅读量统计这些内容。</p><h3 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a>阅读量统计</h3><p>阅读量统计我使用了不蒜子：</p><ol><li><p>在主题下的 layout/_partial/after-footer.ejs 中最后添加代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>在 after-footer 后面使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本站总访问量 &lt;span id=<span class="string">"busuanzi_value_site_pv"</span>&gt;&lt;/span&gt; 次&amp;nbsp&amp;nbsp&amp;nbsp</span><br><span class="line">本站访客数&lt;span id=<span class="string">"busuanzi_value_site_uv"</span>&gt;&lt;/span&gt;人次</span><br></pre></td></tr></table></figure><p>不过我只希望在文章中添加阅读量，所以放的位置也不一样，我会把它和字数/阅读时长一起放到头部，所以稍后在字数/阅读时长的内容中一起讲。</p></li></ol><h3 id="字数-阅读时长"><a href="#字数-阅读时长" class="headerlink" title="字数/阅读时长"></a>字数/阅读时长</h3><p>字数和阅读时长的统计我使用了插件 hexo-wordcount。</p><ol><li><p>下载 hexo-wordcount 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure></li><li><p>在主题目录下 layout/_partial/post 中新建 word.ejs 文件，把之前的阅读量统计和字数及阅读时长的内容一起放到这个文件里(注意：首页中的每篇文章也会显示，但是那里只会统计站点访问量，所以要判断首页则不显示这些信息，暂时使用了 index 来区分是否是首页)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index)&#123; %&gt;</span><br><span class="line">    &lt;div style=<span class="string">"margin-top:10px;font-size: 12px; color: #999;"</span>&gt;</span><br><span class="line">        &lt;span class=<span class="string">"post-time"</span>&gt;</span><br><span class="line">            &lt;span class=<span class="string">"post-meta-item-icon"</span>&gt;</span><br><span class="line">            &lt;i class=<span class="string">"fa fa-keyboard-o icon-acfun"</span> style=<span class="string">"font-size: 12px;"</span>&gt;&lt;/i&gt;</span><br><span class="line">            &lt;span class=<span class="string">"post-meta-item-text"</span>&gt;  字数统计: &lt;/span&gt;</span><br><span class="line">            &lt;span class=<span class="string">"post-count"</span>&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line"></span><br><span class="line">        &lt;span class=<span class="string">"post-time"</span>&gt;</span><br><span class="line">            &amp;nbsp; | &amp;nbsp;</span><br><span class="line">            &lt;span class=<span class="string">"post-meta-item-icon"</span>&gt;</span><br><span class="line">            &lt;i class=<span class="string">"fa fa-hourglass-half icon-clock"</span> style=<span class="string">"font-size: 12px;"</span>&gt;&lt;/i&gt;</span><br><span class="line">            &lt;span class=<span class="string">"post-meta-item-text"</span>&gt;  阅读时长: &lt;/span&gt;</span><br><span class="line">            &lt;span class=<span class="string">"post-count"</span>&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;span class=<span class="string">"post-time"</span>&gt;</span><br><span class="line">            &amp;nbsp; | &amp;nbsp;</span><br><span class="line">            &lt;i class=<span class="string">"icon-book"</span> style=<span class="string">"font-size: 12px;"</span>&gt;&lt;/i&gt;</span><br><span class="line">            &lt;span id=<span class="string">"busuanzi_container_page_pv"</span>&gt;</span><br><span class="line">            本文总阅读量</span><br><span class="line">            &lt;span id=<span class="string">"busuanzi_value_page_pv"</span>&gt;&lt;/span&gt;</span><br><span class="line">            次</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="在文章中插入图片"><a href="#在文章中插入图片" class="headerlink" title="在文章中插入图片"></a>在文章中插入图片</h2><p>考虑到性能问题，打算把图片放到 <a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a> 中，通过外链的形式插入。</p><ol><li><p>注册七牛云，免费领取对象存储，新建存储空间（需要实名认证，包括支付宝、身份证等绑定，并且免费的话只能用测试域名，有效期30     天）</p></li><li><p>复制上传的图片外链，在文章中引入外链，居中设置宽度（默认的太大了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;</span><br><span class="line">    &lt;img </span><br><span class="line">        src=<span class="string">"外链地址"</span></span><br><span class="line">        width=<span class="string">"80%"</span></span><br><span class="line">    /&gt;</span><br><span class="line">&lt;/center&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="添加-RSS"><a href="#添加-RSS" class="headerlink" title="添加 RSS"></a>添加 RSS</h2><p>可以使用一个插件 —— hexo-generator-feed</p><ol><li><p>下载插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-generator-feed</span><br></pre></td></tr></table></figure></li><li><p>在站点的 _config.yml 中添加以下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">    <span class="built_in">type</span>: atom</span><br><span class="line">    path: atom.xml</span><br><span class="line">    <span class="built_in">limit</span>: 20</span><br></pre></td></tr></table></figure></li><li><p>在主题下的 _config.yml 中添加以下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure></li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol><li><p>在站点 _config.yml 中配置部署 github 仓库信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    <span class="built_in">type</span>: git</span><br><span class="line">    repo: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></li><li><p>通过指令生成页面后使用指令 <code>hexo d</code> 部署<br>若发生错误：<code>Deployer not found: Git</code>，则说明要下载 hexo-deployer-git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>到这里，搭建博客就结束了，内容比较简单，就是自己想要的功能可以要自己花时间去找，还有就是 markdown 的语法一定要注意空格、tab，不要有多余的空格（之前代码块一直显示错乱，找了好久才发现 ~~~ 后面多了个空格）！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直想搞个博客，总是被各种事情阻扰，然后继续被搁置着。现在闲了，终于决定自己动手做一个。本文主要记录使用 hexo + github pages 搭建博客的过程及遇到的一些小问题（cu xin）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://gromimiss.github.io/tags/hexo/"/>
    
      <category term="github pages" scheme="https://gromimiss.github.io/tags/github-pages/"/>
    
  </entry>
  
</feed>
