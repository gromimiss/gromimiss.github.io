<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gromimiss&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gromimiss.github.io/"/>
  <updated>2021-03-14T02:52:13.742Z</updated>
  <id>https://gromimiss.github.io/</id>
  
  <author>
    <name>Gromimiss</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序三方代发</title>
    <link href="https://gromimiss.github.io/2021/03/13/3rdminiprogram/"/>
    <id>https://gromimiss.github.io/2021/03/13/3rdminiprogram/</id>
    <published>2021-03-12T16:00:00.000Z</published>
    <updated>2021-03-14T02:52:13.742Z</updated>
    
    <content type="html"><![CDATA[<p>小程序运营者可以一键授权给第三方平台，由第三方平台来上传代码完成业务。在进行三方代发时，会涉及到很多流程，包括开发调试以及运营发布三方小程序（无需开发介入），本文旨在记录这一整套流程。</p><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="相关申请即设置"><a href="#相关申请即设置" class="headerlink" title="相关申请即设置"></a>相关申请即设置</h3><ul><li>在微信公众平台申请一个小程序，然后在微信开放平台的第三方平台详情中绑定该小程序作为三方开发使用，该小程序就是模板小程序，上传该小程序，代码会被直接上传到开放平台</li><li>在第三方平台账号中配置小程序服务器域名，在三方代发前调用接口为小程序添加第三方平台的域名</li><li>申请一个小程序，用来日常开发测试</li></ul><h3 id="相关名词及字段"><a href="#相关名词及字段" class="headerlink" title="相关名词及字段"></a>相关名词及字段</h3><ul><li>open3rd: 第三方平台，即提供三方服务的对外三方平台，是给其他客户管理小程序的平台</li><li>3rdMiniProgramAppid: 三方代发时需要一个模板小程序来提交代码分发到其他客户的小程序上，这就是模板小程序的 appid</li><li>extAppid: 三方客户小程序的 appid</li><li>extEnable: 是否开启本地的 ext.json，本地调试使用</li><li>ext: 服务端注入额外参数，在提交体验版前，服务端可以给不同小程序注入参数，比如使用 clientId 来区分不同的业务，这些注入的参数在小程序中可以使用 <code>getExtConfig</code> 来获取</li><li>extPages: 可以通过此配置设置对应 page 的配置信息（即 page.json）</li><li>directCommit: 规定当前上传操作是否直接上传到三方小程序的审核列表中，设为 true 时即可支持开发者工具中执行上传操作则直接上传到对应三方小程序的审核列表，当为 false 时则直接上传到对应草稿箱，默认为 false</li></ul><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><ul><li>客户在增值服务购买小程序服务，调用微信快速创建小程序接口，企业法人扫脸后创建小程序</li><li>云端收到创建成功通知，获取小程序原始 id 和 appid 去云端创建 clientId 映射服务</li><li>三方发布平台获取到新的未发布小程序，点击发布体验版，对小程序进行分发</li><li>客户进入商家运营中心配置小程序所需的审核材料和支付账户相关东西</li><li>确认体验版无误，对小程序正式提审</li></ul><h2 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h2><p>为了方便前端开发，在本地开发时可以另外创建小程序作为开发测试使用，在三方发布平台打包时再走三方代发流程。</p><ul><li>当我们在三方发布平台（供运营使用）执行打包时，libra 会收到 mqtt 消息，进行三方打包，此时 appid 是模板小程序的 appid，三方发布平台轮询后端 mqtt 接口</li><li>libra 使用模板小程序打包完成后上传到第三方平台的草稿箱，并通知打包完成</li><li>三方发布平台收到打包完成消息，按钮变为提交体验版，选择要发布的小程序提交，将代码从草稿箱转移到模板库，注入相应的 clientId，提交代码到体验版</li><li>等待提交完成，查看发布到体验版的小程序，调用审核接口，审核通过后进行正式发布</li></ul><h2 id="三方代发整体流程"><a href="#三方代发整体流程" class="headerlink" title="三方代发整体流程"></a>三方代发整体流程</h2><center><br>  <img src="https://i.loli.net/2021/03/13/W74iHfyLrAwMToj.png" width="50%"><br></center><ul><li>三方平台创建审核通过后微信服务器会向其授权事件接收 URL 每隔10分钟推送 component_verify_ticket，保存最近可用的 component_verify_ticket</li><li>可以通过上面的 component_verify_ticket  来获取令牌(component_access_token)，有效期 2 小时</li><li>通过 component_access_token 获取预授权码（pre_auth_code），有效期 1800 s</li><li>用户需要在第三方平台授权页中完成授权，授权通过后三方平台即可在回调 URL 中获取到授权码（authorization_code），通过授权码获取到授权方的 appid、authorizer_access_token、authorizer_refresh_token 等授权方相关信息</li><li>发布时先把代码上传到模板库</li><li>通过 authorizer_access_token、模板 id、ext.json（服务端在此注入相关业务参数）上传到体验版</li><li>提交审核，等待微信服务器推送审核结果</li><li>审核通过，使用 authorizer_access_token 发布正式版本</li></ul><h2 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h2><p>当我们需要对线上三方小程序进行调试时，可以在本地增加 ext.json，开启 extEnable 并且设置 extAppid 调试指定三方小程序。</p><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><p><a href="https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/Third_party_platform_appid.html" target="_blank" rel="noopener">第三方平台开发文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序运营者可以一键授权给第三方平台，由第三方平台来上传代码完成业务。在进行三方代发时，会涉及到很多流程，包括开发调试以及运营发布三方小程序（无需开发介入），本文旨在记录这一整套流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="https://gromimiss.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>React 源码解析之任务调度器 Scheduler</title>
    <link href="https://gromimiss.github.io/2020/12/26/react1/"/>
    <id>https://gromimiss.github.io/2020/12/26/react1/</id>
    <published>2020-12-25T16:00:00.000Z</published>
    <updated>2021-03-10T15:45:32.722Z</updated>
    
    <content type="html"><![CDATA[<p>Scheduler，用于完成任务调度工作。它以小顶堆的方式存放了两个队列：taskQueue 和 timerQueue。taskQueue 用于存放将被处理的任务，timerQueue 用于存放延期处理的任务。</p><a id="more"></a><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>在 Scheduler 中主要使用到了一种数据结构：堆。它是顺序存储的一颗完全二叉树，分为大顶堆和小顶堆。</p><p>大顶堆：<code>arr[i] &gt;= arr[i * 2 + 1] &amp;&amp; arr[i] &gt;= arr[i * 2 + 2]</code>，即父节点的值总是会比子节点的值大。<br>小顶堆：<code>arr[i] &lt;= arr[i * 2 + 1] &amp;&amp; arr[i] &lt;= arr[i * 2 + 2]</code>，即父节点的值总是会比子节点的值小。</p><p>Scheduler 中使用堆来实现了优先队列：</p><table><thead><tr><th>类型</th><th style="text-align:right">入队</th><th style="text-align:center">出队</th></tr></thead><tbody><tr><td>普通数组</td><td style="text-align:right">O(1)</td><td style="text-align:center">O(n)</td></tr><tr><td>顺序数组</td><td style="text-align:right">O(n)</td><td style="text-align:center">O(1)</td></tr><tr><td>堆</td><td style="text-align:right">O(logn)</td><td style="text-align:center">O(logn)</td></tr></tbody></table><p>就源码来看一下。</p><h3 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Compare sort index first, then task id.</span></span><br><span class="line">  <span class="keyword">const</span> diff = a.sortIndex - b.sortIndex;</span><br><span class="line">  <span class="keyword">return</span> diff !== <span class="number">0</span> ? diff : a.id - b.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compare 方法，用来比较两个元素间的顺序，先通过 sortIndex，若一样则通过元素上的 id。</p><h3 id="siftUp"><a href="#siftUp" class="headerlink" title="siftUp"></a>siftUp</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上比较</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftUp</span>(<span class="params">heap, node, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = i;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 取父元素</span></span><br><span class="line">    <span class="keyword">const</span> parentIndex = (index - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> parent = heap[parentIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent !== <span class="literal">undefined</span> &amp;&amp; compare(parent, node) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// The parent is larger. Swap positions.</span></span><br><span class="line">      heap[parentIndex] = node;</span><br><span class="line">      heap[index] = parent;</span><br><span class="line">      index = parentIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// The parent is smaller. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某节点可能与上一层节点交换就要用 siftUp。他会先取传入节点的父节点，通过 compare 方法来比较父节点和传入节点的优先顺序：</p><ul><li>若传入的值小则将传入的值放置到父节点的位置，而父节点则放到传入的位置，再将 index 更新为父节点的位置，继续向上取父节点比较，直到堆顶</li><li>若传入的值大则位置不变</li></ul><h3 id="siftDown"><a href="#siftDown" class="headerlink" title="siftDown"></a>siftDown</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向下比较</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">siftDown</span>(<span class="params">heap, node, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = i;</span><br><span class="line">  <span class="keyword">const</span> length = heap.length;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; length) &#123;</span><br><span class="line">    <span class="keyword">const</span> leftIndex = (index + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> left = heap[leftIndex];</span><br><span class="line">    <span class="keyword">const</span> rightIndex = leftIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> right = heap[rightIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the left or right node is smaller, swap with the smaller of those.</span></span><br><span class="line">    <span class="keyword">if</span> (left !== <span class="literal">undefined</span> &amp;&amp; compare(left, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (right !== <span class="literal">undefined</span> &amp;&amp; compare(right, left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        heap[index] = right;</span><br><span class="line">        heap[rightIndex] = node;</span><br><span class="line">        index = rightIndex;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        heap[index] = left;</span><br><span class="line">        heap[leftIndex] = node;</span><br><span class="line">        index = leftIndex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right !== <span class="literal">undefined</span> &amp;&amp; compare(right, node) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      heap[index] = right;</span><br><span class="line">      heap[rightIndex] = node;</span><br><span class="line">      index = rightIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Neither child is smaller. Exit.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某节点可能与下一层节点交换就要用 siftDown。从指定节点开始，取出子树中的左侧节点和右侧节点。</p><ul><li>将左侧节点和传入的值比较：左侧节点小，比较左侧节点和右侧节点。若右侧节点比左侧节点小，将右侧节点放到子树顶部，将传入的值放入到右侧节点的位置，index 更新为改动的节点位置（需要重复进行这个操作，保证右侧节点下的子树是正确的）；反之，将左侧节点放到子树顶部，将传入的值放入到左侧节点的位置</li><li>将右侧节点和传入的值比较：右侧节点小，将右侧节点放到子树顶部，将传入的值放入到右侧节点的位置</li><li>上述都不符合，位置不改动</li></ul><h3 id="peek、push-和-pop"><a href="#peek、push-和-pop" class="headerlink" title="peek、push 和 pop"></a>peek、push 和 pop</h3><p>基础的方法看完来看下基于它们实现的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">heap: Heap, node: Node</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = heap.length;</span><br><span class="line">  heap.push(node);</span><br><span class="line">  <span class="comment">// 向上比较，将 node 放置在合适的位置</span></span><br><span class="line">  siftUp(heap, node, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取堆顶值，即最小值</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">peek</span>(<span class="params">heap: Heap</span>): <span class="title">Node</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> first = heap[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> first === <span class="literal">undefined</span> ? <span class="literal">null</span> : first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params">heap: Heap</span>): <span class="title">Node</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> first = heap[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (first !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> last = heap.pop();</span><br><span class="line">    <span class="keyword">if</span> (last !== first) &#123;</span><br><span class="line">      heap[<span class="number">0</span>] = last;</span><br><span class="line">      siftDown(heap, last, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>push：在堆中加入一个元素，并会向上比较，放置在合适的位置</li><li>peek：取堆顶值，即最小值</li><li>pop：去除堆顶节点并将这个堆顶节点返回，将堆中最后一个元素先放置到堆顶，向下比较，将这个元素放到合适的位置</li></ul><h2 id="SchedulerHostConfig"><a href="#SchedulerHostConfig" class="headerlink" title="SchedulerHostConfig"></a>SchedulerHostConfig</h2><p>unstable_scheduleCallback 方法里涉及到了 getCurrentTime、requestHostCallback、requestHostTimeout 等方法，都写在 SchedulerHostConfig.default.js 中。</p><h3 id="getCurrentTime"><a href="#getCurrentTime" class="headerlink" title="getCurrentTime"></a>getCurrentTime</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  <span class="keyword">typeof</span> performance === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> performance.now === <span class="string">'function'</span></span><br><span class="line">) &#123;</span><br><span class="line">  getCurrentTime = <span class="function"><span class="params">()</span> =&gt;</span> performance.now();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> initialTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  getCurrentTime = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Date</span>.now() - initialTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若有 performace，currentTime 会取 <code>performace.now()</code> ，它是当前时间与 <code>performance.timing.navigationStart</code>(即上一个页面被 unload 的时间戳，若没有上一个页面，则与 fetchStart 值相等) 的时间差。它与 <code>Date.now() - performance.timing.navigationStart</code> 的区别是不受系统程序执行阻塞的影响，因此更加精准；若不支持 performance 则取 <code>Date.now() - initialTime</code>，即当前时间和 SchedulerHostConfig.default.js 文件加载的时间差。总之，这里就取的是在执行该方法时到某一个时间节点的间隔差。</p><h3 id="requestHostCallback"><a href="#requestHostCallback" class="headerlink" title="requestHostCallback"></a>requestHostCallback</h3><p>流程图如下：</p><center><br>  <img src="https://i.loli.net/2021/03/10/8jsCEYUA5xDRqvS.png" width="50%"><br></center><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> performWorkUntilDeadline = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (scheduledHostCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentTime = getCurrentTime();</span><br><span class="line">    deadline = currentTime + yieldInterval;</span><br><span class="line">    <span class="keyword">const</span> hasTimeRemaining = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行传入的回调</span></span><br><span class="line">      <span class="keyword">const</span> hasMoreWork = scheduledHostCallback(</span><br><span class="line">        hasTimeRemaining,</span><br><span class="line">        currentTime,</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 是否还有更多的任务，若有则继续传递</span></span><br><span class="line">      <span class="keyword">if</span> (!hasMoreWork) &#123;</span><br><span class="line">        isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">        scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        port.postMessage(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      port.postMessage(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isMessageLoopRunning = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  needsPaint = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">const</span> port = channel.port2;</span><br><span class="line">channel.port1.onmessage = performWorkUntilDeadline;</span><br><span class="line"></span><br><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  scheduledHostCallback = callback;</span><br><span class="line">  <span class="keyword">if</span> (!isMessageLoopRunning) &#123;</span><br><span class="line">    <span class="comment">// 标识消息传递中</span></span><br><span class="line">    isMessageLoopRunning = <span class="literal">true</span>;</span><br><span class="line">    port.postMessage(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当存在 window 对象并且有 MessageChannel，那么 requestHostCallback 会使用 MessageChannel 来建立起一个通道，通过 <code>port.postMessage(null)</code> 来发送消息，channel.port1.onmessage 接受信息，并立即开始执行任务队列中的任务，类似一个发布订阅。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _flushCallback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> currentTime = getCurrentTime();</span><br><span class="line">      <span class="keyword">const</span> hasRemainingTime = <span class="literal">true</span>;</span><br><span class="line">      _callback(hasRemainingTime, currentTime);</span><br><span class="line">      _callback = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      setTimeout(_flushCallback, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行传入的 callback，执行完后置空</span></span><br><span class="line"><span class="comment">// 若发现之前执行的还存在则递归执行 requestHostCallback，直到 callback 为 null</span></span><br><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    setTimeout(requestHostCallback, <span class="number">0</span>, cb);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _callback = cb;</span><br><span class="line">    setTimeout(_flushCallback, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而当不存在上面对象的话，就会使用 setTimeout 来实现。通过判断 _callback 是否存在，若不存在则会将传入的回调赋值给 _callback 并在下一个事件循环执行这个回调，重置 _callback；若 _callback 已经存在了则说明任务还在执行中，它会一直递归的查询 _callback，直到 callback 为空，再执行前面存在的流程。</p><h3 id="requestHostTimeout"><a href="#requestHostTimeout" class="headerlink" title="requestHostTimeout"></a>requestHostTimeout</h3><p>设置一个定时器，在传入的指定 ms 之后触发。</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>回到 Scheduler 的核心代码，先上一张流程图：</p><center><br>  <img src="https://i.loli.net/2021/03/10/lCPWpZAmEDIxyuV.png" width="100%"><br></center><p>在这里 scheduler profiling 记录 task event 相关的代码我会先隐藏掉，主要看主流程代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unstable_scheduleCallback</span>(<span class="params">priorityLevel, callback, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前执行该方法时到 js 加载的时间</span></span><br><span class="line">  <span class="keyword">var</span> currentTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> startTime;</span><br><span class="line">  <span class="keyword">var</span> timeout;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'object'</span> &amp;&amp; options !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> delay = options.delay;</span><br><span class="line">    <span class="comment">// 延迟开始</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delay === <span class="string">'number'</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      startTime = currentTime + delay;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 立刻开始</span></span><br><span class="line">      startTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// timeoutForPriorityLevel:通过优先等级获取 timeout 时间</span></span><br><span class="line">    timeout =</span><br><span class="line">      <span class="keyword">typeof</span> options.timeout === <span class="string">'number'</span></span><br><span class="line">        ? options.timeout</span><br><span class="line">        : timeoutForPriorityLevel(priorityLevel);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timeout = timeoutForPriorityLevel(priorityLevel);</span><br><span class="line">    startTime = currentTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算出过期时间</span></span><br><span class="line">  <span class="keyword">var</span> expirationTime = startTime + timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newTask = &#123;</span><br><span class="line">    id: taskIdCounter++,</span><br><span class="line">    callback,</span><br><span class="line">    priorityLevel,</span><br><span class="line">    startTime,</span><br><span class="line">    expirationTime,</span><br><span class="line">    sortIndex: <span class="number">-1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里其实就是设置一个定时器：从延迟队列里取任务可执行的任务执行</span></span><br><span class="line">  <span class="keyword">if</span> (startTime &gt; currentTime) &#123;</span><br><span class="line">    <span class="comment">// This is a delayed task.</span></span><br><span class="line">    newTask.sortIndex = startTime;</span><br><span class="line">    <span class="comment">// 放到延迟队列里</span></span><br><span class="line">    push(timerQueue, newTask);</span><br><span class="line">    <span class="comment">// 任务队列里面没有任务，并且是延迟队列里的第一个就是当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) === <span class="literal">null</span> &amp;&amp; newTask === peek(timerQueue)) &#123;</span><br><span class="line">      <span class="comment">// 若之前已经在执行延迟任务调度则取消之前的定时器，否则则设置 isHostTimeoutScheduled 标识</span></span><br><span class="line">      <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">        cancelHostTimeout();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isHostTimeoutScheduled = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行一个定时器</span></span><br><span class="line">      requestHostTimeout(handleTimeout, startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是执行任务队列里的任务</span></span><br><span class="line">    newTask.sortIndex = expirationTime;</span><br><span class="line">    push(taskQueue, newTask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      requestHostCallback(flushWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个任务节点都会有以下几个属性：</p><ul><li>id：任务节点的序号，创建任务时自增 1</li><li>callback：真正要执行的任务</li><li>priorityLevel：任务优先级，按 ImmediatePriority、UserBlockingPriority、NormalPriority、LowPriority、IdlePriority 的顺序依次降低</li><li>startTime：任务预期开始的时间，默认为当前时间，可通过 options.delay 设置为延时任务。只有 startTime 小于或等于 currentTime 的情况下才会被加入到 taskQueue 中</li><li>expirationTime：过期时间，scheduler 基于该值来判断任务是否要开始进行调度。通过 options.timeout 设定或 priorityLevel 计算 timeout 值后将 timeout 与 startTime 相加就得到了 expirationTime</li><li>sortIndex：默认值为 -1。timerQueue 中，该值是 startTime，而 taskQueue 中该值是 expirationTime</li></ul><p>它会先计算出 startTime 和 expirationTime 的值，创建一个具有以上属性的任务节点，通过对比startTime 和 currentTime 来决定要将任务放到哪个队列中，并执行不同的操作。</p><h3 id="advanceTimers"><a href="#advanceTimers" class="headerlink" title="advanceTimers"></a>advanceTimers</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出延迟队列中可开始执行的任务放入到任务队列中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advanceTimers</span>(<span class="params">currentTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出堆中最优先的延迟任务</span></span><br><span class="line">  <span class="keyword">let</span> timer = peek(timerQueue);</span><br><span class="line">  <span class="keyword">while</span> (timer !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若没有任务回调则直接移除这次任务</span></span><br><span class="line">    <span class="keyword">if</span> (timer.callback === <span class="literal">null</span>) &#123;</span><br><span class="line">      pop(timerQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timer.startTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// 将任务从延迟队列中移除，存到任务队列中，按过期时间排序</span></span><br><span class="line">      pop(timerQueue);</span><br><span class="line">      timer.sortIndex = timer.expirationTime;</span><br><span class="line">      push(taskQueue, timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = peek(timerQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看下 advanceTimers，它会取出堆中最优先的延迟任务，也就是说从堆顶开始，以优先级依次执行，移除没有回调的任务，若任务的 startTime 已经小于或等于当前时间了，则说明可以开始执行了，就会将这个任务推到任务队列里并从延迟队列里移除。总的来说，它做的就是处理延迟队列里的任务，将没有回调的任务过滤掉，把可以开始执行的任务依次推到任务队列中，等待执行。</p><h3 id="handleTimeout"><a href="#handleTimeout" class="headerlink" title="handleTimeout"></a>handleTimeout</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行从延迟队列中取出的可开始执行的任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleTimeout</span>(<span class="params">currentTime</span>) </span>&#123;</span><br><span class="line">  isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">  advanceTimers(currentTime);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前没有在执行的任务则执行任务</span></span><br><span class="line">  <span class="keyword">if</span> (!isHostCallbackScheduled) &#123;</span><br><span class="line">    <span class="keyword">if</span> (peek(taskQueue) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      isHostCallbackScheduled = <span class="literal">true</span>;</span><br><span class="line">      requestHostCallback(flushWork);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 若任务队列中没有任务，则取出延迟队列中的最优先任务，以最优先任务的开始时间到执行此方法时的时间为间隔时间</span></span><br><span class="line">      <span class="comment">// 到那个时候再执行 handleTimeout，延迟任务又会被放到任务队列里被执行</span></span><br><span class="line">      <span class="keyword">const</span> firstTimer = peek(timerQueue);</span><br><span class="line">      <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 advanceTimers 处理出了可执行的任务之后，若当前没有在执行的任务并且任务队列里有任务那么就执行任务；否则若延迟队列里还有任务则继续递归执行 handleTimeout。</p><h3 id="flushWork"><a href="#flushWork" class="headerlink" title="flushWork"></a>flushWork</h3><p>这里真正在执行的其实就是 workLoop。它会以 workLoop 的方式循环调度 taskQueue 队列或调用 handleTimeout 来递归调度 timerQueue 队列。这两种方式中只会有一个在激活状态。当 taskQueue 队列调度完毕，会调用 requestHostTimeout 处理 timerQueue 队列；timerQueue 队列有任务进入 taskQueue，又会调用 requestHostCallback 处理 taskQueue 队列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hasTimeRemaining 目前看传入的都是 true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushWork</span>(<span class="params">hasTimeRemaining, initialTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 重置是否有在执行的任务的标识</span></span><br><span class="line">  isHostCallbackScheduled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 清除这个定时器</span></span><br><span class="line">  <span class="keyword">if</span> (isHostTimeoutScheduled) &#123;</span><br><span class="line">    isHostTimeoutScheduled = <span class="literal">false</span>;</span><br><span class="line">    cancelHostTimeout();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行任务的标识</span></span><br><span class="line">  isPerformingWork = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> previousPriorityLevel = currentPriorityLevel;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableProfiling) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> workLoop(hasTimeRemaining, initialTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 重置相关变量</span></span><br><span class="line">    currentTask = <span class="literal">null</span>;</span><br><span class="line">    currentPriorityLevel = previousPriorityLevel;</span><br><span class="line">    isPerformingWork = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">hasTimeRemaining, initialTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentTime = initialTime;</span><br><span class="line">  advanceTimers(currentTime);</span><br><span class="line">  currentTask = peek(taskQueue);</span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    currentTask !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 任务还没有到过期时间，直接跳出循环(取出了最优先的任务，其过期时间还是比当前时间要大，那其他任务肯定更大，所以直接跳出)</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      currentTask.expirationTime &gt; currentTime &amp;&amp;</span><br><span class="line">      (!hasTimeRemaining || shouldYieldToHost()) <span class="comment">// 达到任务的最大运行时长，让出主线程</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> callback = currentTask.callback;</span><br><span class="line">    <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">      currentTask.callback = <span class="literal">null</span>;</span><br><span class="line">      currentPriorityLevel = currentTask.priorityLevel;</span><br><span class="line">      <span class="comment">// 相当于 true</span></span><br><span class="line">      <span class="keyword">const</span> didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;</span><br><span class="line">      markTaskRun(currentTask, currentTime);</span><br><span class="line">      <span class="comment">// 执行回调</span></span><br><span class="line">      <span class="keyword">const</span> continuationCallback = callback(didUserCallbackTimeout);</span><br><span class="line">      currentTime = getCurrentTime();</span><br><span class="line">      <span class="comment">// 回调如果返回了一个函数则继续给当前任务的 callback 属性，否则从任务队列中移除该任务</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> continuationCallback === <span class="string">'function'</span>) &#123;</span><br><span class="line">        currentTask.callback = continuationCallback;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentTask === peek(taskQueue)) &#123;</span><br><span class="line">          pop(taskQueue);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 继续查延迟队列里是否有任务要加入到任务队列里</span></span><br><span class="line">      advanceTimers(currentTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 若 callback 没有则直接移除该任务</span></span><br><span class="line">      pop(taskQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再取堆顶，依次执行任务，直到执行完了所有到了过期时间的任务</span></span><br><span class="line">    currentTask = peek(taskQueue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里代表还有没执行的任务，即过期时间还没到的任务，则返回 true，否则继续创建一个延迟监听，返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (currentTask !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> firstTimer = peek(timerQueue);</span><br><span class="line">    <span class="keyword">if</span> (firstTimer !== <span class="literal">null</span>) &#123;</span><br><span class="line">      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看下，workLoop 中会先通过 advanceTimer 整理出可执行的任务队列。从堆顶任务开始处理，遇到还没到过期时间的任务会直接跳出循环，因为任务队列的数据结构是以堆的方式，它会先取出最优先的任务，这里优先级就是按 expirationTime 来计算的，expirationTime 小的会被排在前面。当该任务过期时间比当前时间要大，那排在其后面的其他任务的过期时间肯定更大，所以直接跳出循环，等待之后执行。若是到了过期时间的任务则会取出其 callback 执行，若 callback 返回的还是函数，会继续将返回的函数赋值给 currentTask，并且不会移除该任务，当继续通过 peek 取堆顶任务的时候取出的还会是该任务，直到 callback 不再返回一个函数，才会去将该任务移除，继续取剩下的优先任务，重复上面的操作。若剩余还有未执行的任务(过期时间还没到的任务)，则继续通过 handleTimeout 来取出可执行的任务执行或继续进行下一次监听。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Scheduler 里面其实就是将传入的 callback 封装成一个 task，按优先级及传入的 options 来决定任务的执行顺序及执行时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Scheduler，用于完成任务调度工作。它以小顶堆的方式存放了两个队列：taskQueue 和 timerQueue。taskQueue 用于存放将被处理的任务，timerQueue 用于存放延期处理的任务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://gromimiss.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>支付</title>
    <link href="https://gromimiss.github.io/2020/11/05/pay/"/>
    <id>https://gromimiss.github.io/2020/11/05/pay/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2021-03-14T02:53:22.415Z</updated>
    
    <content type="html"><![CDATA[<p>在做电商项目中会涉及到很多的支付方式，每个支付方式的对接都有些许不同，这里记录下各大支付方式的对接流程。</p><a id="more"></a><h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>用户 h5 页下单</li><li>创建订单</li><li>调用微信支付接口下单</li><li>下单接口返回支付相关参数 mweb_url</li><li>跳转 mweb_url，并且可在 url 后携带参数 redirect_url</li><li>中间页进行 h5 权限校验</li><li>完成支付及取消支付都会跳转到 redirect_url（未配置则回到支付发起页）</li><li>引导用户主动发起支付结果查询，后端判断是否接收到微信侧的支付结果通知，若没有，后台调用订单查询接口确认状态</li><li>展示订单支付结果</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>微信支付需要在微信支付后台配置授权域名。</p><p>调用后端接口，后端向微信发起下单请求后会返回支付相关参数，前端再通过返回的 mweb_url 调起微信支付的中间页，呼起收银台，支付完成后会返回到前端在 mweb_url 后面拼接的 redirect_url 参数。</p><ul><li>安卓: 微信回调地址由前端控制</li><li>ios: 同上，ios 端支付完成一样不会跳回客户端，只是微信会打开 safari。所以需要做处理: 回调页面需要是一个中转页面，判断若是自己的 app 环境，就跳正常链接，若是 safari 则通过 scheme 打开 app（微信打开 safari 的同时，app 里的第三方支付会自己判断支付完成，并已经跳到回调页，所以我们在 safari 中只需要做的是: 返回 app）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间页</span></span><br><span class="line"><span class="keyword">const</span> url = isInApp ? <span class="string">`<span class="subst">$&#123;<span class="built_in">window</span>.location.origin&#125;</span>/orderPaySuccess?orderId=<span class="subst">$&#123;orderId&#125;</span>`</span> : <span class="string">`<span class="subst">$&#123;scheme&#125;</span>://`</span>;</span><br><span class="line">location.href = url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getRediectUrl = <span class="keyword">async</span> (selectedPay, params) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;isIOS &#125; = judgeDevice();</span><br><span class="line">    <span class="keyword">const</span> host = <span class="built_in">window</span>.location.origin;</span><br><span class="line">    <span class="keyword">let</span> extra = <span class="string">'?'</span>;</span><br><span class="line">    params &amp;&amp; <span class="built_in">Object</span>.keys(params).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> extra += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span>));</span><br><span class="line">    <span class="keyword">return</span> selectedPay === <span class="string">'wechat_pay'</span> &amp;&amp; isIOS ? <span class="string">`<span class="subst">$&#123;host&#125;</span>/wxIosBack<span class="subst">$&#123;extra&#125;</span>scheme=<span class="subst">$&#123;scheme&#125;</span>`</span> : </span><br><span class="line">        <span class="string">`<span class="subst">$&#123;host&#125;</span>/  orderPaySuccess<span class="subst">$&#123;extra&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支付宝支付"><a href="#支付宝支付" class="headerlink" title="支付宝支付"></a>支付宝支付</h2><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol><li>用户 h5 下单</li><li>后台通过支付接口生成订单数据</li><li>前端通过 form 表单形式请求到支付宝</li><li>支付宝自动将页面跳转至支付宝 H5 收银页</li><li>用户在支付宝 app 或 H5 收银页完成支付后，会根据在支付 api 中传入的前端会跳地址 return_url 自动跳转回 h5</li></ol><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>调用后端接口，后端通过支付接口生成订单数据，前端再以 form 表单的形式请求到支付宝，将生成的订单数据除了 bizContent 以外都编码后拼接在返回的 api 地址后，bizContent 通过隐藏域发送，表单提交请求到支付宝，支付宝跳转到支付宝 h5 收银页（若用户安装了支付宝 app 则唤起支付宝），用户在完成支付后会根据支付 api 中传入的 return_url 跳转到我们的页面，并在 url 中带上支付结果参数。</p><ul><li>安卓: 支付宝的回调地址一般配置在服务端，比如: <a href="https://xxx.com/orderPaySuccess?orderId=xxx，支付" target="_blank" rel="noopener">https://xxx.com/orderPaySuccess?orderId=xxx，支付</a> api 带上的支付结果参数则会被拼接在回调地址后</li><li>ios: 同上，只是支付完成后不会自动跳回 app，需要手动切换</li></ul><h2 id="stripe-支付"><a href="#stripe-支付" class="headerlink" title="stripe 支付"></a>stripe 支付</h2><h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><ol><li>用户 h5 下单</li><li>跳转 stripe checkout 页</li><li>用户支付成功后跳转至配置的 successUrl</li></ol><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>点击支付从接口中获取到 publicKey 和 sessionId，重定向到 stripe checkout 页，用户支付成功后跳转到配置的 success_url 页，success_url 和 cancel_url 前后端都可以控制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; publicKey, sessionId &#125; = res.extendMap; <span class="comment">// 从接口中获取</span></span><br><span class="line"><span class="keyword">const</span> stripe = <span class="built_in">window</span>.Stripe(publicKey);</span><br><span class="line">stripe.redirectToCheckout(&#123;</span><br><span class="line">    sessionId</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="paypal-支付"><a href="#paypal-支付" class="headerlink" title="paypal 支付"></a>paypal 支付</h2><h3 id="流程-3"><a href="#流程-3" class="headerlink" title="流程"></a>流程</h3><ol><li>用户点击 paypal 生成的按钮在 h5 下单</li><li>弹出 paypal 弹窗</li><li>支付成功后由前端这边做一个支付成功的跳转</li></ol><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>通过嵌入 paypal 的按钮，点击按钮时会呼起 paypal 支付弹窗进行支付，通过 approve 验证是否成功，并且做一个成功的跳转。</p><ul><li>安卓: 由 approve 验证函数控制（即前端传入）</li><li>ios: 同上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">paypal.Button.render(&#123;</span><br><span class="line">    env: <span class="string">'production'</span>,</span><br><span class="line">    style: &#123;</span><br><span class="line">        label: <span class="string">'paypal'</span>,</span><br><span class="line">        size: <span class="string">'large'</span>,</span><br><span class="line">        shape: <span class="string">'rect'</span>,</span><br><span class="line">        color: <span class="string">'gold'</span>,</span><br><span class="line">        tagline: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    payment: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; getPaymentId, paymentId &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">if</span> (paymentId) &#123;</span><br><span class="line">            <span class="keyword">return</span> paymentId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getPaymentId().then(<span class="function">(<span class="params">res</span>) =&gt;</span> res)</span><br><span class="line">    &#125;,</span><br><span class="line">    onAuthorize: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; approve &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        approve(&#123;</span><br><span class="line">            paymentId: res.paymentId,</span><br><span class="line">            payerId: res.payerId</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">'#paypal_button'</span>);</span><br></pre></td></tr></table></figure><h2 id="paytm-支付"><a href="#paytm-支付" class="headerlink" title="paytm 支付"></a>paytm 支付</h2><p>待补充。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>由于 app 内 h5 支付会打开第三方支付页面，所以会破坏导航历史堆栈，支付完成后跳到的支付结果页直接返回会返回到第三方支付页，再次调起支付，并且支付失败，体验极差，所以要在回调地址页手动控制历史堆栈。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pushHistory = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.pushState(</span><br><span class="line">        &#123;</span><br><span class="line">            title: <span class="string">'title'</span>,</span><br><span class="line">            url: <span class="string">'#'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'title'</span>,</span><br><span class="line">        <span class="string">'#'</span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> fixHistoryBack = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    pushState(); <span class="comment">// 为了触发 popstate 事件</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 首页 -&gt; 详情页 -&gt; 下单页 -&gt; 第三方支付页 -&gt; 支付成功页 -&gt; history push</span></span><br><span class="line">        <span class="keyword">const</span> len = history.length - <span class="number">2</span>;</span><br><span class="line">        len &gt; <span class="number">1</span> ? history.go(-l) : history.back();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各大支付方式的支付成功消息都是异步的，所以用户虽然支付完了，但是可能有一些特殊情况，导致并没有真正支付成功，这种情况下若不进行轮询，支付状态就会显示异常。而倘若在回调页执行轮询，微信和支付宝取消订单和支付成功的回调地址都是同一个，导致无法区分，所以统一流程应该使用微信官方提供的那一套：当用户支付完之后，无论是否完成支付，回到 h5 页时都可以弹出一个确认框，让用户选择是否已完成支付，若用户选择完成支付，则进行轮询，否则直接跳转到订单详情页。</p><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul><li><a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4" target="_blank" rel="noopener">微信</a></li><li><a href="https://opendocs.alipay.com/open/203/105285" target="_blank" rel="noopener">支付宝</a></li><li><a href="https://stripe.com/docs/js" target="_blank" rel="noopener">Stripe</a></li><li><a href="https://developer.paypal.com/docs/archive/orders-integration-guide/#add-the-script-to-your-client" target="_blank" rel="noopener">Paypal</a></li><li><a href="https://developer.paytm.com/docs/show-payment-page" target="_blank" rel="noopener">Paytm</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做电商项目中会涉及到很多的支付方式，每个支付方式的对接都有些许不同，这里记录下各大支付方式的对接流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Redux 和 Vuex 的源码解析</title>
    <link href="https://gromimiss.github.io/2020/09/23/vuxAndRedux/"/>
    <id>https://gromimiss.github.io/2020/09/23/vuxAndRedux/</id>
    <published>2020-09-22T16:00:00.000Z</published>
    <updated>2021-03-14T03:32:57.104Z</updated>
    
    <content type="html"><![CDATA[<p>在部分 SPA 项目中我们会使用到状态管理，方便去管理一些在多个组件下都可以使用或操作的数据。 这篇文章主要就来分析一下 Vuex 和 Redux 两个状态管理库。</p><a id="more"></a><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux 更灵活可扩展，开发者可以根据自己的需求使用，不仅限于 react 项目。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><ul><li>store: 通过 createStore 生成的对象，对象包含 getState、dispatch、subscrible、replaceReducer 等方法</li><li>state: 数据对象，只能通过 getState 去获取</li><li>action: 描述发生了什么的关键词</li><li>reducer: 描述 action 如何改变 state。需要是纯函数，内部的执行操作必须无副作用，不能对 state 进行直接修改而是应该返回一个全新的 state 以此来达到状态更新可预测的目的。</li><li>dispatch: 触发 state 更新</li></ul><p>流程：dispatch action -&gt; 执行 reducer -&gt; 返回新的 state</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li>compose.ts</li></ul><p>从右到左开始，后一个函数会作为前一个函数的参数。比如 compose(f1, f1, f3) =&gt; f1(f2(f3))。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs: Function[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(arg: T) =&gt; arg</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  if (funcs.length === 1) &#123;</span></span><br><span class="line"><span class="xml">    return funcs[0]</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  return funcs.reduce((a, b) =&gt; (...args: any) =&gt; a(b(...args)))</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>bindActionCreators.ts</li></ul><p>遍历对象形式传入的 actionCreators，返回 dispatch(actionCreate) 组合成的对象。开发者可以不直接接触 dispatch 来进行 state 的更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  actionCreators: ActionCreator&lt;any&gt; | ActionCreatorsMapObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  dispatch: Dispatch</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> boundActionCreators: ActionCreatorsMapObject = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> actionCreators) &#123;</span><br><span class="line">    <span class="keyword">const</span> actionCreator = actionCreators[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>combineReducers.ts</li></ul><p>在 redux 中 reducer 负责生成 state，并且在整个应用中只有一个 state 对象，当应用很大的时候， state 也会因此十分庞大，以至于 reducer 也十分庞大，那么 combineReducers 就是为了解决这个问题的。</p><p>在开发中我们可以对 reducer 函数进行拆分，每个小的 reducer 都可以独立负责 state 中的某一部分。combineRecuders 会接收一个 reducers 对象，这个对象的每一个 key 都对应了一个 reducer，并且这个 key 需要和 state 中的 key 保持一致，以标识使用哪个 reducer 来改变 state 的哪一部分。这里会先过滤出是函数的 reducers，得到最终可用的 reducers 对象，然后循环遍历拆分的 reducers，处理对应的 state 部分，将它又合并成一个 nextState。</p><p>通过 hasChanged 来记录前后 state 是否发生改变，若发生了改变则返回新的 nextState，否则返回原来的 state，保证了在不变的情况下仍然返回的是同一个对象。这也是之前要求 reducer 必须是纯函数的原因，combineReducers 只会对新旧 state 进行了浅比较，若直接更改旧的 state，实则引用地址没有变，将不会触发 view 层的 render。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers: ReducersMapObject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="keyword">const</span> finalReducers: ReducersMapObject = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = reducerKeys[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        warning(<span class="string">`No reducer provided for key "<span class="subst">$&#123;key&#125;</span>"`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    state: StateFromReducersMapObject&lt;typeof reducers&gt; = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    action: AnyAction</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> nextState: StateFromReducersMapObject&lt;<span class="keyword">typeof</span> reducers&gt; = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">      <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">      &#125;</span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    hasChanged =</span><br><span class="line">      hasChanged || finalReducerKeys.length !== <span class="built_in">Object</span>.keys(state).length</span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>applyMiddleware.ts</li></ul><p>用户可以在 createStore 中传入该方法来自定义一些功能。它提供给开发者自定义一些扩展的行为，比如说打印日志、错误校验等。当传入中间件时，它会串联的执行中间件而不影响原有的业务状态，每个中间件中都可以拿到 getState 和 dispatch 两个方法，执行所有中间件，将中间件返回的函数组成一个数组通过上面的 compose 方法，以函数柯里化的方式将多个参数转换成单一的参数，依次的去执行中间件返回的函数，最终返回一个增强后的 store 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ...middlewares: Middleware[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">StoreEnhancer</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">createStore: StoreEnhancerStoreCreator</span>) =&gt;</span> &lt;S, A extends AnyAction&gt;(</span><br><span class="line">    reducer: Reducer&lt;S, A&gt;,</span><br><span class="line">    preloadedState?: PreloadedState&lt;S&gt;</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(reducer, preloadedState)</span><br><span class="line">    <span class="keyword">let</span> dispatch: Dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Dispatching while constructing your middleware is not allowed. '</span> +</span><br><span class="line">          <span class="string">'Other middleware would not be applied to this dispatch.'</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI: MiddlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">action, ...args</span>) =&gt;</span> dispatch(action, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为什么要将 middlewareAPI 传递给每个中间件？</span></span><br><span class="line"><span class="comment">     * 为了将 getState 和 dispatch 方法缓存在闭包中，并将这两个方法传递到每一个中间件中</span></span><br><span class="line"><span class="comment">     * 当发生扩展更新时，由于它存在于闭包中，所有中间件都可以取到最新的 dispatch 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose&lt;<span class="keyword">typeof</span> dispatch&gt;(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createStore.ts</li></ul><p>createStore 是 redux 中最核心的一部分代码，它会创建一个带有 dispatch、subscribe、getState、replaceReducer 等方法的一个对象。它可以接收 reducer、初始化 state、以及 applyMiddleware，下面代码中的 enhancer 其实就是 applyMiddleware，它会返回增强后的 store 对象。具体看下代码：</p><p>enhancer 会提供中间件扩展后的 store。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enhancer(createStore)(</span><br><span class="line">    reducer,</span><br><span class="line">    preloadedState <span class="keyword">as</span> PreloadedState&lt;S&gt;</span><br><span class="line">  ) <span class="keyword">as</span> Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>subscribe: 订阅 state 的更新，调用时会被加入到 nextListeners 队列中，并返回取消订阅的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener: (</span>) =&gt; <span class="title">void</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the listener to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'You may not call store.subscribe() while the reducer is executing. '</span> +</span><br><span class="line">        <span class="string">'If you would like to be notified after the store has been updated, subscribe from a '</span> +</span><br><span class="line">        <span class="string">'component and invoke store.getState() in the callback to access the latest state. '</span> +</span><br><span class="line">        <span class="string">'See https://redux.js.org/api/store#subscribelistener for more details.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isSubscribed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在每次 dispatch 之前都会保存一份 listeners 快照，这样可以保证在每次 dispatch 的时候，循环体是不会混乱的</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  ensureCanMutateNextListeners()</span><br><span class="line">  nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保证当前 listener 只会被取消注册一次</span></span><br><span class="line">    <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isSubscribed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners()</span><br><span class="line">    <span class="keyword">const</span> index = nextListeners.indexOf(listener)</span><br><span class="line">    nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">    currentListeners = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch: 触发 state 的更新，并且依次触发订阅函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action: A</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Actions must be plain objects. '</span> +</span><br><span class="line">        <span class="string">'Use custom middleware for async actions.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">'Actions may not have an undefined "type" property. '</span> +</span><br><span class="line">        <span class="string">'Have you misspelled a constant?'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">true</span></span><br><span class="line">    currentState = currentReducer(currentState, action)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> listeners = (currentListeners = nextListeners)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = listeners[i]</span><br><span class="line">    listener()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>与 Redux 不一样的是 Vuex 一般都是和 vue 搭配使用。</p><h3 id="重要概念-1"><a href="#重要概念-1" class="headerlink" title="重要概念"></a>重要概念</h3><ul><li>state: 单一状态树</li><li>mutation: 进行状态的更改，通过 commit 触发</li><li>action: 类似于 mutation，可以包含异步操作。但是应该在里面提交 mutation，而不是直接修改 state，通过 dispatch 触发</li><li>module: 模块，每个模块都会拥有自己的 state、mutation、action、getter，避免 store 对象过于臃肿</li><li>getter: 从 state 中派生出的一些状态</li></ul><p>流程：<br>commit -&gt; 执行 mutation -&gt; 改变 state<br>dispatch -&gt; 执行 action -&gt; commit -&gt; 执行 mutation -&gt; 改变 state</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>当我们创建根组件的时候，会把通过 new Vuex.Store({…}) 创建的 store 对象传入到根组件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue.use(Vuex) 会去调用 Vuex 上的 install 方法，install 方法实际上就是将根组件上的 store 对象传递给子孙组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> version = <span class="built_in">Number</span>(Vue.version.split(<span class="string">'.'</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue 2 及以上会在每个 vue 组件上混合 beforeCreate 钩子，在这里初始化 $store 属性</span></span><br><span class="line"><span class="comment">// 执行顺序：rootVm beforeCreate -&gt; vm beforeCreate -&gt; childVm beforeCreate -&gt; ...</span></span><br><span class="line"><span class="comment">// 所以 vuexInit 在自身的 options 上找不到 store，就必定可以在 parent.$store 上找到</span></span><br><span class="line"><span class="comment">// 实际上 vuex 就是通过根组件来将 $store 属性传递给一个个的子孙组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (version &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">  Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// override init and inject vuex init procedure</span></span><br><span class="line">  <span class="comment">// for 1.x backwards compatibility.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">  <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store = <span class="keyword">typeof</span> options.store === <span class="string">'function'</span></span><br><span class="line">      ? options.store()</span><br><span class="line">      : options.store</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store = options.parent.$store</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在初始化一个 store 对象的时候，会去 installModule。module 是一个树状结构，它会从根 module 开始递归的去处理每一个 module，每个 module 上会挂载一个 context 属性，这个属性上的 dispatch、commit、getters、state 都会去处理/获取当前 module 下的 state。它会将每个 module 下的 mutations、actions、getters 以 [‘namespaceA/namespaceB/key’] 的形式为键名，分别存储在 store 的 _mutations、_actions、_wrappedGetters 属性下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span> (<span class="params">store, rootState, path, module, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length</span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 module 存储到 _modulesNamespaceMap</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</span><br><span class="line">    <span class="keyword">if</span> (store._modulesNamespaceMap[namespace] &amp;&amp; __DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] duplicate namespace <span class="subst">$&#123;namespace&#125;</span> for the namespaced module <span class="subst">$&#123;path.join(<span class="string">'/'</span>)&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    store._modulesNamespaceMap[namespace] = <span class="built_in">module</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传入的 state 会覆盖原有的 state</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">    store._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      Vue.set(parentState, moduleName, <span class="built_in">module</span>.state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 local 对象，它上面绑定了当前模块下处理过后的 dispatch、commit、getters、state</span></span><br><span class="line">  <span class="keyword">const</span> local = <span class="built_in">module</span>.context = makeLocalContext(store, namespace, path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 module 上的 mutations、getters、actions</span></span><br><span class="line">  <span class="comment">// 将它们放到 store 的 _mutations、_actions、_wrappedGetters 属性下</span></span><br><span class="line">  <span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> type = action.root ? key : namespace + key</span><br><span class="line">    <span class="keyword">const</span> handler = action.handler || action</span><br><span class="line">    registerAction(store, type, handler, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerGetter(store, namespacedType, getter, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归处理 module 下的 module</span></span><br><span class="line">  <span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">    installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还需要注意的是我们经常考虑的一点，action 和 mutation 的区别。</p><p>首先 action 肯定返回的是一个 promise，一般来说异步请求会放到 action 里，并且在 action 里还是需要使用 commit 来提交一个 mutation 来改变 state。</p><p>在 mutation 外部或者没有调用 replaceState 方法来改变 state 在 strict 的情况下会抛错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 _commiting 为 false</span></span><br><span class="line"><span class="comment"> * 当通过 store 上的 replaceState 及 commit 改变 state 时都会将 commiting 设置为 true，以此来区分是在内部改变还是外部改变</span></span><br><span class="line"><span class="comment"> * 在 mutation 外部改变 state 时则报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">_withCommit (fn) &#123;</span><br><span class="line">  <span class="keyword">const</span> committing = <span class="keyword">this</span>._committing</span><br><span class="line">  <span class="keyword">this</span>._committing = <span class="literal">true</span></span><br><span class="line">  fn()</span><br><span class="line">  <span class="keyword">this</span>._committing = committing</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">replaceState (state) &#123;</span><br><span class="line">  <span class="keyword">this</span>._withCommit(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._vm._data.$$state = state</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enableStrictMode</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  store._vm.$watch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._data.$$state &#125;, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      assert(store._committing, <span class="string">`do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123; <span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">sync</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 commit 方法及 replaceState 方法在改变 state 的时候都会在外面包一个 _withCommit 方法，以此来区分是否是内部改变。</p><p>并且执行 commit 除了会去执行 mutation 来更新 state，也会依次执行注册的订阅者函数，dispatch 除了会去执行 action 还会依次执行 action 订阅者函数。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>redux 可以和别的框架搭配着使用，但是 vuex 只能和 vue 搭配使用，不过 vuex 中会有贴合 vue 的更多特性，比如像计算属性一样的 getters。redux 在 react 中使用还需要用到 react-redux，它会通过 connect 生成容器组件（将 state 映射到组件的 props；将用户对 UI 组件的操作映射成 action），在根组件外包裹 Provider，将 createStore 创建的 store 由 Provider 组件提供到子组件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在部分 SPA 项目中我们会使用到状态管理，方便去管理一些在多个组件下都可以使用或操作的数据。 这篇文章主要就来分析一下 Vuex 和 Redux 两个状态管理库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Hybird APP</title>
    <link href="https://gromimiss.github.io/2020/04/23/hybrid/"/>
    <id>https://gromimiss.github.io/2020/04/23/hybrid/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-05-23T09:33:04.777Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Native APP 虽然用户体验很好但开发及发布成本高，而 Web APP 虽然开发成本低无需安装但是用户体验没有 Native APP 那么好，并且无法调用全部硬件底层功能，受限较多。这个时候 Hybird APP 出现了，它兼具了 Native APP 的用户体验和 Web APP 的跨平台以及其他优点。</p><a id="more"></a><h2 id="混合方案"><a href="#混合方案" class="headerlink" title="混合方案"></a>混合方案</h2><h3 id="基于-WebView"><a href="#基于-WebView" class="headerlink" title="基于 WebView"></a>基于 WebView</h3><p>基于 WebView UI 的方案是现如今大多数 APP 采取的方案。它本质其实是在原生 APP 中，使用 WebView 作为容器直接承载 Web 页面，所以最核心的点在于 Native 与 H5 之间的通信。如微信的 JSSDK 就是通过 JSBridge 完成 Native 与 H5 之间的通信，从而赋予 H5 一定程度的原生能力。</p><h3 id="基于-Native"><a href="#基于-Native" class="headerlink" title="基于 Native"></a>基于 Native</h3><p>在赋予 H5 原生 API 能力的基础上，进一步通过 JSBridge 将 JS 解析成的虚拟节点数传递到 Native 并使用原生渲染。代表框架有以下三种：</p><ul><li><p>React Native：采用 React 的设计模式，但是 UI 渲染、动画效果、网络请求都由原生端实现。开发者编写的 JS 代码会通过 React Native 的中间层转化为原生控件和操作。</p></li><li><p>Weex：采用 Vue 设计模式，包括 JS Bridge、Render、Dom 三大部分。JSBridge 会和 JS 端实现双向通信，DOM 负责 dom 的解析、映射，最后通知 UI 线程更新，Render 则负责在 UI 线程中对 dom 实现渲染。它和 RN 一样，JS 代码中生成的 dom 最终也会由 Native 端解析。</p></li><li><p>Flutter：基于 Dart 语言，不需要 JS 引擎，最终也通过原生渲染。</p></li></ul><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><h3 id="JS-通知客户端"><a href="#JS-通知客户端" class="headerlink" title="JS 通知客户端"></a>JS 通知客户端</h3><h4 id="弹窗拦截"><a href="#弹窗拦截" class="headerlink" title="弹窗拦截"></a>弹窗拦截</h4><ul><li>alert：可以被 WebView 的 onJsAlert 监听</li><li>confirm WebView 的 onJsConfirm 监听</li><li>prompt：可以被 WebView 的 onJsPrompt 监听</li></ul><p>当 Web 页面调用这其中的方法时，客户端就会通过监听相应的事件，拦截传入的参数，若参数符合定义的规范就解析参数，做后续的处理。上面三种方式最常用的就是 prompt，因为 alert 和 confirm 相对而言在 Js 中使用到的会更多些。</p><h4 id="URL-shema-iframe"><a href="#URL-shema-iframe" class="headerlink" title="URL shema + iframe"></a>URL shema + iframe</h4><p>H5 端通过创建一个隐藏的 iframe，并且 src 指向我们指定的 URL，插入到文档中，触发 URL 请求，安卓和 ios 可以通过拦截跳转页 URL 请求，解析这个 scheme 协议，符合约定规则就给对应的 Native 方法去处理。android 会通过 shouldOverrideUrlLoading 方法拦截，而 ios 则通过 UIWebView 的 delegate 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_invoke</span>(<span class="params">action, data, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> schema = <span class="string">`jack://utils/<span class="subst">$&#123;action&#125;</span>?a=a`</span>;</span><br><span class="line">        <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">            schema += <span class="string">`&amp;<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;data[key]&#125;</span>`</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">let</span> callbackName = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'string'</span>) &#123;</span><br><span class="line">            callbackName =  callback;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callbackName = action + <span class="built_in">Date</span>.now();</span><br><span class="line">            <span class="built_in">window</span>[callbackName] = callback;</span><br><span class="line">        &#125;</span><br><span class="line">        schema += <span class="string">`&amp;callback=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">        iframe.style.display = <span class="string">'none'</span>;</span><br><span class="line">        iframe.src = schema;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">            iframe = <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">invokeShare</span>(<span class="params">data, callback</span>) </span>&#123;</span><br><span class="line">        _invoke(<span class="string">'share'</span>, data, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.fsInvoke = &#123;</span><br><span class="line">        share: invokeShare,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fsInvoke.share(&#123;<span class="attr">title</span>: <span class="string">'xxx'</span>, <span class="attr">content</span>: <span class="string">'xxx'</span>&#125;, result =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.errno === <span class="number">0</span>) &#123;</span><br><span class="line">        alert(<span class="string">'分享成功'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分享失败</span></span><br><span class="line">        alert(result.message)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>url 长度有限制</li><li>创建请求需要一定的耗时，比注入 API 的方式耗时会更长</li></ul><h4 id="JS-上下文注入"><a href="#JS-上下文注入" class="headerlink" title="JS 上下文注入"></a>JS 上下文注入</h4><p>Native 获取到 JS 的环境上下文，直接在上面挂载对象或方法，使 JS 可以直接调用。</p><p>Android 使用 addJavascriptInterface() 可以在 window 上定义一个 jsbridge 对象，这个对象有一个 call 方法可以直接去调用原生的方法，但是 Android 4.2 以下有安全问题。</p><h3 id="客户端通知-JS"><a href="#客户端通知-JS" class="headerlink" title="客户端通知 JS"></a>客户端通知 JS</h3><p>通过上面 JS 通知客户端的方法，会把回调放在 window 上，然后客户端就可以通过以下方法调用绑定在 window 上的函数。</p><h4 id="loadUrl"><a href="#loadUrl" class="headerlink" title="loadUrl"></a>loadUrl</h4><p>在安卓 4.4 以前没有 evaluationJavaScript API，只能通过 loadUrl 来调用 js，让某个 js 方法执行，但是无法获取该方法的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mWebView = new WebView(this); //即当前webview对象</span></span><br><span class="line">mWebView.loadUrl(<span class="string">"javascript: 方法名('参数,需要转为字符串')"</span>);</span><br></pre></td></tr></table></figure><h4 id="evaluationJavaScript"><a href="#evaluationJavaScript" class="headerlink" title="evaluationJavaScript"></a>evaluationJavaScript</h4><p>IOS 的 WKWebView（IOS 8 中引入的新组件，摆脱过去 UIWebView 内存占用量过大的问题） 和 Android 4.4 后版本的 WebView 使用这个方法来调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步执行JS代码,并获取返回值</span></span><br><span class="line">mWebView.evaluateJavascript(<span class="string">"javascript: 方法名('参数,需要转为字符串')"</span>, <span class="keyword">new</span> ValueCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> onReceiveValue(<span class="built_in">String</span> value) &#123;</span><br><span class="line">        <span class="comment">//这里的value即为对应JS方法的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="stringByEvaluatingJavaScriptFromString"><a href="#stringByEvaluatingJavaScriptFromString" class="headerlink" title="stringByEvaluatingJavaScriptFromString"></a>stringByEvaluatingJavaScriptFromString</h4><p>IOS 的 UIWebView（IOS 8之前的版本） 使用这个方法来调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift</span></span><br><span class="line">webview.stringByEvaluatingJavaScriptFromString(<span class="string">"方法名('参数')"</span>)</span><br><span class="line"><span class="comment">// oc</span></span><br><span class="line">[webView stringByEvaluatingJavaScriptFromString:@<span class="string">"方法名(参数);"</span>];</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在注入了上下文的情况下，只需要通过 postMessage 向 Native 端发送消息，Native 端执行完后执行 actionDidFinish，即执行之前存放的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DELAY_TIME = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">const</span> isAndriod = <span class="regexp">/andriod/</span>.test(<span class="built_in">window</span>.navigator.userAgent);</span><br><span class="line"><span class="keyword">let</span> callbacks = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initBridge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bridge = isAndriod ? <span class="built_in">window</span>.WebViewJavaScriptBridge : &#123;&#125;;</span><br><span class="line">    bridge.send = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">        message[id] = id;</span><br><span class="line">        callbacks[id] = <span class="function">(<span class="params">error, result</span>) =&gt;</span> &#123;</span><br><span class="line">            callback(&#123;error, result&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.sendMessage(isAndriod ? <span class="built_in">JSON</span>.stringify(message) : message);</span><br><span class="line">        id++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 客户端执行方法完成后调用这个方法让 JS 执行回调</span></span><br><span class="line">    <span class="keyword">const</span> actionDidFinish = <span class="function">(<span class="params">id, error, result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> callback = callbacks[id];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!result || !result.usable) &#123;</span><br><span class="line">                <span class="keyword">delete</span> callbacks[id]</span><br><span class="line">            &#125;</span><br><span class="line">            callbak(error, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (isAndriod) &#123;</span><br><span class="line">        bridge.actionDidFinish = actionDidFinish;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.WebViewJavascriptBridge_actionDidFinish = actionDidFinish;</span><br><span class="line">        bridge.sendMessage = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> nativeBridge = <span class="built_in">window</span>.WebViewJavaScriptBridge;</span><br><span class="line">            <span class="comment">// 苹果在 WKWebView 的 js runtime 中事先注入了 window.webkit.messageHandlers.XXX.postMessage 这个方法</span></span><br><span class="line">            <span class="comment">// 可以直接使用这个方法向 Native 传值</span></span><br><span class="line">            <span class="keyword">if</span> (!nativeBridge &amp;&amp; <span class="built_in">window</span>.webkit &amp;&amp; <span class="built_in">window</span>.webkit.messageHandlers) &#123;</span><br><span class="line">                nativeBridge = <span class="built_in">window</span>.webkit.messageHandlers.WebViewJavaScriptBridge;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nativeBridge) &#123;</span><br><span class="line">                nativeBridge.postMessage(message);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 客户端若还没有注入上下文对象，则一直超时获取，直到获取到</span></span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.sendMessage(message);</span><br><span class="line">                &#125;, DELAY_TIME);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bridge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> initBridge();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> callbacks = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> jsbridge = &#123;</span><br><span class="line">    <span class="comment">// js 调用 native 端方法</span></span><br><span class="line">    call: <span class="function"><span class="keyword">function</span> (<span class="params">&#123;method, args, cb&#125;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type cb === <span class="string">'function'</span>) &#123;</span><br><span class="line">            callbacks[id] = cb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 安卓会通过 addJavascriptInterface 注入 _jsbridge 对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>._jsbridge) &#123;</span><br><span class="line">            <span class="built_in">window</span>._jsbridge.call(method, args);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prompt(<span class="string">`_jsbridge=<span class="subst">$&#123;method&#125;</span>`</span>, arg);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// js 端注册可供客户端调用的方法</span></span><br><span class="line">    register: <span class="function"><span class="keyword">function</span> (<span class="params">&#123;name, fn&#125;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">window</span>._jsInit) &#123;</span><br><span class="line">            <span class="built_in">window</span>._jsInit = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">               <span class="keyword">this</span>.call(<span class="string">'jsInit'</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.jsFn[name] = fn;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 回调调用</span></span><br><span class="line">    actionDidFinish: <span class="function"><span class="keyword">function</span> (<span class="params">&#123;id, error, result&#125;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> callback = callbacks[id];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!result || !result.usable) &#123;</span><br><span class="line">                <span class="keyword">delete</span> callbacks[id]</span><br><span class="line">            &#125;</span><br><span class="line">            callbak(error, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 客户端调用 js 注册方法</span></span><br><span class="line">    handleMessageFromNative: <span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">JSON</span>.parse(info.data);</span><br><span class="line">        <span class="keyword">const</span> ret = &#123;</span><br><span class="line">            id: info.callbackId,</span><br><span class="line">            complete: <span class="literal">true</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> fn = <span class="built_in">window</span>.jsFn[info.method];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">            ret.data = fn.apply(<span class="built_in">window</span>.jsFn, args);</span><br><span class="line">            <span class="keyword">this</span>.call(<span class="string">'returnValue'</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.jsbridge = jsbridge;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.im/post/5abca877f265da238155b6bc" target="_blank" rel="noopener">JSBridge 的原理</a></li><li><a href="https://mp.weixin.qq.com/s/zdYySfJMQ1xDKMcUSeEfHA" target="_blank" rel="noopener">大前端必须了解的 Hybrid</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Native APP 虽然用户体验很好但开发及发布成本高，而 Web APP 虽然开发成本低无需安装但是用户体验没有 Native APP 那么好，并且无法调用全部硬件底层功能，受限较多。这个时候 Hybird APP 出现了，它兼具了 Native APP 的用户体验和 Web APP 的跨平台以及其他优点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动端" scheme="https://gromimiss.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="hybird" scheme="https://gromimiss.github.io/tags/hybird/"/>
    
  </entry>
  
  <entry>
    <title>Web 中的用户认证机制</title>
    <link href="https://gromimiss.github.io/2020/04/22/user-auth/"/>
    <id>https://gromimiss.github.io/2020/04/22/user-auth/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-04-25T07:30:01.467Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 是一种无状态的协议，客户端每个发起的请求都是独立的，所以服务端并不能知道当前这个请求究竟是哪个用户发送的，为了追踪用户就有了以下的几种用户认证机制。</p><a id="more"></a><h2 id="基于-Cookie-Session-的认证"><a href="#基于-Cookie-Session-的认证" class="headerlink" title="基于 Cookie/Session 的认证"></a>基于 Cookie/Session 的认证</h2><h3 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h3><p>前端登录后，后端会根据用户信息生成一个 Token，并把这个 Token 和对应用户 id 保存到数据库或 Session 中，然后在 set-cookie 响应头添加上这个 token，向用户浏览器中种入该 Token，之后浏览器请求就会带上这个 Cookie，后端再根据这个 Cookie 来查询用户，验证是否过期。</p><p>虽然用这种方法是比较方便的，前端也不需要做什么处理，但是它的缺点也很明显。由于后端每次都要根据 Token 来查出用户 id，增加了数据库的查询和存储的开销，若把验证信息放到 Session 中，则增加了服务器端的存储压力。并且，使用 Cookie 的方式安全性是比较低的，它需要防止 XSS 和 CSRF 的攻击。由于在浏览器端 Cookie 也是可操作的，它可以通过 js 去读取，一旦网站没有过滤用户输入的内容，不法网站就可以通过注入代码获取到 Cookie，或者直接以用户的身份向服务端发起请求，做一些危险的操作。</p><h3 id="XSS-和-CSRF"><a href="#XSS-和-CSRF" class="headerlink" title="XSS 和 CSRF"></a>XSS 和 CSRF</h3><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>XSS，即跨站脚本攻击（cross site scripting）。它主要分为三类：</p><ul><li>反射型 XSS：攻击者事先做好攻击链接，欺骗用户点击链接触发 XSS 代码</li><li>存储型 XSS：通过评论、发布文章等加入代码，若没有过滤或者过滤不严，那这些代码会被存储到服务器中，当有用户访问这个页面的时候就会触发代码执行</li><li>DOM 型 XSS：DOM 树中的所有节点都可以通过 js 访问或操作</li></ul><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>CSRF，即跨站请求伪造（cross site request forgery），伪装成受信任的用户向第三方网站发送恶意请求。怎么伪造的呢？</p><ol><li>用户浏览并登录网站 A</li><li>网站 A 在登录验证后将 cookie 携带给浏览器，cookie 信息会在浏览器端保存一定时间</li><li>用户没有登出A的情况下，访问了恶意网站 B</li><li>恶意网站 B 携带了网站 A 的 Cookie 以用户的身份进行一些恶意请求</li></ol><p>具体参考<a href="https://blog.techbridge.cc/2017/02/25/csrf-introduction/" target="_blank" rel="noopener">这里</a>。</p><h4 id="如何尽量避免-XSS-和-CSRF-攻击？"><a href="#如何尽量避免-XSS-和-CSRF-攻击？" class="headerlink" title="如何尽量避免 XSS 和 CSRF 攻击？"></a>如何尽量避免 XSS 和 CSRF 攻击？</h4><ul><li>过滤用户输入的内容</li><li>校验 referer 请求头</li><li>加验证码</li><li>在 form 中加上一个隐藏 input，填入服务端生成的 token，用户提交表单后会对比 token</li><li>对 cookie 设置 httpOnly，那么在浏览器中就将无法通过 js 来操作或读取</li><li>对 cookie 设置 secure，cookie 就只允许通过 HTTPS 传输，可以过滤掉一些使用 HTTP 协议的 XSS 注入</li><li>设置 same-site：用来限制第三方 Cookie，Samesite 有 3 个参数，strict、lax、none。见<a href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" target="_blank" rel="noopener">这里</a></li></ul><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>目前浏览器对于不同域的 Cookie 不是不会携带，所以将静态资源放到别的域上来防止 Cookie 的携带吗？</p><p>这其实是两种情况：现在比如一个网站是 a.com，它将静态资源放在了 b.com，a.com 设置了 Cookie，这个时候访问 b.com/xx.js 的时候这个请求不会携带 a.com 域名下的 cookie，但如果 b.com 也设置了 Cookie，这个时候在 a.com 下访问 b.com 其实就是一个跨域请求，但是它会携带 b.com 上设置的 Cookie。也就是说每个域上的 Cookie 只会在发送给相应域的请求才会被携带，而 Samesite 是为了解决 CSRF 的问题，即只有你在 a.com 页面下访问 a.com 请求，才会携带 a.com 域名上的 cookie。</p><h2 id="基于-JWT-的认证"><a href="#基于-JWT-的认证" class="headerlink" title="基于 JWT 的认证"></a>基于 JWT 的认证</h2><p>一个开发标准，定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。</p><p>JWT 组成：Header、Payload、Signature</p><ul><li><p>Header：包含 token 的类型和采用的加密算法，它会使用 Base64 编码组成 JWT 结构的第一部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">    <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Payload 负载：存放信息，也会使用 Base64 编码组成 JWT 结构的第二部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"iss"</span>: <span class="string">"lion"</span>, <span class="comment">// 签发者</span></span><br><span class="line">    <span class="string">"iat"</span>: <span class="number">1441593502</span>, <span class="comment">// 签发时间</span></span><br><span class="line">    <span class="string">"exp"</span>: <span class="number">1441593502</span>, <span class="comment">// 过期时间</span></span><br><span class="line">    <span class="string">"aud"</span>: <span class="string">"www.wxample.com"</span>, <span class="comment">// 接收方</span></span><br><span class="line">    <span class="string">"sub"</span>: <span class="string">"lion@163.com"</span> <span class="comment">// 面向的用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Signature 签名：使用编码后的 header 和 payload 以及提供的密钥，使用 header 中指定的签名算法进行签名。（保证 JWT 没有被篡改过）</p><p>在 JWT 中不应该加入任何敏感的数据，比如密码，它适合向 web 应用传递一些非敏感的信息，常用于设计用户认证和授权系统，单点登录</p><p>JWT 使用：</p><ul><li>前端通过表单将用户名和密码发送到后端，建议通过 SSL 加密传输</li><li>后端核对用户名和密码，将用户 id 等其他信息作为负载按头部指定的签名算法进行签名，形成 JWT</li><li>后端将 JWT 作为登录成功的返回结果返回给前端，前端保存在 localStorage 或 sessionStorage，退出登录时前端删除 JWT</li><li>前端每次请求时将 JWT 放入 HTTP header 中的 Authorization。（解决XSS和XSRF问题）。<code>Authorization: Bearer Token</code></li><li>后端检查是否存在，若存在验证 JWT 的有效性</li><li>验证通过后使用 JWT 中包含的用户信息进行其他逻辑操作，返回相应结果</li></ul><p>JWT 虽然也有 XSS 的危险，但是它相比 Cookie 的方式，将用户状态分散在了客户端中，减轻了服务端的内存压力。</p><h2 id="基于-OAuth-的认证"><a href="#基于-OAuth-的认证" class="headerlink" title="基于 OAuth 的认证"></a>基于 OAuth 的认证</h2><p>OAuth 主要用于第三方认证，比如我们在进入某个网站的时候底下会有第三方登录，通过一个授权服务器来获取服务提供方上的用户同意被获取的信息。具体见我<a href="https://gromimiss.github.io/2019/03/29/oauth/">另一篇文章</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 是一种无状态的协议，客户端每个发起的请求都是独立的，所以服务端并不能知道当前这个请求究竟是哪个用户发送的，为了追踪用户就有了以下的几种用户认证机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>手写一个 call/apply/bind</title>
    <link href="https://gromimiss.github.io/2020/04/21/bind/"/>
    <id>https://gromimiss.github.io/2020/04/21/bind/</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2021-03-14T04:04:41.476Z</updated>
    
    <content type="html"><![CDATA[<p>JS 中的 this 一般取决于函数调用的位置，现在有 3 种方法可以改变 this 的指向，今天来手写实现一下。</p><a id="more"></a><h2 id="call-apply-bind-的区别"><a href="#call-apply-bind-的区别" class="headerlink" title="call/apply/bind 的区别"></a>call/apply/bind 的区别</h2><ul><li>call：调用一个函数，并且 this 指向传入的第一个参数，后面的参数会依次传入到调用的函数中。明确参数有多少个的时候可以用 call</li><li>apply：调用一个函数，并且 this 指向传入的第一个参数，第二个参数是一个数组或者一个类数组</li><li>bind：返回一个新的函数，它会将传入的第一个参数作为原函数的 this，后面的参数加上函数运行时的参数按照顺序作为原函数的参数来调用原函数</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>若第一个参数是 string/number/boolean 等这种基本类型的数据的话，就要将 this 指向其包装对象。<br>实现这几个方法核心原理就是将函数放到传入的第一个上下文对象上，再直接调用这个上下文对象上的该函数，调完将该函数从上下文对象上删除。</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.customCall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 取出上下文对象</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 判断上下文对象的类型，基本数据类型则指向其包装对象</span></span><br><span class="line">    <span class="keyword">if</span> (context === <span class="literal">null</span> || <span class="keyword">typeof</span> context === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        context = <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">'string'</span>) &#123;</span><br><span class="line">        context = <span class="keyword">new</span> <span class="built_in">String</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">'number'</span>) &#123;</span><br><span class="line">        context = <span class="keyword">new</span> <span class="built_in">Number</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">        context = <span class="keyword">new</span> <span class="built_in">Boolean</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对对象添加 symbol 属性，避免覆盖别的属性</span></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>);</span><br><span class="line">    context[fn] = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 执行 context 上的该函数，让 this 指向 context</span></span><br><span class="line">    <span class="keyword">const</span> result = context[fn](...args);</span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.customApply = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.customCall(<span class="built_in">arguments</span>[<span class="number">0</span>], ...arguments[<span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>apply 实现上基本与 call 一致，只是参数的处理不同。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.customBind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> outerArgs = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> _self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _self.apply(context, [</span><br><span class="line">            ...outerArgs,</span><br><span class="line">            ...arguments,</span><br><span class="line">        ]);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'==== before ===='</span>, <span class="keyword">this</span>.name);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'==== after ===='</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'张三'</span>&#125;;</span><br><span class="line">test.customCall(obj, <span class="string">'李四'</span>);</span><br><span class="line">test.customApply(obj, [<span class="string">'王五'</span>]);</span><br><span class="line"><span class="keyword">const</span> test2 = test.customBind(obj, <span class="string">'马六'</span>);</span><br><span class="line">test2();</span><br></pre></td></tr></table></figure><p>基于 apply 方法，返回一个可以改变 this 指向为第一个参数的函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 中的 this 一般取决于函数调用的位置，现在有 3 种方法可以改变 this 的指向，今天来手写实现一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vue-router 中的 hash 模式和 history 模式</title>
    <link href="https://gromimiss.github.io/2020/04/16/vue-router/"/>
    <id>https://gromimiss.github.io/2020/04/16/vue-router/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2021-03-14T03:08:30.673Z</updated>
    
    <content type="html"><![CDATA[<p>Vue-router 中的 hash 模式和 history 模式的区别是什么？它们的原理是什么？</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>保存着用户上网的历史记录，是 window 对象的属性，每个浏览器窗口、每个标签页乃至每个框架都有自己的 history 与特定的对象关联。</p><h4 id="属性、api及事件"><a href="#属性、api及事件" class="headerlink" title="属性、api及事件"></a>属性、api及事件</h4><ul><li>length： 保存着历史记录的数量（hash的改变也会生成一条新的历史记录）</li><li>go()：在用户的历史记录中任意跳转，可以向前或前后，参数若是数值，负值是后退一个整数值，正值则是前进一个整数值，参数是字符串，则会跳转到历史记录中包含该字符串的第一个位置（可前可后，取最近）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-1</span>) <span class="comment">// 后退一页</span></span><br><span class="line">history.go(<span class="number">1</span>) <span class="comment">// 前进一页</span></span><br><span class="line">history.go(<span class="string">'test.com'</span>) <span class="comment">// 跳转到最近的test.com页面</span></span><br></pre></td></tr></table></figure><ul><li>back()：返回上一页，和history.go(-1)等价</li><li>forward()： 前进一页，和history.go(1)等价</li><li>pushState(stateObj, title, url): 新生成一条历史记录，页面内容不刷新，方便用浏览器的后退和前进来导航（目的：让无跳转的单站点可以将它的各个状态保存为浏览器的多条历史记录，当通过历史记录重新加载站点时，站点可以直接加载到对应的状态）<ul><li>stateObject：状态对象，存储自定义数据的元素</li><li>title：标题，用作页面标题，目前各类浏览器都忽略它，所以目前建议设置为空字符串</li><li>url：url地址，必须和当前url同源</li></ul></li><li>replaceState()：和 pushState 基本相同，区别在于此方法不会新生成历史记录，而是将当前历史记录替换掉</li><li>window.onpopstate：浏览器取出历史记录并加载时触发，pushState 及 replaceState 本身调用时是不触发 popstate 事件的，只有点击浏览器的前进、后退及调用 go、back、forward 方法才会触发。</li></ul><p>vue-router 中的 history 模式用到的主要就是 pushState 和 replaceState 方法。</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>URL 中从 # 开始的那一部分（search 取的是 ? 后 # 前的那一部分），可以通过 <code>window.location.hash</code> 获取到。</p><h4 id="属性、api及事件-1"><a href="#属性、api及事件-1" class="headerlink" title="属性、api及事件"></a>属性、api及事件</h4><ul><li>window.onhashchange：hash 值更改的时候触发。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><center><br>    <img src="/assets/vue-router/1.jpg"><br></center><center><br>    <img src="/assets/vue-router/2.jpg"><br></center><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>vue-router 默认会使用 hash 模式，即使用 url 的 hash 来模拟一个完整的 url，当 url 的 hash 改变时，页面不会重新加载，兼容到IE8。它不适合推广宣传，有的 app 里面 url 不允许带有 #。</p><p>而history 模式兼容到 IE10，当设置 mode 为 history 时，若浏览器不支持 h5 history api 会自动降级为 hash 模式。由于我们的应用是一个单页客户端应用，如果后台没有正确的配置，当用户刷新页面，会返回 404，因为刷新会实实在在地去请求服务器，所以要在服务端增加一个覆盖所有情况的候选资源，若 url 匹配不到任何静态资源，则应该返回同一个 index.html 页面（app 依赖的页面）。当配置了后，服务器就不会再返回 404 错误页面了，为了避免这种情况，就需要在 vue 应用里面覆盖所有的路由情况，然后给出一个 404 页面。</p><p>这两种模式后退都会触发组件的生命周期，但是会保留原来的滚动位置。</p><h2 id="后退不刷新，前进刷新简单的实现"><a href="#后退不刷新，前进刷新简单的实现" class="headerlink" title="后退不刷新，前进刷新简单的实现"></a>后退不刷新，前进刷新简单的实现</h2><p>在开发过程中，我们 会遇到这样一个场景：当我们点击进入到一个新的页面时，希望页面是重新加载的，但是当我们返回时可以像浏览器中正常的返回一样，缓存当前页面，不需要再进入组件的一系列生命周期，重新请求数据。这次情况下可以使用以下两种方法：</p><ul><li>使用 keep-alive<br>keep-alive组件第一次进入时的生命周期：beforeRouteEnter -&gt; created -&gt; mounted -&gt; activated -&gt; deactived<br>非首次：beforeRouteEnter -&gt; activated -&gt; deactivated</li></ul><p>在路由映射对象中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    <span class="comment">// 在路由元数据配置是否要缓存，是否是返回</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">name</span>: <span class="string">'home'</span>, component： Home, <span class="attr">meta</span>: &#123; <span class="attr">keepAlive</span>: <span class="literal">true</span>, <span class="attr">isBack</span>: <span class="literal">false</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/detail'</span>, <span class="attr">name</span>: <span class="string">'detail'</span>, <span class="attr">component</span>: Detail, <span class="attr">meta</span>: &#123; <span class="attr">keepAlive</span>: <span class="literal">true</span>， isBack: <span class="literal">false</span> &#125; </span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>入口页面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在 home 组件中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">from</span>.name = <span class="string">'detail'</span>) &#123;</span><br><span class="line">        <span class="comment">//若是从详情页回来的，则说明是返回</span></span><br><span class="line">        to.meta.isBack = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若被缓存 created 只有在第一次进入会执行</span></span><br><span class="line">created() &#123; </span><br><span class="line">    <span class="keyword">this</span>.firstEnter = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">activated() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.firstEnter || !<span class="keyword">this</span>.$route.meta.isBack) &#123;</span><br><span class="line">        <span class="comment">//重新获取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复默认的isBack</span></span><br><span class="line">    <span class="keyword">this</span>.$route.meta.isBack = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.firstEnter = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若有表单页，表单页的操作会影响到上一页的数据则要刷新上一页，比如淘宝的订单列表，点击订单，操作订单后订单的状态就会改变（比如不在待收货列表了），表单页操作成功后关闭会返回到订单列表，此时详情页需要刷新下数据。（仔细想还会有很多问题，比如：希望刷新数据后还是停留在当前滚动位置上）</p><p>并且缓存过多 keep-alive 组件，因常驻内存会导致内存占用过多，需要及时销毁掉内存缓存的组件。</p><p>若直接在离开组件的时候通过 $destory() 销毁组件会出现一个问题：再次进入此组件时，组件不能再被缓存了。</p><p>方法一：设置 include，就只会缓存包含的组件，includes 改变，自动删除不再包含了的已缓存组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"includes"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"compName"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方法二：直接操作页面上层 keepAlive 对象中的 cache 列表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeRouteLeave:<span class="function"><span class="keyword">function</span>(<span class="params">to, from, next</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">from</span> &amp;&amp; <span class="keyword">from</span>.meta.rank &amp;&amp; to.meta.rank &amp;&amp; <span class="keyword">from</span>.meta.rank&gt;to.meta.rank)</span><br><span class="line">        &#123;<span class="comment">//如果返回上一层，则摧毁本层缓存。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.$vnode &amp;&amp; <span class="keyword">this</span>.$vnode.data.keepAlive)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.$vnode.parent &amp;&amp; <span class="keyword">this</span>.$vnode.parent.componentInstance &amp;&amp; <span class="keyword">this</span>.$vnode.parent.componentInstance.cache)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.$vnode.componentOptions)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> key = <span class="keyword">this</span>.$vnode.key == <span class="literal">null</span></span><br><span class="line">                            ? <span class="keyword">this</span>.$vnode.componentOptions.Ctor.cid + (<span class="keyword">this</span>.$vnode.componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;<span class="keyword">this</span>.$vnode.componentOptions.tag&#125;</span>`</span> : <span class="string">''</span>)</span><br><span class="line">                            : <span class="keyword">this</span>.$vnode.key;</span><br><span class="line">                        <span class="keyword">var</span> cache = <span class="keyword">this</span>.$vnode.parent.componentInstance.cache;</span><br><span class="line">                        <span class="keyword">var</span> keys  = <span class="keyword">this</span>.$vnode.parent.componentInstance.keys;</span><br><span class="line">                        <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (keys.length) &#123;</span><br><span class="line">                                <span class="keyword">var</span> index = keys.indexOf(key);</span><br><span class="line">                                <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">                                    keys.splice(index, <span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">delete</span> cache[key];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.$destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>详见<a href="http://github.com/vuejs/vue/issues/6509#issuecomment-403693256" target="_blank" rel="noopener">这里</a>。</p><ul><li>嵌套路由（在父路由组件中还有个 router-view，子路由对应的组件会被渲染到父路由组件中的 router-view），从子路由返回到父路由时是不刷新的，但是子路由强制刷新后，父子路由的组件都会重新渲染，执行各自路由组件的生命周期，并且子路由若被其他页面共用，会导致其父路由都会更新，所以尽量独立使用。这种方法适用于在一个页面上可跳转多个页面，最多二级。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue-router 中的 hash 模式和 history 模式的区别是什么？它们的原理是什么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="vue-router" scheme="https://gromimiss.github.io/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>记对 Vue 中的双向绑定的理解和总结(一)</title>
    <link href="https://gromimiss.github.io/2020/04/11/mvvm1/"/>
    <id>https://gromimiss.github.io/2020/04/11/mvvm1/</id>
    <published>2020-04-10T16:00:00.000Z</published>
    <updated>2020-04-15T10:03:46.058Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 是一个 MVVM 框架，什么是 MVVM？MVVM，即 Model-View-ViewModel，它的核心就是 ViewModel。ViewModel 向上与 View 进行一个双向数据绑定，向下则与 Model 通过接口请求进行数据交互，能起到一个数据驱动视图的作用。它的核心原理就在于：响应式（监听 data 中的数据变化）以及数据改动引发的视图更新。这篇文章主要记录对响应式这块的理解及总结。</p><a id="more"></a><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>Vue 中对数据中对象的监听其实就是数据劫持 + 订阅发布，它内部使用了 Object.defineProperty 中的 getter/setter 拦截函数，获取属性值的时候会触发到 getter 函数，将依赖收集起来，当属性值改变时则会触发 setter 函数，通知依赖更新。</p><p>而数组的监听则是通过重写数组的指定方法来达到响应式的效果，每当调用数组的方法时都会通知相关依赖。</p><h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h4><p>Object.defineProperty(obj, prop, descriptor)：在一个对象上定义或修改一个属性，并返回此对象。obj： 要修改的对象，prop：要定义或修改的属性名，descriptor：属性描述符对象。我们主要讲一下 descriptor。</p><p>descriptor 分为数据描述符和存取描述符。</p><p>数据描述符：</p><ul><li>configure：该属性是否可配置，只有当它为 true 时，才可以改变该属性的描述符。默认为 false</li><li>enumerable：该属性是否可枚举，只有当它为 true 时，该属性才会出现在对象的可枚举属性里。默认为 false</li><li>writable：该属性是否可修改，只有当它为 true 时，该属性的值才可以被赋值运算符改变。默认为 false</li><li>value：该属性对应的值。默认为 undefined</li></ul><p>若默认为 false 为什么我们没有定义描述符的对象的属性还是可以被修改？<br>—— 这里的默认值指的都是定义了描述符对象但没有指明具体某个数据描述符的值</p><p>存取描述符：</p><ul><li>get：当访问该属性时会调用此函数，该函数的返回值会被用作属性的值</li><li>set：当该属性值被修改时会调用此函数</li></ul><h4 id="与-proxy-的区别"><a href="#与-proxy-的区别" class="headerlink" title="与 proxy 的区别"></a>与 proxy 的区别</h4><p>Proxy：可以对外界的访问进行过滤和改写，它可以说是 Object.defineProperty 的全方位加强版，但是兼容性不怎么好，不兼容 IE。</p><p>区别：</p><ul><li>可以直接监听对象而非属性</li><li>可以直接监听数组的变化</li><li>有多达 13 种拦截方式</li></ul><p>详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">这里</a>。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>观察者实例会被绑定在每个被观察的对象上，并且由绑定在观察者实例上的发布者来存储/通知相应的依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            d: <span class="number">1</span></span><br><span class="line">            __ob__: [Observer <span class="built_in">Object</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        __ob__: [Observer <span class="built_in">Object</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    __ob__: [Observer <span class="built_in">Object</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    value: any;</span><br><span class="line">    dep: Dep;</span><br><span class="line">    vmCount: number; <span class="comment">// 将此对象作为根数据的vm数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">        <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 定义一个不可枚举的属性__ob__(防止遍历数据对象时遍历到这个属性)</span></span><br><span class="line">        def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">// 使用哪种方式来增加数组（截断原型/ 定义隐藏属性）</span></span><br><span class="line">            <span class="keyword">const</span> augment = hasProto</span><br><span class="line">                ? protoAugment</span><br><span class="line">                : copyAugment</span><br><span class="line">            <span class="comment">// 将数组类型的value添加上自定义后的数组方法</span></span><br><span class="line">            augment(value, arrayMethods, arrayKeys)</span><br><span class="line">            <span class="comment">// 对数组中的每一个项都绑定上观察者</span></span><br><span class="line">            <span class="comment">// 数组不能通过对每个key设置getter/setter来触发更新通知而是使用方法时才触发</span></span><br><span class="line">            <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将对象的每个属性都转换成getter/setters</span></span><br><span class="line">    walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            defineReactive(obj, keys[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察数组中的每一个项</span></span><br><span class="line">    observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">            observe(items[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的数据响应式在 defineReactive 方法中，它会为对象的每个属性创建一个发布者，通过 Object.defineProperty 设置属性的 getter 函数收集订阅了当前属性变化的依赖，若属性值上也有观察者对象，则也收集依赖，若属性值是一个数组，则需要检查每个元素项是否有观察者对象，有观察者对象的元素都一一收集依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">    key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">    val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    customSetter?: ?Function, <span class="regexp">//</span> 用来打印辅助信息</span></span></span><br><span class="line"><span class="function"><span class="params">    shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.为属性创建一个发布者</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep() </span><br><span class="line">    <span class="comment">// 返回指定对象上一个自有属性对应的属性描述符</span></span><br><span class="line">    <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">    <span class="comment">// 若不可配置则返回</span></span><br><span class="line">    <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若开发者定义的属性原本就有setter/getter则予以保留</span></span><br><span class="line">    <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">    <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">        (!getter || setter) ：相当于 !(getter &amp;&amp; !setter)</span></span><br><span class="line"><span class="comment">        也就是说若这个数据存在 getter 并且不存在 setter ，即一个只读属性，则不用获取其属性值对其进行观察</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.获取属性值的 __ob__ 属性</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 每一个数据字段都通过闭包引用着一个属于自己的 dep 常量</span></span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">// Dep.targrt 指要被收集的依赖</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend() <span class="comment">// 3.依赖收集（绑定wachter)</span></span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend() <span class="comment">// 4.为属性值添加依赖收集</span></span><br><span class="line">          <span class="comment">// 若对象中的属性值为数组，要为数组元素递归调用 dependArray 继续收集依赖</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">// newVal !== newVal &amp;&amp; value !== value 检查是否是NaN</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal) <span class="comment">// 将新的属性值声明成响应式的</span></span><br><span class="line">      dep.notify() <span class="comment">// （用于由于对象属性修改（即其子元素）而触发 setter 函数导致闭包中的 dep 通知所有绑定的 watcher 对象）</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>发布者，负责收集依赖并且通知依赖。它和订阅者是多对多的关系，并且运行时会保存当前订阅者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">    id: number;</span><br><span class="line">    subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = uid++</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集观察者</span></span><br><span class="line">    addSub (sub: Watcher) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    removeSub (sub: Watcher) &#123;</span><br><span class="line">        remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depend () &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">            Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖更新</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">            subs[i].update()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在任何时间全局只会有一个 Watcher 依赖的对象的值被计算</span></span><br><span class="line"><span class="comment">// 保存即将要收集的目标</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep.target = _target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 删除并返回数组的最后一个元素</span></span><br><span class="line">  Dep.target = targetStack.pop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>Watcher 会解析一个表达式，通过对这个表达式求值来触发 getter 函数，收集依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求值</span></span><br><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">// 将这个 watcher 设置为当前 watcher</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">            handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        finally的作用：</span></span><br><span class="line"><span class="comment">        1. 无论出现什么情况，finally 块里的代码一定会被执行</span></span><br><span class="line"><span class="comment">        2. finally 块里的代码也是在 return 之前执行的</span></span><br><span class="line"><span class="comment">        3. 若 try 或者 catch 中有 return，并且 finally 中也有 return，finally 中的 return 会覆盖别处的 return 语句</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        <span class="comment">// 递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集</span></span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="comment">// 更新发布者中的依赖列表，将上次清空之前存放的发布者修改为新的发布者数组，并清空新的发布者数组</span></span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当属性的 getter 函数调用 <code>dep.depend()</code> 时，就会调用当前 Watcher 的 addDep 方法，这个方法会将当前属性的发布者存到 newDeps 数组中，并且当前属性的发布者中的 subs 数组也会保存这个 Watcher。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="comment">// this.newDepIds 避免在一次求值中收集重复的依赖</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">        <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">        <span class="comment">// this.depIds 避免在多次求值中收集重复的依赖（多次求值：当数据变化时重新求值）</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">            dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据更改时，则会触发 setter 函数，调用 <code>dep.notify()</code>，此时就会遍历此发布者中的依赖更新。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由 dep 通知相关依赖更新</span></span><br><span class="line">update () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.computed) &#123;</span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">        一个 computed 属性 watcher 有两种模式:lazy 和 activated</span></span><br><span class="line"><span class="comment">        初始化默认是 lazy，并且只有在至少一个订阅者依赖时才被激活，这通常是另一个计算属性或组件的渲染功能</span></span><br><span class="line"><span class="comment">      **/</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.dep.subs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 在 lazy 模式中，我们不希望在必要之前执行计算</span></span><br><span class="line">        <span class="comment">// 所以我们简单的标记 watcher 是被污染的，真实的计算是在计算属性被访问时在 this.evaluate 方法中被执行</span></span><br><span class="line">        <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在 activated 模式中，我们希望主动执行计算，但是仅在值确实发生改变时通知我们的订户</span></span><br><span class="line">        <span class="keyword">this</span>.getAndInvoke(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 通知依赖一一更新</span></span><br><span class="line">          <span class="keyword">this</span>.dep.notify()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//异步更新的好处： 当修改多个值时分别都会触发一次重新渲染，导致严重的性能问题，而使用异步更新则解决了这个问题</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getAndInvoke(<span class="keyword">this</span>.cb)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当值发生变化时调用（触发响应时要重新求一次值）</span></span><br><span class="line">  getAndInvoke (cb: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="comment">// 这个判断是为非渲染函数类型的观察者准备的，用来对比新旧两次求值的结果，当值不相等时就调用通过参数传递进来的回调</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="keyword">this</span>.value ||</span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="keyword">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 设置新的值</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">false</span> <span class="comment">// 惰性求值，表示已经求过值了</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将回调函数的作用域修改为当前Vue组件实例</span></span><br><span class="line">          cb.call(<span class="keyword">this</span>.vm, value, oldValue) </span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="整体链路"><a href="#整体链路" class="headerlink" title="整体链路"></a>整体链路</h3><p>被观察的对象都绑定了一个 <code>__ob__</code> 的内部属性，指向了一个观察者实例，这个观察者实例上则保存了一个 dep 属性，指向一个发布者实例，发布者实例的 subs 属性存储着一个依赖列表（由想监听当前数据变化的订阅者们组成），而每个订阅者中的 deps 属性中存储着上一次求值时的发布者列表，newDeps 属性中则存储着当前求值时的发布者列表。</p><h2 id="实现一个简易的响应式"><a href="#实现一个简易的响应式" class="headerlink" title="实现一个简易的响应式"></a>实现一个简易的响应式</h2><p>Observe.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">'./dep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observe</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">    walk(obj) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(obj, key, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    observe(val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">'object'</span>) &#123;</span><br><span class="line">            <span class="built_in">Object</span>.keys(value).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                defineReactive(value, key, value[key]);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    defineReactive(obj, key, val) &#123;</span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">        observe(val);</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                    dep.depend();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> val;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val !== newVal) &#123;</span><br><span class="line">                    val = newVal;</span><br><span class="line">                    observe(newVal);</span><br><span class="line">                    dep.notify();</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Dep.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = uid++;</span><br><span class="line">        <span class="keyword">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    depend() &#123;</span><br><span class="line">        Dep.target.addDep(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">        subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Dep;</span><br></pre></td></tr></table></figure></p><p>Watcher.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">'./dep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm, expFn, cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm;</span><br><span class="line">        <span class="keyword">this</span>.expFn = expFn;</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">        <span class="keyword">this</span>.val = <span class="keyword">this</span>.get();</span><br><span class="line">        <span class="keyword">this</span>.deps = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        Dep.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> val = <span class="keyword">this</span>.vm[expFn];</span><br><span class="line">        Dep.target = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    addDep(dep) &#123;</span><br><span class="line">        <span class="keyword">const</span> ids = <span class="keyword">this</span>.deps.map(<span class="function">(<span class="params">dep</span>) =&gt;</span> dep.id);</span><br><span class="line">        <span class="keyword">if</span> (ids.indexOf(dep.id) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.deps.push(dep);</span><br><span class="line">            dep.addSub(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="keyword">const</span> val = <span class="keyword">this</span>.get();</span><br><span class="line">        <span class="keyword">if</span> (val !== <span class="keyword">this</span>.val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 是一个 MVVM 框架，什么是 MVVM？MVVM，即 Model-View-ViewModel，它的核心就是 ViewModel。ViewModel 向上与 View 进行一个双向数据绑定，向下则与 Model 通过接口请求进行数据交互，能起到一个数据驱动视图的作用。它的核心原理就在于：响应式（监听 data 中的数据变化）以及数据改动引发的视图更新。这篇文章主要记录对响应式这块的理解及总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://gromimiss.github.io/tags/vue/"/>
    
      <category term="源码" scheme="https://gromimiss.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JS 中的执行上下文、作用域链、闭包以及this</title>
    <link href="https://gromimiss.github.io/2020/04/03/context/"/>
    <id>https://gromimiss.github.io/2020/04/03/context/</id>
    <published>2020-04-02T16:00:00.000Z</published>
    <updated>2020-04-23T02:32:45.434Z</updated>
    
    <content type="html"><![CDATA[<p>为了总结执行上下文、this、作用域以及闭包这几个基础知识点，看了很多的文章，但发现大多是对其表现进行总结，为了更好的记忆我就去了解了下 JS 的编译原理。</p><a id="more"></a><h2 id="JS-属于什么语言？"><a href="#JS-属于什么语言？" class="headerlink" title="JS 属于什么语言？"></a>JS 属于什么语言？</h2><p>什么是解释型语言？<br>不需要在运行前编译，在运行程序时才进行翻译，专门的解释器会负责在每个语句执行的时候解释程序代码。</p><p>什么是编译型语言？<br>在计算机运行代码前，需要先将代码翻译成计算机可以理解的文件再执行，他只要经过一次编译就可以运行，除非修改代码，否则无需重新编译。</p><p>JS 属于解释型语言，每句代码只有在运行时才能知道这句代码是否有错，而编译型语言在运行之前进行了编译，编译器会对所有代码进行检查，以至于不会出现使用了不存在的变量等问题。</p><p>但是若 JS 属于解释型语言，那为什么还会有变量提升和 JIT 代码优化呢？</p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>在函数作用域内的任何变量的声明都会被提升到顶部，并且赋值 undefined，所以是 JS 引擎解释了两次同一段代码？第一次变量提升然后第二次再执行代码还是说先编译了整个代码然后再运行的呢？</p><p>这就要了解下 JS 的运行机制了。</p><h4 id="JS-的运行机制"><a href="#JS-的运行机制" class="headerlink" title="JS 的运行机制"></a>JS 的运行机制</h4><p>浏览器会先按照 js 的顺序加载外部或者内嵌的脚本代码（不异步加载的情况下），然后开始按顺序执行代码</p><ol><li>JS 首先会进入一个执行上下文（函数），对代码进行词法分析，将这段程序分解成词法单元。</li><li>在对当前作用域分析完成后，引擎会将词法单元解析成 AST。</li><li>引擎遇到声明语句时会询问作用域在当前作用域集合中是否已存在该名称的变量，若已存在则会忽略该声明，否则它会要求作用域在当前作用域集合中声明一个新的变量（若是没有 var，则会向上查找，直到全局作用域也没找到，则在全局作用域中声明一个新的变量），每次声明都会为变量分配内存，注意，只是分配内存，并不会修改源代码将变量声明语句提升。</li><li>之后引擎再赋值或取值时会询问作用域在当前作用域集合中是否存在该名称的变量，若不存在则往上查找，直到到最外层的作用域，即全局作用域，若找到了则会赋值给这个变量，若未找到则抛出一个 ReferenceError 异常。</li><li>最后，再由引擎生成 CPU 可以执行的机器码。</li><li>代码执行完毕。</li></ol><p>变量提升并不是代码修改，在这个过程中并没有生成中间代码，它只是 JS 解释器处理事情的方式。</p><h4 id="变量提升具体示例"><a href="#变量提升具体示例" class="headerlink" title="变量提升具体示例"></a>变量提升具体示例</h4><p>从上面的处理过程就可以看出，当我们写 <code>var a = 2</code> 时，会被分为两部分任务，第一个是声明变量并赋值 undefined，第二个是将值赋值给变量，所以无论作用域中的声明出现在什么位置，都将会在代码被执行前进行处理。</p><p>需要注意的是函数声明会被提升，但是函数表达式是不会被提升的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">bar();</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 代码内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过提升后，上面代码会变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line">bar(); <span class="comment">// ReferenceError</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 为什么最终打印出来的并不是一个匿名函数呢？</span></span><br><span class="line">    <span class="keyword">var</span> bar = ...self...</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然函数声明和变量声明都会被提升，但是当函数声明和变量声明重复的时候，若函数声明是在后面，则可以覆盖前面的变量，若函数声明在前面，变量并不能覆盖掉前面的函数。（个人理解函数声明可以当成是把声明和赋值都提升到了上面，而后面遇到同变量名的是不会再去重新声明分配内存的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// function foo() &#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// function foo() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo;</span><br></pre></td></tr></table></figure><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>JIT 及时编译是为了解决多次重复编译的问题的，比如说下面这段代码在解释型语言中执行时就会将 sum+= i 编译 1000 次，造成非常大的性能损耗。<a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/" target="_blank" rel="noopener">参考该文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JIT 只是 Mozila 和 Google 的开发人员为了提升浏览器性能才引入的，JS 并没有强制要求使用 JIT。</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>即 JS 代码解析执行时所处的环境，它会以栈(先入后出)的方式被存放。</p><p>当 JS 代码开始执行时，会先进入全局环境，此时全局上下文被创建并入栈，之后当调用函数时则进入相应的函数环境，相应函数上下文被创建并入栈，当处于栈顶的执行上下文执行完毕后，则会将其出栈。</p><p>一个执行上下文的生命周期：创建阶段（生成变量对象、建立作用域链、确定 this 指向），执行阶段（变量赋值、执行其他代码）。</p><p>生成变量对象：</p><ul><li>检索当前上下文中的参数，生成 arguments 对象，建立以形参变量名为属性名，形参变量值为属性值的属性</li><li>检索当前上下文中的函数声明，建立以函数名为属性名，函数所在内存地址引用为属性值的属性</li><li>检索当前上下文中的变量声明，建立以变量名为属性名， undefined 为属性值的属性（若变量名和形参变量名或函数相同，则该变量声明不会影响已存在的这类属性）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">2</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域由书写代码时函数声明的位置来决定的，词法分析阶段就可以知道全部变量的位置以及是如何声明的，从而预测在执行过程中如何对它们进行查找。<br>但在 JS 中有两个机制可以 “欺骗” 词法作用域：eval() 和 with。</p><ul><li>eval：执行一段包含一个或者多个声明的代码字符串，以至于在运行时修改了已经存在的词法作用域。</li><li>with：将一个对象的引用作为作用域来处理，对象的属性作为作用域中的变量来处理，从而创建了一个新的词法作用域。</li></ul><p>为什么要尽量避免使用 eval 和 with？<br>引擎将无法在词法分析时对作用域查找进行优化，导致性能问题。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链是指当前上下文和上层上下文的一系列变量对象组成的层级链，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。在执行上下文的执行阶段，当需要查找某个变量或函数时，会在当前上下文的变量对象中进行查找，若未找到，则沿着上层上下文变量对象进行查找，直到全局上下文中的变量对象。</p><p>函数作用域是在函数被声明时确定的。每个函数都会包含一个 [[scope]] 内部属性，在函数被声明时，该函数的 [[scope]] 属性会保存其上层上下文的变量对象，形成包含上层上下文变量对象的层级链。当函数被调用时，其执行上下文会被创建并入栈。在创建阶段生成其变量对象后，会将该变量对象添加到作用域链的顶端，并将 [[scope]] 添加进该作用域中。</p><p>在 JS 中我们熟悉的只有全局作用域和函数作用域，但事实上还有两个特殊的情况：</p><ul><li>with：在上面就讲过了 with 会从对象中创建出作用域。</li><li>try/catch：catch 中捕获到的 err 对象只有在 catch 代码块中才能访问到。</li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>指有权访问另一个函数作用域中变量的函数，它可以创建内部变量，即私有变量，让外部不能随意修改这些变量，暴露一个访问器（函数）来让外部间接访问。</p><p>应用场景主要有结果缓存，模块，函数节流等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resultCache</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">cachedFn</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> hit = cache[str];</span><br><span class="line">        <span class="keyword">return</span> hit || (cache[str] = fn(str));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>它取决于函数调用的位置。</p><p>分为以下几种情况：</p><ul><li>new 创建的对象实例，绑定到新创建的对象(非显示返回函数或对象的情况下)</li><li>call/apply/bind：严格模式下指向第一个参数，非严格模式下，null 和 undefined 指向全局对象，基本数据类型指向其包装对象</li><li>事件，指向绑定事件的那个元素</li><li>对象上的函数调用，绑定到那个对象</li><li>普通函数调用，严格模式下绑定到 undefined，非严格模式绑定到全局对象</li><li>箭头函数指向包裹箭头函数的第一个普通函数的 this（定义时指向谁就是谁，不会随着调用者的改变而改变）</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>记录一道面试题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">alert(foo);</span><br></pre></td></tr></table></figure><p>结果： 1<br>解析：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    foo = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="number">1</span>;</span><br><span class="line">bar();</span><br><span class="line">alert(foo);</span><br></pre></td></tr></table></figure></p><p>代码实际上会变成以上所示，bar 函数里面的 foo 函数声明会被提升，由于后面又有 <code>foo = 10</code> 会把函数声明的值给覆盖，相当于变成了 <code>var foo = 10</code>，这里面的 foo 是 bar 函数执行上下文中的变量对象，在外面获取不到，所以 alert 的其实还是外面的 foo 变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了总结执行上下文、this、作用域以及闭包这几个基础知识点，看了很多的文章，但发现大多是对其表现进行总结，为了更好的记忆我就去了解了下 JS 的编译原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS 中的对象继承</title>
    <link href="https://gromimiss.github.io/2019/09/21/extend/"/>
    <id>https://gromimiss.github.io/2019/09/21/extend/</id>
    <published>2019-09-20T16:00:00.000Z</published>
    <updated>2020-04-29T09:24:02.376Z</updated>
    
    <content type="html"><![CDATA[<p>对象继承作为 JS 的基础知识点之一，它是怎么做到的呢？ES5 的继承和 ES6 的继承之间的区别又是什么呢？</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每个函数都有一个 prototype 属性，它指向了一个对象，这个对象就是原型。每个对象都有一个内置属性 <code>__proto__</code>，这个属性会指向该对象的原型，原型则含有一个 constructor 属性指向构造函数。</p><h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h3><p>new 操作符做了什么？它会创建一个用户定义的对象类型的实例或者具有构造函数的内置对象的实例。<br>它内部的实现原理：</p><ol><li>继承自 Ctor.prototype 的新对象会被创建</li><li>将 this 绑定到新创建的对象</li><li>构造函数若没有显式的返回一个对象，则返回创建的对象，若显式的返回了一个对象则会覆盖创建的对象（非对象类型不会覆盖，如 null，string，number，undefined，boolean，symbol）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newOperator</span>(<span class="params">Ctor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(Ctor.prototype);</span><br><span class="line">    <span class="keyword">let</span> params = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> result = Ctor.apply(obj, params);</span><br><span class="line">    <span class="keyword">if</span> (result !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">'object'</span> || <span class="keyword">typeof</span> result === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>每个对象都拥有一个 <code>__proto__</code> 内置属性，它指向了该对象的原型对象，而原型对象也会拥有一个 <code>__proto__</code> 内置属性，他也会指向一个原型对象。当在查找一个对象上的方法或属性时，会先在构造函数内部查找，若没有找到，则会在其原型对象上查找，若还没有找到则会继续往上搜索，直到最后指向了 null。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>原型继承</li></ul><p>将父类实例赋值给子类的原型，形成一条原型链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'Tom'</span>);</span><br><span class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Child(<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure><p>缺点：不能在创建子类实例的时候向父类构造函数传递参数，并且若父类构造函数中的属性是一个引用类型的值，之后创建出来的实例的该属性将会指向一个引用，互相影响。</p><ul><li>组合继承</li></ul><p>结合原型链和借用构造函数的方式实现一个继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Child(<span class="string">'Tom'</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure><p>缺点：执行了两次构造函数。</p><ul><li>寄生组合继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Child,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Child(<span class="string">'Tom'</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure><h2 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h2><p>原代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    getAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解析后的主要代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 设置 subClass.prototype：以父类原型对象为基础创建一个新对象，这个对象的 constructor 指向子类构造函数</span></span><br><span class="line">    subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123; </span><br><span class="line">        <span class="keyword">constructor</span>: &#123; </span><br><span class="line">            value: subClass, </span><br><span class="line">            writable: <span class="literal">true</span>, </span><br><span class="line">            configurable: <span class="literal">true</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="comment">// 设置 subClass.__proto__ 为父构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (superClass) _setPrototypeOf(subClass, superClass); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createSuper</span>(<span class="params">Derived</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="comment">// 前面通过 _inherts 方法设置了 __proto__ 为父构造函数，所以这里指向父构造函数</span></span><br><span class="line">        <span class="keyword">var</span> Super = _getPrototypeOf(Derived), result; </span><br><span class="line">        <span class="keyword">if</span> (_isNativeReflectConstruct()) &#123; </span><br><span class="line">            <span class="keyword">var</span> NewTarget = _getPrototypeOf(<span class="keyword">this</span>).constructor; </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                类似于 new:</span></span><br><span class="line"><span class="comment">                创建一个以 Super 为构造函数，arguments 为传入构造函数中的参数，NewTarget 为新创建对象的原型对象的实例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                和以下代码等价：</span></span><br><span class="line"><span class="comment">                var result = Object.create(NewTarget.prototype);</span></span><br><span class="line"><span class="comment">                Super.apply(result, args);</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            result = <span class="built_in">Reflect</span>.construct(Super, <span class="built_in">arguments</span>, NewTarget); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为什么不直接使用 new Super() 返回一个父类实例?</span></span><br><span class="line">            <span class="comment">// 因为这样返回的就是一个单纯的父类实例，后面在子类原型上挂的方法将获取不到</span></span><br><span class="line">            result = Super.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 若调用以上方法没有得到返回值或者返回值不是对象或函数，则会直接返回子类实例，否则返回返回值</span></span><br><span class="line">        <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, result); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型和构造函数上定义相应的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (protoProps) _defineProperties(Constructor.prototype, protoProps); </span><br><span class="line">    <span class="keyword">if</span> (staticProps) _defineProperties(Constructor, staticProps); </span><br><span class="line">    <span class="keyword">return</span> Constructor; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="comment">/*#__PURE__*/</span><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 不能像调用函数那样调用类 </span></span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建原型对象上的属性和构造函数上的属性</span></span><br><span class="line">    _createClass(Parent, [&#123;</span><br><span class="line">        key: <span class="string">"getName"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="comment">/*#__PURE__*/</span><span class="function"><span class="keyword">function</span> (<span class="params">_Parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将 Child 子类的 prototype 设置成 Parent.prototype</span></span><br><span class="line">    <span class="comment">// 将 Child 子类的 __proto__ 设置成 Parent</span></span><br><span class="line">    _inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 super 函数，这里会去执行父构造函数，将父类中设置的实例属性添加在子实例上</span></span><br><span class="line">    <span class="keyword">var</span> _super = _createSuper(Child);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Child);</span><br><span class="line"></span><br><span class="line">        _this = _super.call(<span class="keyword">this</span>, name);</span><br><span class="line">        _this.age = age;</span><br><span class="line">        <span class="keyword">return</span> _this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Child, [&#123;</span><br><span class="line">        key: <span class="string">"getAge"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Child;</span><br><span class="line">&#125;(Parent);</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>ES5 的继承实际上是创建一个子类的实例对象，然后将父类的属性都添加到这个实例对象上，而 ES6 的继承中子类必须在 constructor 方法中调用 super 方法，通过调用 super 方法在支持 Reflect.construct 的情况下创建一个以父构造函数为构造函数，子类构造函数为原型对象的实例，后面子类的属性都会添加到这个实例上，若不支持的话则像 ES5 的继承一样创建一个子类的实例对象，然后将父类的属性都添加到这个实例对象上。</p><p>上面例子的结构对比图：</p><center><br>    <img src="/assets/extend/1.jpg"><br></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对象继承作为 JS 的基础知识点之一，它是怎么做到的呢？ES5 的继承和 ES6 的继承之间的区别又是什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="https://gromimiss.github.io/2019/08/10/copy/"/>
    <id>https://gromimiss.github.io/2019/08/10/copy/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2020-04-21T06:20:35.387Z</updated>
    
    <content type="html"><![CDATA[<p>浅拷贝和深拷贝作为面试必考知识点之一，特此记录下。</p><a id="more"></a><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><h3 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h3><p>对象只会被会克隆最外部的一层，更深层的对象还是通过引用指向同一块堆内存。</p><h3 id="浅拷贝有哪些？"><a href="#浅拷贝有哪些？" class="headerlink" title="浅拷贝有哪些？"></a>浅拷贝有哪些？</h3><p>Object.assign()、展开运算符、Array.from() 等</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        result[key]= obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h3><p>对对象中的对象也会进行一份拷贝，指向不同的堆内存。</p><h3 id="深拷贝有哪些？"><a href="#深拷贝有哪些？" class="headerlink" title="深拷贝有哪些？"></a>深拷贝有哪些？</h3><p>JSON.parse(JSON.stringify(obj))、jquery 中的 extend、lodash 中的 extend 等。</p><h3 id="简单实现-1"><a href="#简单实现-1" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleDeepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        result[key] = simpleDeepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是像 JSON.parse(JSON.stringify(obj)) 和上面的 simpleDeepClone 其实都只是实现了简单的深拷贝，实际上我们还需要考虑一些特殊的场景。</p><ul><li>对函数、regexp、symbol、Date 等的克隆</li><li>稀疏数组（指有部分内存空间未被使用的数组，虽然定义了 n 个元素的空间，但实际上没有放满 n 个元素，有部分空间是 empty）</li><li>自定义对象的对象类型会丢失，所有对象都会指向 Object</li><li>循环引用会报错：<code>RangeError: Maximum call stack size exceeded</code></li></ul><p>当不考虑函数、自定义对象以及 symbol 的克隆的话可以直接使用 MessageChannel。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    port2.onmessage = <span class="function">(<span class="params">ev</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ev.data);</span><br><span class="line">    &#125;;</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整的实现"><a href="#完整的实现" class="headerlink" title="完整的实现"></a>完整的实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldList = [];</span><br><span class="line">    <span class="keyword">const</span> newList = [];</span><br><span class="line">    <span class="keyword">const</span> _clone = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 函数、自定义对象、日期、正则、循环引用需要特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj.source, obj.flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解决循环引用的问题</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">        <span class="keyword">const</span> idx = oldList.indexOf(obj);</span><br><span class="line">        <span class="keyword">if</span> (idx !== <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newList[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        oldList.push(obj);</span><br><span class="line">        newList.push(result);</span><br><span class="line">        <span class="comment">// 遍历 symbol 类型的属性</span></span><br><span class="line">        <span class="keyword">let</span> symbolKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line">        <span class="keyword">if</span> (symbolKeys.length) &#123;</span><br><span class="line">            symbolKeys.forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">                result[key] = _clone(obj[key]);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            result[key] = _clone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _clone(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取属性的方法：</p><ul><li>for…in 返回所有能通过对象访问的可枚举属性，包括实例和原型中的属性</li><li>Object.keys 返回对象自身所有的可枚举属性，不包括原型中的属性</li><li>Object.getOwnPropertyNames 返回对象自身的属性（包括不可枚举属性但是不包括 Symbol 值作为名称的属性），不包括原型中的属性</li><li>Object.getOwnPropertySymbols 返回对象中以 Symbol 值作为名称的属性</li><li>Reflect.ownKeys 返回对象自身的属性（包括不可枚举属性以及 Symbol 属性），相当于 <code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>深克隆需要注意的情况可能还不止这些，并且如果对象特别大特别深的情况下，对性能会有影响，后续有时间看一下 lodash 的源码再来记录下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浅拷贝和深拷贝作为面试必考知识点之一，特此记录下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>charles 的常用操作</title>
    <link href="https://gromimiss.github.io/2019/07/25/charles/"/>
    <id>https://gromimiss.github.io/2019/07/25/charles/</id>
    <published>2019-07-24T16:00:00.000Z</published>
    <updated>2019-07-26T10:15:17.920Z</updated>
    
    <content type="html"><![CDATA[<p>Charles 是一个功能十分强大的抓包工具，如果说在 Windows 上用的比较多的是 Fiddler，那么在 Mac 上用的比较多的就是 Charles 了。它有很多实用的功能，给我带来了很多惊喜，并且还需要我去继续发现，解锁新的技能，借此先总结一波。</p><a id="more"></a><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>抓包是使用 charles 最基础也是最常见的操作了，它会通过将自己设置成代理服务器来完成抓包。一般移动端页面由于没有开发者工具，所以调试的时候使用的比较多，它能抓取请求，将请求数据和响应数据等信息都一一展示以便于我们去捕捉到问题的根源。并且，当对项目不了解，页面又比较多的时候，也可以通过 charles 来找到你需要改动的页面。</p><p>默认情况下，charles 会勾选系统代理，以至于在本地发出的请求也会被截取到，在移动端调试的时候可能不想抓取本地的请求，可以在 Proxy -&gt; macOS Proxy 取消勾选。</p><h4 id="抓取移动设备上的-http-请求"><a href="#抓取移动设备上的-http-请求" class="headerlink" title="抓取移动设备上的 http 请求"></a>抓取移动设备上的 http 请求</h4><ol><li>在 Proxy -&gt; ProxySettings 设置 HTTP 代理的端口，默认是 8888</li><li>在 Help -&gt; Local IP Addresses 中查看本机的 IP 地址</li><li>手机上在连接的 WIFI 中设置代理：设置 -&gt; 无线局域网 -&gt; 指定 wifi -&gt; HTTP 代理 -&gt; 设置为手动，填写上面的 ip 地址和端口</li><li>在 charles 中允许访问，如果不想每换个手机都需要点击允许访问，可以在 Proxy -&gt; Access Control Settings 中加入 0.0.0.0/0(IPv4) 或 ::/0(IPv6)</li><li>在 charles 中查看抓取到的请求相关的信息</li></ol><h4 id="抓取移动设备上的-https-请求"><a href="#抓取移动设备上的-https-请求" class="headerlink" title="抓取移动设备上的 https 请求"></a>抓取移动设备上的 https 请求</h4><p>https 请求不同于 http 请求， 它加了一层 SSL 验证，所以在以上步骤后还需要：</p><ol><li>在手机上安装证书：<br>在浏览器中打开 <a href="http://chls.pro/ssl" target="_blank" rel="noopener">http://chls.pro/ssl</a> 下载并安装证书（可以在 SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser 中查看如何安装证书）。</li><li>在 Charles 中允许 SSL 代理：Proxy -&gt; SSL Proxying Settings -&gt; 添加要抓取的 https 请求，若想抓取所有 https 请求，可以添加 *:443</li></ol><p>遇到的问题：</p><ul><li><p>charles 抓取 https 请求失败，提示：</p><ol><li>Failure SSLHandshake:Received fatal alert: unknown_ca </li><li>You may need to configure your browser or application to trust the Charles Root Certificate.<br>这是因为在 ios 10.3 之前安装自定义证书会默认信任，但之后安装新的证书默认是不受信任的，需要手动去设置，设置路径：设置 -&gt; 通用 -&gt; 关于本机 -&gt; 设置信任证书</li></ol></li><li><p>某些 app 禁止了 https 代理，比如微信新版本现在就不可以抓取 https 代理了，我的微信版本 7.0.5 还可以抓取</p></li></ul><h3 id="模拟请求"><a href="#模拟请求" class="headerlink" title="模拟请求"></a>模拟请求</h3><p>和后端调试过程中，后端定位问题时，往往会打断点让我们再请求一次，就可以直接在 charles 中重新发起请求，而不需要再到页面中手动走流程，更快捷省力。</p><ol><li>重复发送请求<ul><li>选中一个请求 -&gt; 右键 -&gt; Repeat(发送一次)</li><li>选中一个请求 -&gt; 右键 -&gt; Repeat Advanced -&gt; 配置并发量和重复请求次数</li></ul></li><li>手动添加参数，模拟请求<ul><li>选中一个请求 -&gt; 右键 -&gt; Compose -&gt; 配置请求相关信息 -&gt; Execute 执行请求（模拟指定的请求）</li><li>Tools -&gt; Compose New Request -&gt; 配置请求相关信息 -&gt; Excute 执行请求（模拟新的请求）</li></ul></li></ol><h3 id="过滤请求"><a href="#过滤请求" class="headerlink" title="过滤请求"></a>过滤请求</h3><p>通常情况下，网络请求会很多，有时候我们需要从几十个请求里去找到我们想要抓取的哪个请求，比较费时，这个时候就可以对网络请求进行过滤，过滤出我们想要的请求。</p><ul><li>在界面中点击 Sequence -&gt; Filter -&gt; 输入想匹配到的请求包含字符串，比如想抓取百度的请求，就可以输入 baidu。</li><li>Proxy -&gt; Recording Settings -&gt; 配置需要监控的协议，地址，端口（高级配置）</li></ul><h3 id="代理转发"><a href="#代理转发" class="headerlink" title="代理转发"></a>代理转发</h3><p>一般我们的服务都分为本地、测试、预发、线上环境，在开发过程中我们可能需要连的是后端的 ip，并且可能一个项目需要和多个后端对接，之后上测试，上预发又需要连接到相应的环境，就需要用到 charles 的代理转发功能了。</p><p>Tools -&gt; Map Remote Settings -&gt; 勾选 Enable Map Remote -&gt; Add</p><p>它不像 switchhost，它的配置可以精确到协议，端口，路径。</p><center><br>    <img src="/assets/charles/1.png" width="50%"><br></center><h3 id="重写设置"><a href="#重写设置" class="headerlink" title="重写设置"></a>重写设置</h3><p>我们可以配置对某些请求重写它的请求信息，每次发送请求匹配到配置好的 url 时，charles 就会截取到请求，重写配置好的请求信息。比如同一个 ip 的不同端口对应着不同的环境，就可以通过种不同的 cookie 来映射要连接的是什么环境。并且在开发的过程中也可以通过种 cookie 来隔离某些请求，做一些和其他请求不同的操作。</p><p>使用：</p><p>Tools -&gt; Rewrite Settings -&gt; 勾选 Enable Rewrite -&gt; Add</p><center><br>    <img src="/assets/charles/2.png" width="50%"><br></center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>charles 是开发调试过程一个强大的工具，不光开发，测试也可以通过它来更好的定位到问题，找对应的开发去解决问题。它还有很多功能是我没有用到的，等用到过之后再来补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Charles 是一个功能十分强大的抓包工具，如果说在 Windows 上用的比较多的是 Fiddler，那么在 Mac 上用的比较多的就是 Charles 了。它有很多实用的功能，给我带来了很多惊喜，并且还需要我去继续发现，解锁新的技能，借此先总结一波。&lt;/p&gt;
    
    </summary>
    
    
      <category term="charles" scheme="https://gromimiss.github.io/tags/charles/"/>
    
      <category term="工具" scheme="https://gromimiss.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="抓包" scheme="https://gromimiss.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="https://gromimiss.github.io/2019/07/03/upload/"/>
    <id>https://gromimiss.github.io/2019/07/03/upload/</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2020-04-15T05:40:40.112Z</updated>
    
    <content type="html"><![CDATA[<p>一直对文件相关的 API 不是很了解，这次做到移动端上传图片的需求就想着总结记录一下。</p><a id="more"></a><h2 id="相关对象"><a href="#相关对象" class="headerlink" title="相关对象"></a>相关对象</h2><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>FileReader 用来异步读取存储在用户计算机上的文件内容，可读取 Blob 或 File 对象。</p><p>常用方法：</p><ul><li>readAsDataUrl(file/blob)：将指定的对象读取为一个 base64 编码的 URL</li><li>readAsText(file/blob, [,encoding])：将指定的对象根据特殊的编码格式转化为响应的字符串，* encoding 默认为 utf-8</li><li>readAsArrayBuffer(file/blob)：将指定的对象读取为一个 ArrayBuffer</li></ul><p>常用事件：</p><ul><li>load：文件成功读取时触发</li><li>error：文件读取失败时触发</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取的结果，ev.target.result === reader.result</span></span><br><span class="line">    <span class="built_in">console</span>.log(ev.target.result)</span><br><span class="line">&#125;;</span><br><span class="line">reader.readAsDataURL(file);</span><br></pre></td></tr></table></figure><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p>一个不可变、原始数据的类文件对象，可以通过 Blob() 构造函数将一个非 Blob 对象和数据构造为一个 Blob 对象。</p><p>Blob(array, [,options]): 可将由 ArrayBuffer, ArrayBufferView, Blob, DOMString 或者其他类似对象的混合体组成的数组转换为一个 Blob 对象。</p><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>File 基于 Blob，它继承了 Blob 的功能并且支持用户系统上的文件。以下三种情况下都会返回这种对象：</p><ol><li>用户通过 <code>&lt;input&gt;</code> 元素选择文件后返回的 FileList 对象</li><li>拖放操作时生成的 DataTransfer 对象</li><li>HTMLCanvasElement 中的 mozGetAsFile()</li></ol><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p>一个用来表示通用、固定长度的原始二进制数据缓冲区。通过  ArrayBuffer 构造函数分配一段可以存放数据的连续内存区域。详细见<a href="https://blog.csdn.net/lichwei1983/article/details/43893025" target="_blank" rel="noopener">这里</a>。</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL.createObjectURL()：返回一个 URL，这个URL表示指定的 File 对象 / Blob 对象，一般用来显示图片。<br>URL.revokeObjectURL()：用完释放 URL 以获得最佳性能和内存使用状况。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>如果需要一次上传多张图片则要设置 multiple 属性，这个属性在 ios 中有效，但是 android 中还是只能上传单张图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"file"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">ref</span>=<span class="string">"uploadImg"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">multiple</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">accept</span>=<span class="string">'image/*'</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">change</span>=<span class="string">"change"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>移动端上传图片，由于现在很多手机像素都很高，所以上传的手机中的照片都很大，以至于上传会很慢，所以需要对图片先做一个压缩再进行上传。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">change(event) &#123;</span><br><span class="line">    <span class="keyword">const</span> files = <span class="keyword">this</span>.$refs.uploadImg.files;</span><br><span class="line">    <span class="keyword">const</span> len = <span class="keyword">this</span>.imgList.length;</span><br><span class="line">    <span class="keyword">if</span> (len + files.length &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        note(<span class="string">'图片最多可上传9张'</span>, &#123;</span><br><span class="line">            mask: <span class="literal">false</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.forEach.call(files, (file, index) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> url = URL.createObjectURL(file);</span><br><span class="line">        <span class="keyword">this</span>.imgList.push(&#123;</span><br><span class="line">            status: <span class="string">'loading'</span>,</span><br><span class="line">            displayPath: url,</span><br><span class="line">            realPath: <span class="string">''</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.ArrayBuffer &amp;&amp;</span><br><span class="line">            <span class="built_in">window</span>.Uint8Array &amp;&amp;</span><br><span class="line">            <span class="built_in">window</span>.Blob &amp;&amp;</span><br><span class="line">            <span class="built_in">window</span>.File &amp;&amp;</span><br><span class="line">            file.size &gt; <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.compress(url, file, index, len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.uploadImg(file, index, len);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">compress(url, file, index, len) &#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = url;</span><br><span class="line">    img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> width = img.width;</span><br><span class="line">        <span class="keyword">let</span> height = img.height;</span><br><span class="line">        <span class="keyword">let</span> ratio;</span><br><span class="line">        <span class="keyword">if</span> ((ratio = width * height / <span class="number">1000000</span>) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ratio = <span class="built_in">Math</span>.sqrt(ratio);</span><br><span class="line">            width /= ratio;</span><br><span class="line">            height /= ratio;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ratio = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">        canvas.width = width;</span><br><span class="line">        canvas.height = height;</span><br><span class="line">        <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="comment">// 进行最小压缩</span></span><br><span class="line">        <span class="keyword">let</span> ndata = canvas.toDataURL(<span class="string">'image/jpeg'</span>, <span class="number">0.5</span>);</span><br><span class="line">        canvas = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.transformFile(ndata, file, index, len);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">transformFile(url, file, index, len) &#123;</span><br><span class="line">    <span class="comment">// 解码使用 base-64 编码的字符串</span></span><br><span class="line">    <span class="keyword">let</span> bytes = atob(url.split(<span class="string">','</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> arrBf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(bytes.length);</span><br><span class="line">    <span class="keyword">let</span> unitArr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arrBf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        unitArr[i] = bytes.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([arrBf], &#123;</span><br><span class="line">        type: file.type,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> File([blob], name, &#123;</span><br><span class="line">        type: file.type,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (result &amp;&amp; result.size) &#123;</span><br><span class="line">        <span class="keyword">this</span>.uploadImg(result, index, len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.uploadImg(file, index, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">uploadImg(file, index, len) &#123;</span><br><span class="line">    uploadImage([file]).then(<span class="function">(<span class="params">urls</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.imgList[len + index].status = <span class="string">'success'</span>;</span><br><span class="line">        <span class="keyword">this</span>.imgList[len + index].realPath = urls[<span class="number">0</span>];</span><br><span class="line">    &#125;)</span><br><span class="line">        .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.imgList[len + index].status = <span class="string">'failed'</span>;</span><br><span class="line">            note(<span class="string">'服务器异常'</span>, &#123;</span><br><span class="line">                mask: <span class="literal">false</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">removeImg(index) &#123;</span><br><span class="line">    URL.revokeObjectURL(<span class="keyword">this</span>.imgList[index].displayPath);</span><br><span class="line">    <span class="keyword">this</span>.imgList.splice(index, <span class="number">1</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li>使用相机拍照后上传，上传一次后 change 事件不再触发（在公司APP内是这样子，在浏览器中正常）</li><li>在安卓手机中直接打开相册上传图片只能选择一张，目前没办法做到选择多张</li><li>在公司 APP 中上传图片只能选择图片不能选择照相</li><li>在 app 上页面请求和其他资源请求协议不一致可能会出问题。页面是 http 请求，但是图片是 https 请求，图片在公司 APP 中就无法正常显示，所以不能写死协议，由浏览器自动补全</li><li>在安卓手机中当上传一次图片之后取消选择也会触发 change 事件，所以要在 change 事件中加一层判断</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>若是承载在 app 上的 h5 页面做上传图片最好还是使用原生提供的方法或者在微信上可以使用 jssdk 提供的上传图片，要不然体验还是不怎么好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直对文件相关的 API 不是很了解，这次做到移动端上传图片的需求就想着总结记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>表情编辑器组件的简单实现</title>
    <link href="https://gromimiss.github.io/2019/06/24/emojiEditor/"/>
    <id>https://gromimiss.github.io/2019/06/24/emojiEditor/</id>
    <published>2019-06-23T16:00:00.000Z</published>
    <updated>2019-06-26T08:23:51.793Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中遇到需要用到表情编辑器的需求，看到老后台里面的表情编辑器一堆 Bug，正好这个项目要迁移新后台，就想着重构一版，原本以为挺简单的一玩意，但是真正开发的过程中遇到了很多问题。之前也没有这块的经验，都是直接使用的网上现成的库，所以这次想着记录一下摸索的过程。</p><a id="more"></a><h2 id="基本功能介绍"><a href="#基本功能介绍" class="headerlink" title="基本功能介绍"></a>基本功能介绍</h2><p>这个表情编辑器不同于别的富文本编辑器，它只支持插入表情，功能比较单一，正也是因为需要支持表情，涉及到标签，所以不能通过 textarea 来写。并且前期我一直在考虑这个编辑器是否要双向绑定，如果双向绑定就意味着要去区分这个值是在哪里改变的，因为 value(真正的数据，会传到数据库的数据，不带标签) 和 content(展示在页面上的数据，带标签，展示表情图) 是不同的，而 value 改变，content 就要改变，所以需要监听 value 是组件内的改变还是组件外的改变，若是组件内的改变，则不应该触发 content 的改变。最后考虑到如果使用传入默认值的形式，那么就只能暴露出方法，每次有改动都需要调用这个方法去改变值，相较于双向绑定，使用起来没有那么方便，并且表情编辑器也是表单组件中的一部分，所以还是做成双向绑定更为合适。</p><p>根据项目需要，分析出编辑器需要有以下可配置项：</p><ul><li>value 编辑器的 value 值</li><li>width 编辑器的宽度，默认 100%</li><li>height 编辑器的高度</li><li>max 编辑器最多可输入的字符数</li><li>placeholder 编辑器未输入时显示的提示字符</li></ul><p>UI 展示如下：</p><center><br>    <img src="/assets/emojiEditor/1.jpg" width="40%"><br></center><h2 id="主要实现"><a href="#主要实现" class="headerlink" title="主要实现"></a>主要实现</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ul><li>准备表情合成的雪碧图、表情字符和对应类名间的映射文件</li><li>基本 HTML 结构：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;cus-emoji-editor&quot; :style=&quot;styleObj&quot; @click.stop=&quot;&quot;&gt;</span><br><span class="line">    &lt;!-- 工具栏：插入表情的按钮 --&gt;</span><br><span class="line">    &lt;div class=&quot;cus-emoji-editor__toolbar&quot;&gt;</span><br><span class="line">        &lt;span </span><br><span class="line">            id=&quot;emojiBtn&quot; </span><br><span class="line">            class=&quot;cus-emoji-editor__btn-emoji&quot;</span><br><span class="line">            @click=&quot;insertAutoFocus&quot;&gt;&lt;/span&gt;</span><br><span class="line">        &lt;ui-popover </span><br><span class="line">            target=&quot;#emojiBtn&quot;</span><br><span class="line">            ref=&quot;emojiPopover&quot; </span><br><span class="line">            placement=&quot;top&quot;</span><br><span class="line">            trigger=&quot;click&quot;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ui-menu </span><br><span class="line">                    :menu=&quot;menu&quot; </span><br><span class="line">                    class=&quot;cus-emoji-editor__emoji-menu line&quot; </span><br><span class="line">                    @emit=&quot;menuChange&quot;</span><br><span class="line">                    current-menu=&quot;emoji&quot;&gt;&lt;/ui-menu&gt;</span><br><span class="line">                &lt;div class=&quot;cus-emoji-editor__emoji-body&quot;&gt;</span><br><span class="line">                    &lt;i </span><br><span class="line">                        v-for=&quot;(item, key) in emojData&quot; </span><br><span class="line">                        :key=&quot;key&quot; </span><br><span class="line">                        :class=&quot;item&quot; </span><br><span class="line">                        :title=&quot;key + &apos;_web&apos;&quot; </span><br><span class="line">                        @click=&quot;insertEmoji(key, item)&quot;&gt;&lt;/i&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/ui-popover&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 编辑区域--&gt;</span><br><span class="line">    &lt;div class=&quot;cus-emoji-editor__content&quot;&gt;</span><br><span class="line">        &lt;div </span><br><span class="line">            class=&quot;cus-emoji-editor__placeholder&quot; </span><br><span class="line">            v-if=&quot;placeholder &amp;&amp; !hasVal &amp;&amp; !isFocus&quot; </span><br><span class="line">            @click=&quot;focus&quot;&gt;&#123;&#123;placeholder&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div </span><br><span class="line">            class=&quot;cus-emoji-editor__input&quot;</span><br><span class="line">            v-html=&quot;content&quot;</span><br><span class="line">            contenteditable=&quot;true&quot;</span><br><span class="line">            ref=&quot;input&quot;</span><br><span class="line">            @focus=&quot;isFocus = true&quot;</span><br><span class="line">            @blur=&quot;isFocus = false&quot;</span><br><span class="line">            @compositionstart=&quot;isComplete = false&quot;</span><br><span class="line">            @compositionend=&quot;isComplete = true&quot;</span><br><span class="line">            @input=&quot;handleInput&quot;</span><br><span class="line">            @paste=&quot;handlePaste&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;cus-emoji-editor__len&quot; v-if=&quot;max&quot;&gt;</span><br><span class="line">            &#123;&#123;len&#125;&#125;/&#123;&#123;max&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>通过背景图位置的设置控制表情图的显示，比如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.qqemoji &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 28px;</span><br><span class="line">    height: 28px;</span><br><span class="line">    background: url(xxx.png) 0 0 no-repeat;</span><br><span class="line">    zoom: 1;</span><br><span class="line">    background-size: 1900%;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    box-sizing: content-box;</span><br><span class="line">&#125;</span><br><span class="line">.qqemoji-1 &#123;</span><br><span class="line">    background-position: -4px -4px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑器的主体功能"><a href="#编辑器的主体功能" class="headerlink" title="编辑器的主体功能"></a>编辑器的主体功能</h3><h4 id="相关属性及-api-复习"><a href="#相关属性及-api-复习" class="headerlink" title="相关属性及 api 复习"></a>相关属性及 api 复习</h4><p>想要了解所有 API，可见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Selection" target="_blank" rel="noopener">文档</a>.</p><ul><li>Selection 对象：表示用户选择的文本范围或插入符号的当前位置，可能横跨多个元素。</li><li>Range 对象：用户选择的某个区域（某个连续的一部分），通常情况下用户只能选择一个范围，但是用户也可以通过 control 键并选多个区域（chrome 中禁止了这个动作）。</li><li>anchor：一个选区的起始点，即鼠标按下瞬间的那个点。</li><li>focus：一个选区的终点，即鼠标松开瞬间所记录的那个点</li><li>window.getSelection() 获取选中对象，在firefox、safari、chrome、opera、ie9+下使用</li><li>document.selection 获取选中对象,在 ie9 以下使用</li><li>selection.getRangeAt(0) 选中的第一个区域</li><li>selection.removeAllRanges() 将所有区域从选区中移除</li><li>selection.addRange() 添加一个区域对象到选区</li><li>range.insertNode(el) 在选中位置起点处插入元素</li><li>range.cloneRange() 克隆一个选中区域</li><li>range.setStart(el, 1) 设置 range 对象的起点，el 为 range 的起始位置，1 为从 el 开始位置算起的偏移量</li><li>range.setEnd(el, 1) 设置 range 对象的终点</li><li>range.setStartBefore(el) 将某个节点的起点位置设置为 range 对象的起点位置</li><li>range.setStartAfter(el) 将某个节点的终点位置设置为 range 对象的起点位置</li><li>range.setEndBefore(el) 将某个节点的起点位置设置为 range 对象的终点位置</li><li>range.setEndAfter(el) 将某个节点的终点位置设置为 range 对象的终点位置</li><li>range.collapse(true) true 光标向 start 折叠为一个点，false 光标向 end 折叠为一个点</li><li>range.deleteContents() 从文档中移除 range 中的内容</li></ul><h4 id="主体功能实现"><a href="#主体功能实现" class="headerlink" title="主体功能实现"></a>主体功能实现</h4><p>一个表情编辑器主要考虑三点，一是输入文字、二是插入表情、三是复制粘贴。整个流程是这样的：</p><ul><li>输入文字 -&gt; 计算字符数 -&gt; 组件内部设置 value -&gt; 反应到组件外</li><li>插入表情 -&gt; 组件内部设置 value -&gt; 反应到组件外</li><li>复制粘贴 -&gt; 组件内部设置 value -&gt; 反应到组件外</li><li>用户设置 value -&gt; 触发 content 的设置</li></ul><p>下面是细节实现：</p><ul><li>输入文字是上面三个点中最简单的一个，它只需要保证光标是在一个 div 中（用于分行），并且考虑输入中文时应该到输入完成才触发值的改变。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">handleInput(ev) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // 中文是否输完</span><br><span class="line">        if (!this.isComplete) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let firstChild = this.$refs.input.firstChild;</span><br><span class="line">        if (!firstChild || firstChild.nodeName !== &apos;DIV&apos;) &#123;</span><br><span class="line">            this.$refs.input.innerHTML = &apos;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.max || this.max === 0) &#123;</span><br><span class="line">            this.setVal();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.debounceSetVal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">&#125;,</span><br><span class="line">setVal() &#123;</span><br><span class="line">    this.isInner = true;</span><br><span class="line">    const children = this.$refs.input.children;</span><br><span class="line">    let val = &apos;&apos;;</span><br><span class="line">    // 分行</span><br><span class="line">    for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">        val = i !== children.length - 1 ?</span><br><span class="line">            `$&#123;val&#125;$&#123;children[i].textContent&#125;\n` : `$&#123;val&#125;$&#123;children[i].textContent&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value = val;</span><br><span class="line">    this.$emit(&apos;input&apos;, this.value);</span><br><span class="line">    this.$emit(&apos;change&apos;, this.value);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>插入表情里有很多需要注意的点:</li></ul><ol><li>当没有进入编辑器的焦点时，选择表情也应该可以插入表情，并且要考虑到编辑器是否有值，默认聚焦光标会在编辑器的起始点，所以需要我们手动将光标移动到文本最后。</li><li>当编辑器插入表情或者粘贴时，它会被添加到 <code>&lt;br&gt;</code> 后面，这个 <code>&lt;br&gt;</code> 不会被自动去掉。<code>&lt;br&gt;</code> 的作用是光标定位，在 <code>&lt;div&gt;</code> 里面加一个 <code>&lt;br&gt;</code> 可以让光标定位到 <code>&lt;div&gt;</code> 里面，但是要注意的是输入字符浏览器会自动去掉 <code>&lt;br&gt;</code>，而插入表情和复制粘贴需要我们自己手动去除。</li><li>表情图片的展示必须使用 img 标签，否则光标没法正确的展示，但是 img 标签还是会有一个问题，由于没有设置 src 属性，它会有一个边框，通过设置 border 也没有办法去掉，只能通过在 src 上添加一个透明图片。</li><li>表情字符要存在一个标签中，这样之后就可以通过 textContent 属性获取所有文本内容，它包含了子孙元素中的文本。</li><li>每个编辑器的类名必须要区分开来，否则若一个编辑器设置了 this.range，另一个编辑器也会拿到那个 range 的值，导致 range 混乱，插入表情出现问题（我这里是加了一个 manage.js，管理所有编辑器的 uid）。</li><li>选中文本插入表情，选中文本应该被清除。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">// 处理首次进入页面，还没有保存 range 对象的情况，解决第一个问题</span><br><span class="line">insertAutoFocus() &#123;</span><br><span class="line">    if (!this.range) &#123;</span><br><span class="line">        this.$refs.input.focus();</span><br><span class="line">        // 默认进入焦点焦点会在内容区的起始位置，所以要将光标移到内容区的最后</span><br><span class="line">        this.moveCursorToLast(this.$refs.input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">moveCursorToLast(el) &#123;</span><br><span class="line">    if (!el.lastChild) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (window.getSelection) &#123;</span><br><span class="line">        let range = window.getSelection();</span><br><span class="line">        range.selectAllChildren(el.lastChild); // range 选择obj下所有子内容</span><br><span class="line">        range.collapseToEnd(); // 光标移至最后</span><br><span class="line">    &#125; else if (document.selection) &#123; // 兼容 IE</span><br><span class="line">        let range = document.selection.createRange();</span><br><span class="line">        range.moveToElementText(el.lastChild);</span><br><span class="line">        range.collapse(false);</span><br><span class="line">        range.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">// 若选区是在编辑区的，则保存这个选区</span><br><span class="line">getCursor() &#123;</span><br><span class="line">    const selection = this.getSelection();</span><br><span class="line">    const anchorNode = selection.anchorNode;</span><br><span class="line">    const inputClass = `cus-emoji-editor__input--$&#123;this.uid&#125;`;</span><br><span class="line">    const placeholderClass = `cus-emoji-editor__placeholder--$&#123;this.uid&#125;`;</span><br><span class="line">    const aNCls = anchorNode.className || &apos;&apos;;</span><br><span class="line">    const aNParentCls = anchorNode.parentNode.className || &apos;&apos;;</span><br><span class="line">    const ancestorCls = anchorNode.parentNode.parentNode.className || &apos;&apos;;</span><br><span class="line">    // 这里要区分不同编辑器</span><br><span class="line">    if (anchorNode &amp;&amp;</span><br><span class="line">        (aNCls.indexOf(inputClass) &gt; -1 ||</span><br><span class="line">            aNCls.indexOf(placeholderClass) &gt; -1 ||</span><br><span class="line">            aNParentCls.indexOf(inputClass) &gt; -1 ||</span><br><span class="line">            ancestorCls.indexOf(inputClass) &gt; -1)) &#123;</span><br><span class="line">        this.range = selection.getRangeAt(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">insertEmoji(key, className) &#123;</span><br><span class="line">    this.$refs.emojiPopover.hide();</span><br><span class="line">    let range = this.range;</span><br><span class="line">    if (!range) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 显示表情图</span><br><span class="line">    let el = document.createElement(&apos;img&apos;);</span><br><span class="line">    el.className = className;</span><br><span class="line">    // 存放表情字符</span><br><span class="line">    let elText = document.createElement(&apos;span&apos;);</span><br><span class="line">    elText.style.display = &apos;none&apos;;</span><br><span class="line">    elText.innerText = key;</span><br><span class="line">    // 删除之前选中区域的内容</span><br><span class="line">    range.deleteContents();</span><br><span class="line">    // 插入表情和字符</span><br><span class="line">    range.insertNode(el);</span><br><span class="line">    range.insertNode(elText);</span><br><span class="line">    // 将光标位置移动到插入的表情后</span><br><span class="line">    this.moveRange(el);</span><br><span class="line">    this.setVal();</span><br><span class="line">    this.removeBr(el, elText);</span><br><span class="line">&#125;,</span><br><span class="line">removeBr(el, elText) &#123;</span><br><span class="line">    // 当首次没有进入编辑器焦点，点击插入表情，表情会插入到 &lt;br&gt; 后</span><br><span class="line">    if (elText) &#123;</span><br><span class="line">        const prev = elText.previousSibling;</span><br><span class="line">        if (prev &amp;&amp; prev.nodeName === &apos;BR&apos; &amp;&amp; prev.parentNode.nodeName === &apos;DIV&apos;) &#123;</span><br><span class="line">            prev.parentNode.removeChild(prev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当编辑器插入表情或者粘贴时，后面的 &lt;br&gt; 不会自动被去掉</span><br><span class="line">    const next = el.nextSibling;</span><br><span class="line">    if (next &amp;&amp; next.nodeName === &apos;BR&apos; &amp;&amp; next.parentNode.nodeName === &apos;DIV&apos;) &#123;</span><br><span class="line">        next.parentNode.removeChild(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">moveRange(el, range) &#123;</span><br><span class="line">    range = (range || this.range).cloneRange();</span><br><span class="line">    if (el) &#123;</span><br><span class="line">        range.setStartAfter(el);</span><br><span class="line">    &#125;</span><br><span class="line">    range.collapse(true);</span><br><span class="line">    let selection = this.getSelection();</span><br><span class="line">    selection.removeAllRanges();</span><br><span class="line">    selection.addRange(range);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>复制粘贴：</li></ul><p>复制粘贴要考虑的是不需要将样式，图片等一起粘贴过来，我们只需要文本和表情，而表情就是一个图片，这一点暂时还没有处理，目前只支持复制文本。</p><p>小细节：toolbar 中表情 tool 可以使用 button 按钮，当你选中某些文本的时候就会有选中的效果，如果使用 span 标签，选中效果会被清除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">handlePaste(ev) &#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">    let data = ev.clipboardData.getData(&apos;text&apos;);</span><br><span class="line">    let selection = this.getSelection();</span><br><span class="line">    if (selection &amp;&amp; data !== &apos;&apos; &amp;&amp; data !== null) &#123;</span><br><span class="line">        let textNode = document.createTextNode(data);</span><br><span class="line">        // 删除选中文本</span><br><span class="line">        this.range.deleteContents();</span><br><span class="line">        // 插入文本</span><br><span class="line">        this.range.insertNode(textNode);</span><br><span class="line">        this.moveRange(textNode);</span><br><span class="line">        this.setVal();</span><br><span class="line">        this.removeBr(textNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="其他实现及注意点"><a href="#其他实现及注意点" class="headerlink" title="其他实现及注意点"></a>其他实现及注意点</h4><ul><li>有这样一个场景：在表格列表中点击某条记录中的编辑，打开编辑 dialog，dialog 中有表情编辑器，那么多条记录是共用的一个 dialog，编辑器也是同一个，只是编辑器的值会改变，此时需要在每次 dialog 打开时（即用户设置值的时候），将 range 清空，否则在没有聚焦时插入表情就会出现问题。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    value(newVal, oldVal) &#123;</span><br><span class="line">        if (this.isInner) &#123;</span><br><span class="line">            this.isInner = false;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.setContent(newVal);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    setContent(val) &#123;</span><br><span class="line">        let parseVal = parseEmojiMessage(val);</span><br><span class="line">        let eles = parseVal.split(/\n/);</span><br><span class="line">        let ele = &apos;&apos;;</span><br><span class="line">        for (let index = 0; index &lt; eles.length; index++) &#123;</span><br><span class="line">            const element = eles[index];</span><br><span class="line">            if (element) &#123;</span><br><span class="line">                ele += `&lt;div&gt;$&#123;element&#125;&lt;/div&gt;`;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.$refs.input.innerHTML = ele || &apos;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&apos;;</span><br><span class="line">        // 一定要清空</span><br><span class="line">        this.range = null;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文本删除时，div会被一并删除，所以当文本为空时要手动加上 <code>&lt;div&gt;&lt;br&gt;&lt;/div&gt;</code></li><li><code>&lt;br&gt;</code> 的作用只能是光标定位，换行会新增 <code>&lt;div&gt;&lt;br/&gt;&lt;/div&gt;</code>，但是当换行后又添加文字时 <code>&lt;br&gt;</code> 会被去掉，所以不能通过替换 <code>&lt;br&gt;</code> 为 \n 传到数据库，我们需要确保每一行都在一个 div 中，通过 div 来换行</li><li>列表中显示表情编辑器的内容时，需要将 emoji 字符 替换为表情图。由于 replace 会替换掉所有符合的字符串，所以一定要加匹配到的表情字符去重，以防止二次替换（将 <span> 中的表情字符再次替换掉）。</span></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    const parseEmojiMessage = (content) =&gt; &#123;</span><br><span class="line">    if (!content) &#123;</span><br><span class="line">        return &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    let regx = /\[[\u2E80-\u9FFF|BQXK|BQTS|BQHL|BQJX|BQBA|BQMS|BQBG|BQBT|BQJR|BQQZ|BQLW]+\]/g; // 匹配文本中表情相关信息</span><br><span class="line">    let matchList = content.match(regx);</span><br><span class="line">    let noRepeatMatch = [];</span><br><span class="line">    // 去重，防止替换过的在 span 标签中的表情字符被再次替换</span><br><span class="line">    matchList &amp;&amp; matchList.forEach((item) =&gt; &#123;</span><br><span class="line">        if (noRepeatMatch.indexOf(item) &lt;= -1) &#123;</span><br><span class="line">            noRepeatMatch.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    noRepeatMatch.forEach((item) =&gt; &#123;</span><br><span class="line">        let className = qqEmoj[item] || wxEmoj[item];</span><br><span class="line">        let str = `\\$&#123;item.substring(0, item.length - 1)&#125;\\]`;</span><br><span class="line">        // 替换的标签不要换行，否则表情中的\n处理会出问题</span><br><span class="line">        content = content</span><br><span class="line">            .replace(new RegExp(str, &apos;g&apos;), `&lt;span style=&quot;display: none;&quot;&gt;$&#123;item&#125;&lt;/span&gt;&lt;img src=&quot;http://h0.hucdn.com/open201926/c94e6ea80e94bba4_10x10.png&quot; class=&quot;$&#123;className&#125;&quot; /&gt;`);</span><br><span class="line">    &#125;);</span><br><span class="line">    return content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>由于宽度设置的是百分比，当英文单词放不下时，width会自动拉长，想要自动换行可以：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.cus-emoji-editor__input &#123;</span><br><span class="line">    width: xxxpx;</span><br><span class="line">    word-wrap: break-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="未实现的优化"><a href="#未实现的优化" class="headerlink" title="未实现的优化"></a>未实现的优化</h4><ul><li>复制 emoji 表情</li><li>目前点击表情 tool 时编辑器会失焦，光标消失，最好让编辑器在点击的时候还是聚焦的状态</li><li>每次符合条件的 range 对象都会被记录下来以至于之后失焦时点击插入表情都会插入在失焦时的位置，而首次没有 range 对象时点击插入表情会插入到文本末尾，这里可以考虑统一插入到最后（由于点击表情的时候编辑器就会失焦，所以没办法去区分是聚焦的时候点击的表情，还是失焦的时候点击的表情）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看似简单的表情编辑器在真正开发的过程中遇到的问题还挺多的，并且结合场景还会发现一些平时注意不到的问题。以上只是一个表情编辑器的简单实现，还有很多细节需要去继续优化，后续再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中遇到需要用到表情编辑器的需求，看到老后台里面的表情编辑器一堆 Bug，正好这个项目要迁移新后台，就想着重构一版，原本以为挺简单的一玩意，但是真正开发的过程中遇到了很多问题。之前也没有这块的经验，都是直接使用的网上现成的库，所以这次想着记录一下摸索的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://gromimiss.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>由于分页组件引发的一些思考</title>
    <link href="https://gromimiss.github.io/2019/05/21/page/"/>
    <id>https://gromimiss.github.io/2019/05/21/page/</id>
    <published>2019-05-20T16:00:00.000Z</published>
    <updated>2019-05-21T05:47:57.556Z</updated>
    
    <content type="html"><![CDATA[<p>之前在写组件库的时候就一直想不好对传入的不同的 prop 应该做怎么样的处理，最近总结了一下。</p><a id="more"></a><h2 id="prop-有哪些处理情况？"><a href="#prop-有哪些处理情况？" class="headerlink" title="prop 有哪些处理情况？"></a>prop 有哪些处理情况？</h2><p>前不久，在使用公司内部的组件库时遇到一个问题：它默认初始化时会触发一次页码 change 事件，而我在进入页面时会调用一次获取列表数据的接口，并且在页码 change 事件中也会调用一次获取列表数据的接口，这就导致了页面进入时会触发两次获取列表数据的接口，去找架构组同事沟通了下，他说这是考虑到了前端将列表数据存在本地，通过页码 change 事件去获取列表数据，这让我想到了关于组件 prop 的一些问题：</p><p>在组件中会使用到很多的 prop，通过传入的 prop 去判断是否要支持某个功能或者是作为一个组件的值。以 page 当前页为例，有以下3种情况：</p><ol><li>page 是一个双向绑定的值，在组件内部和外部传入的变量是永远保持一致的，即内部改变则外部也改变，外部改变内部也改变（双向）</li><li>page 由外部传入，组件内部通过 watch 这个属性来做一些内部数据的更新（不会影响到外部的数据，单向）</li><li>page 是外部传入的一个初始值，组件内部会在初次传入时将值赋给内部的一个变量，后期即便外部改变传入的变量值，内部也不再接收这个改变（首次有效）</li></ol><p>而分页组件中的 page 一般是作为一个初始值，在页码 change 事件中会携带一个当前页码的值，以供外部获取，而作为一个默认初始值，它后来没有改变，也就不应该去触发页码 change 事件。即便有一种特殊情况，用户将数据存在本地，通过获取页码信息的接口返回的页码信息来获取到本地对应页，也应该由用户通过 js 去改变 page 来触发 页码 change 事件然后获取列表数据。</p><h2 id="什么情况下应该触发-change-事件"><a href="#什么情况下应该触发-change-事件" class="headerlink" title="什么情况下应该触发 change 事件"></a>什么情况下应该触发 change 事件</h2><p>在组件中一个值改变有 3 种情况： </p><ol><li>用户改变（比如在 input 中输入文字）</li><li>组件内部改变（比如开发者通过组件暴露的一个方法去设置值）</li><li>它是一个双向绑定的值，开发者直接改变传入的变量则组件内部也接收到了改变</li></ol><p>change 事件是只要值改变就应该触发而不考虑是哪种情况下改变的值，但是这样会有一个问题：有部分业务场景下，我们只需要用户通过输入/选择改变值才触发 change 事件，然后去做一些特殊的处理，这个时候若只是原来那个 change 事件就没有办法去区分了，所以是否有必要去再添加一个额外的 change 事件更合适呢。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然，vue 中对数据的订阅发布触发视图的更新也是不考虑数据是哪里改变的，如何改变的，但是作为开发者，我们是可以知道在哪里做了数据的改变的，并且在代码中可以做一些额外的处理，而组件库作为基于 vue 的一些组件的封装，我们是没有办法在特定的场景做一些特定的操作的，因为 vue 是面向开发者的，而业务开发是面向用户的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在写组件库的时候就一直想不好对传入的不同的 prop 应该做怎么样的处理，最近总结了一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="vue" scheme="https://gromimiss.github.io/tags/vue/"/>
    
      <category term="组件库" scheme="https://gromimiss.github.io/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染过程及前端页面性能分析优化</title>
    <link href="https://gromimiss.github.io/2019/04/29/performance/"/>
    <id>https://gromimiss.github.io/2019/04/29/performance/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2020-04-17T13:34:59.386Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在浏览器输入网站域名，并按下回车之后的一段时间里，其实发生了很多事情，比如协议补全、域名解析、TCP 三次握手、发送请求、页面解析等等，因此这一过程可优化的点也很多。本文旨在阐述浏览器渲染网页时的一系列过程，在对浏览器如何工作足够了解的基础上，使用调试工具来分析页面性能，借此找到阻碍浏览器性能的问题点，从而做出相应优化。</p><a id="more"></a><h2 id="输入-URL-并回车后发生了什么"><a href="#输入-URL-并回车后发生了什么" class="headerlink" title="输入 URL 并回车后发生了什么"></a>输入 URL 并回车后发生了什么</h2><h3 id="浏览器解析-URL"><a href="#浏览器解析-URL" class="headerlink" title="浏览器解析 URL"></a>浏览器解析 URL</h3><p>当输入 URL 并回车后，浏览器首先会对 URL 进行解析，获取协议、主机、端口、路径，根据不同协议进行不同的处理。</p><h3 id="浏览器检查本地缓存"><a href="#浏览器检查本地缓存" class="headerlink" title="浏览器检查本地缓存"></a>浏览器检查本地缓存</h3><p>浏览器通过 Expires 和 Cache-control 来检查缓存是否新鲜，若命中缓存则直接从缓存中拉取资源信息，否则则发送新的请求。</p><p>Expires：HTTP 1.0 中提供，会比对此字段返回的时间和客户端时间，若在此之前则命中缓存。</p><p>Cache-control：HTTP 1.1 中新增，通过设置 max-age 指定缓存多久后过期（它会根据第一次请求的时间和设置的有效期计算出过期时间，在过期时间之前就能命中缓存）。若同时有 Cache-control 和 Expires，则Cache-control 的优先级更高，因为 Expires 设置的是服务器的时间，可能会和客户端时间不一致，导致缓存出错。<br>其他常见配置项：</p><ul><li>no-cache：每次使用缓存前都先向服务端验证，若服务端表示资源仍可用，则使用缓存</li><li>no-store：禁止浏览器缓存数据，每次请求资源都会向服务器发送请求，并重新下载完整资源</li><li>public：可被所有用户缓存，包括终端用户和 CDN 等中间代理服务器</li><li>private：只能被终端用户的浏览器缓存</li></ul><p>具体参考<a href="https://zhuanlan.zhihu.com/p/55623075" target="_blank" rel="noopener">这篇文章</a>，解释的特别清楚。</p><h3 id="浏览器组装一个-HTTP-请求报文"><a href="#浏览器组装一个-HTTP-请求报文" class="headerlink" title="浏览器组装一个 HTTP 请求报文"></a>浏览器组装一个 HTTP 请求报文</h3><p>一个 HTTP 请求报文包含了请求行、请求头、请求体，这一步浏览器会组装一个完整的请求报文以备后续发送请求。</p><p>请求行：包含了请求方法、请求 url、http 版本。</p><p>请求头：用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。服务器会以此获取客户端信息。</p><p>常见请求头：</p><ul><li>Accept：告诉服务器，客户端接受什么类型的响应</li><li>Cookie：通过这个请求头将 cookie 传递给服务器</li><li>Referer：表示这个请求是从哪个 URL 过来的</li><li>Cache-Control：对缓存进行控制</li><li>User-Agent：告诉服务器发起请求的应用程序名称</li><li>Host：给出接受请求的服务器的主机名和端口号</li></ul><p>请求体：传递请求数据，比如图片、视频等等。</p><h3 id="DNS-域名解析，获取-ip-地址"><a href="#DNS-域名解析，获取-ip-地址" class="headerlink" title="DNS 域名解析，获取 ip 地址"></a>DNS 域名解析，获取 ip 地址</h3><p>因为计算机更擅长处理一长串数字，而 ip 地址又不方便用户记忆和沟通，所以就诞生了域名，用户可以通过域名来访问网站，通过 DNS 服务解析为 ip 地址，最后访问到网站所在的 ip 地址。DNS 用于 TCP/IP 网络，它会将主机名和域名转换为 ip 地址。</p><p>浏览器获取 ip 地址会有以下过程，若查找到则不会再执行后面的几步：</p><ul><li>从浏览器中检查缓存</li></ul><p>在 chrome 中可以通过 chrome://net-internals/#dns 查看各域名的 DNS 缓存信息，默认每个域名缓存 60 s。<br>在 firefox 中可以通过 about:config 查看 DNS 的缓存数量及缓存时间，默认每个域名缓存 60 s。<br>注：DNS 记录会有一个 TTL 值（记录最大有效期，单位：s），os 缓存会参考此值，但是不完全等于此值，而浏览器 DNS 缓存的时间和此值无关，每种浏览器都使用了一个固定值。（<a href="https://dyn.com/blog/web-browser-dns-caching-bad-thing/" target="_blank" rel="noopener">参考此文章</a>）</p><ul><li>从系统中检查缓存</li><li>检查本地的 hosts 文件是否有这个网址的映射关系</li><li>路由器缓存</li><li>ISP（电信运营商） DNS 缓存</li><li>DNS 递归查询</li></ul><p>本地 DNS 一般是指电脑上网时 IPv4 或 IPv6 设置中填写的 DNS，这个可以手动指定也可以由 DHCP 自动分配。如果电脑是直连运营商网络的，一般默认情况下 DNS 为 DHCP 分配到的运营商的服务器地址，若电脑和运营商之间还加了路由器，则它分配给下面电脑的 DNS 地址就是它自身，一般是 192.168.1.1，并且很有可能路由器本身还内置了一个 DNS 转发器，它会将发往它所有的 DNS 请求转发到上层 ISP 的 DNS。</p><p>在设置路由器的时候一般都会在 WAN 口设置中看到一个选项：手动设置 DNS 服务器，当我们未设置 DNS 服务器时，访问网络的情况如下（未转发）：</p><center><br>    <img src="/assets/performance/1.png" width="50%"><br></center><p>而当我们设置了本地网络供应商提供的 DNS 地址，则可以最大限度提升电脑与网络的交换速度，提高网络访问速度（转发）：</p><center><br>    <img src="/assets/performance/2.jpeg" width="50%"><br></center><p>DNS 服务器查询过程：</p><ol><li><p>主机向本地域名服务器递归查询：主机所询问的本地域名服务器若不知道被查询域名的 ip 地址，它就会以客户的身份，向其他根域名服务器继续发出查询请求，主机不用管后续过程，只会接收最终结果。</p></li><li><p>本地域名服务器向根域名服务器迭代查询:当本地域名服务器向根域名服务器查询时，根域名服务器若查询到了具体的 ip 地址则会直接给出，若未查询到则会告诉本地域名服务器下一步要去哪个域名服务器下进行查询，让本地域名服务器进行后续的查询。（全球 DNS 根服务器只有 13 台）</p></li></ol><p>这个过程，主机就相当于是老板，而本地域名服务器是秘书，老板只需要接收最终的结果，秘书则负责和部门同事 A 沟通，若沟通无果则和部门同事 B 沟通，直到问出结果，再将结果告诉老板。</p><center><br>    <img src="/assets/performance/3.png" width="40%"><br></center><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p>HTTP 基于 TCP 协议，浏览器需要在三次握手后才能捎带 HTTP 请求报文，达到真正的建立连接。</p><p>TCP 三次握手图示：</p><center><br>    <img src="/assets/performance/5.png" width="40%"><br></center><ul><li>ACK 标志位：标志确认号 ack 是否有效，当 ACK = 1 时，确认号有效。</li><li>SYN 标志位：连接建立时用于同步序号。SYN = 1，ACK = 0 表示是一个连接请求报文段，如同意连接，则在响应报文段中使 SYN = 1，ACK = 1，握手完成后会被重新置为0。</li><li>序列号 seq：标记数据段的顺序，TCP 把连接中发送的所有数据字节都编上序号，发送给另一端。这个序号主要是用来保证有序的，当 A 向 B 发送一个数据包的时候，seq 会叠加，每一个传输方在传送数据时都会带上这个信息，另一端按照这个序号来排序收到信息的顺序，从而保证信息的传递是有序的，也可以确认有没有丢包的情况。</li><li>确认号 ack：确认号是另一端对对方 seq 的一个回应，一般会把对方给的 seq + 1 然后下一次发包的时候带上，这样对方就知道我们是收到了前面的消息的。</li></ul><p>这个过程就是这样的：客户端向服务端发起请求，携带了一个 SYN 标志位，服务端收到请求后携带一个 SYN 和一个 ACK 回复客户端，表示收到了请求，客户端再携带 ACK 回复服务端好的并建立连接。</p><p>为什么要是 3 次握手？</p><p>3 次握手可以确保数据已经被客户端接收到，若是 2 次，则服务端不知道是否有没有将数据成功传给客户端。<a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">这里写的很详细</a>。</p><h3 id="SSL-连接"><a href="#SSL-连接" class="headerlink" title="SSL 连接"></a>SSL 连接</h3><p>若使用的 HTTPS 协议就需要建立 SSL 连接。</p><h3 id="服务器检查缓存"><a href="#服务器检查缓存" class="headerlink" title="服务器检查缓存"></a>服务器检查缓存</h3><p>HTTP 请求发送成功后服务器会检查缓存：</p><p>Last-Modified：HTTP 1.0 中提供，浏览器第一次发起请求时，服务器会在 Last-Modified 响应头中携带文件最后更新的时间（服务器时间），而后浏览器再次发起请求时，就会在 If-Mofified-Since 请求头中将之前 Last-Modified 中的时间传递给服务器，服务器检查缓存后发生若文件没有更新，则直接返回一个 304 的响应头，减少响应数据量，提高响应速度。</p><p>ETag：HTTP 1.1 中新增，它是文件的一个唯一标识符，只要文件发生改变，这个标识就会发生改变。服务器会将比对 If-None-Match 请求头，若文件没有更新，也直接返回一个 304 响应头。若同时有 Last-Modified 和 ETag，则 ETag 的优先级更高，因为在一些特殊的情况下 Last-Modified 可能会缓存出错：服务器时钟出错，服务器时钟进行了修改，在本地打开了缓存文件，但并没有进行修改，又或者在不可感知的时间内对文件进行了修改（Last-Modify 只能以 s 计时）。</p><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><p>处理程序接收请求并做处理，比如一些数据库增删查改操作，然后将响应报文通过 tcp 连接发送回浏览器。</p><h3 id="浏览器接收-HTTP-响应"><a href="#浏览器接收-HTTP-响应" class="headerlink" title="浏览器接收 HTTP 响应"></a>浏览器接收 HTTP 响应</h3><p>在 HTTP 1.0 中使用的是短连接，每次请求都会使用新的 TCP 连接，而在 HTTP 1.1 中使用的是长连接，当并发请求时最多会创建 6 个 TCP 连接，之后的请求就需要等待前面的请求完成才能开始（在 HTTP 1.0 和  HTTP 1.1 中浏览器在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数的请求会被阻塞，在 chrome 中这个限制数是 6 个），而在 HTTP 2.0 中则新增了多路复用，基于二进制分层， 可以在共享 TCP 连接的基础上同时发送请求和响应。HTTP 消息被分解为独立的帧而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。</p><p>HTTP 1.1 图示：</p><center><br>    <img src="/assets/performance/4.png" width="80%"><br></center><p>现在一般默认都是 HTTP 1.1，所以浏览器接收 HTTP 响应后会根据情况来选择是否要关闭 tcp 连接，关闭 tcp 连接的话就要进行 4 次挥手。</p><p>TCP 4 次挥手图示：</p><center><br>    <img src="/assets/performance/6.png" width="40%"><br></center><p>FIN：释放一个连接，FIN = 1 表示此报文段的发送方的数据已经发送完毕，要求释放连接。</p><p>为什么挥手需要 4 次？</p><p>因为 tcp 是全双工的，即 A 在给 B 发信息的同时，B 同时也在给 A 发信息，所以当断开的时候，必须要求双方都得知道。客户端发送一个 FIN 信号给服务器端，表示想要关闭连接，服务器端收到关闭信息告诉客户端还有数据没发好，让客户端等一下，然后服务器端再发送一个信息给客户端，表示可以关闭连接了，客户端回应服务端你关闭吧，不用理我，然后进入 time_wait 状态，服务器端收到 ack 信息就关闭了，客户端在等待 2MSL 后，服务端没东西给过来就也关闭连接。</p><h3 id="浏览器检查响应状态码"><a href="#浏览器检查响应状态码" class="headerlink" title="浏览器检查响应状态码"></a>浏览器检查响应状态码</h3><p>常见状态码：</p><ul><li>200 请求成功</li><li>301 永久重定向，浏览器需要重新发送一个 HTTP 请求到服务器返回的新地址</li><li>304 请求资源并没有改变</li><li>400 错误请求，预发或参数有误</li><li>401 未授权</li><li>403 禁止，拒绝请求</li><li>404 找不到资源</li><li>405 请求方法不被允许</li><li>500 服务器内部错误</li><li>502 错误网关</li></ul><h3 id="对响应进行解码"><a href="#对响应进行解码" class="headerlink" title="对响应进行解码"></a>对响应进行解码</h3><p>若文件很大，那下载就会比较慢，特别是网速慢的时候，所以一般会对响应数据进行压缩。浏览器发送请求一般都会携带 Accept-Encoding: gzip,deflate，若服务器对响应内容进行压缩，则会在响应头中返回 Content-Encoding: gzip，浏览器接收到响应，发现响应头中包含了 Content-Encoding 就会将响应内容进行解压。</p><h3 id="资源下载、处理"><a href="#资源下载、处理" class="headerlink" title="资源下载、处理"></a>资源下载、处理</h3><p>浏览器收到响应数据，进行渲染：</p><ol><li>DOM 树构建（parse HTML）：浏览器接收到网络传输的字节数据，会将这些字节数据转换为字符串，之后再将这些字符串通过词法分析转换为标记，标记化后将这些标记转换为 node，最后这些 node 会根据不同 node 之间的联系构建为一颗 DOM 树。</li><li>构建 CSSOM 树（Recaculate Style）：这个过程其实是一个样式的重新计算，因为浏览器本身有一套内置样式表，所以最终的 CSSOM 树其实是浏览器样式和页面所有样式的重新计算。（浏览器确定节点的样式是自右向左的，比如 div span 会先找到所有的 span，再去找到 div，然后给复合条件的 span 标签设置样式，所以我们应该尽可能避免写过于具体的 CSS）</li><li>合并 DOM 树和 CSSOM 树为 Render 树：只包括渲染页面需要的节点（不包括 display: none 的节点还有 <code>&lt;head&gt; &lt;meta&gt;</code> 等节点）。</li><li>布局（Layout）：各元素尺寸、位置的计算。</li><li>绘制（Paint）：结合渲染树和布局信息绘制实际像素。</li><li>复合图层化（Composite）：渲染层合并，由于对页面中 DOM 元素的绘制是在多个层上进行的，所以在每个层绘制完后，浏览器会将所有层按照合理的顺序合并成一个图层，显示到屏幕上。图层化是浏览器为了充分利用已有的渲染成果，最小化 GPU 运算，将 “脏区” 提升为复合图层，隔离变化影响的操作（GPU 有自己的处理器和存储器及数据处理模型）。</li></ol><p>浏览器将元素提升为一个复合层有多种原因：</p><ul><li>3D 或透视变换 css 属性，如 translate3d</li><li><code>&lt;video&gt;、&lt;iframe&gt;、&lt;canvas&gt;、&lt;webgl&gt;</code> 等元素</li><li>元素自身的 opacity 和 transform 做 css 动画</li><li>使用 will-change 属性：提前告诉浏览器要变化，这样浏览器会做一些优化工作</li><li>filters</li><li>position:fixed</li><li>元素在复合层上渲染（隐式合成）</li></ul><h2 id="性能优化要点"><a href="#性能优化要点" class="headerlink" title="性能优化要点"></a>性能优化要点</h2><p>输入 URL 之后的过程其实做了很多处理，因此在这个过程中，其实可以发现很多可以优化的地方。</p><ul><li>对资源进行强缓存，若页面代码更新，则通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新的资源</li><li>域名预解析，对页面中不在同一个域的域名进行预获取，并且缓存结果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link ref=&quot;dns-prefetch&quot; href=&quot;域名&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>使用 HTTP 2.0 （HTTP 2.0 做了很多优化，比如首部压缩、多路复用、二进制分帧等）</li><li>协商缓存</li><li>启用 GZIP</li><li>将静态资源部署到 CDN 节点上，避免图片、js、css等资源文件的请求携带 cookie</li><li>减少页面请求，如：合并 css/js 文件；将背景图合并成一个文件，通过 background-image 和 background-position 来显示；行内图片使用 Data URI Scheme，它不会被浏览器缓存，但若放在 css 的 background 中，会随着 css 被一起缓存，并且它的体积是原数据体积的 4/3，在图片很小、网络受限的时候使用最好</li><li>延迟加载：对于首屏不需显示的资源可以延迟加载</li><li>css 不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染和 js 的执行，所以应尽量扁平层级，优化选择器</li><li>js 会阻塞 DOM 的解析和渲染，所以应该将 js 放在 body 底部，或者使用 defer 延迟加载，使用 async 异步执行</li><li>压缩 js、css、图片等资源</li><li>尽量避免重排（影响布局，需要重新计算每个元素的尺寸和位置）和重绘（元素更改外观但不影响布局，不影响其他元素，比如 color）：不一条条的去修改 dom 样式，尽量使用 className 一次修改；当必须要改变一个节点会导致重排的样式时，尽量让重排次数减少，可以将节点设置 dispaly: none，做完大量修改后，再让这个元素显示，或者克隆一个节点，做完修改后，再替换文档树中的节点；避免强制同步布局（在获取某个样式——比如高度之前做了样式的更改，就会导致浏览器去提前执行布局的计算，造成多次重排），应该尽量批量读取样式，然后执行样式的修改；避免布局抖动（循环读取一个样式值，然后使用此值来更新样式，造成重复重排)；动画使用 transform，而不是修改 left 或 top</li><li>不使用 table 布局，一次小改动导致整个 table 重新布局</li><li>尽量使用 flexbox，它的运行速度更快</li><li>避免隐式合成导致的额外内存占用</li><li>尽量避免使用 setTimeout 和 setInterval，而是使用 requestAnimationFrame</li></ul><p>强制同步布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 错误写法</span><br><span class="line">el.classList.add(&apos;test&apos;);</span><br><span class="line">console.log(el.offsetWidth);</span><br><span class="line"></span><br><span class="line">// 正确写法</span><br><span class="line">console.log(el.offsetWidth);</span><br><span class="line">el.classList.add(&apos;test&apos;);</span><br></pre></td></tr></table></figure><p>布局抖动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 错误写法</span><br><span class="line">for (let i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">    list[i].style.width = el.offsetWidth + &apos;px&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确写法</span><br><span class="line">let width = el.offsetWidth;</span><br><span class="line">for (let i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">    list[i].style.width = width + &apos;px&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="chrome-开发者工具"><a href="#chrome-开发者工具" class="headerlink" title="chrome 开发者工具"></a>chrome 开发者工具</h3><p><a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">附上开发者工具文档</a></p><p>network 中请求的 waterfall 列详解：</p><blockquote><p>Queueing。 浏览器在以下情况下对请求排队：</p><ul><li>存在更高优先级的请求。</li><li>此源已打开六个 TCP 连接，达到限值。 仅适用于 HTTP/1.0 和 HTTP/1.1。</li><li>浏览器正在短暂分配磁盘缓存中的空间<br>Stalled。 请求可能会因 Queueing 中描述的任何原因而停止。<br>DNS Lookup。 浏览器正在解析请求的 IP 地址。<br>Proxy negotiation。 浏览器正在与代理服务器协商请求。<br>Request sent。 正在发送请求。<br>ServiceWorker Preparation。 浏览器正在启动 Service Worker。<br>Request to ServiceWorker。 正在将请求发送到 Service Worker。<br>Waiting (TTFB)。 浏览器正在等待响应的第一个字节。 TTFB 表示 Time To First Byte（至第一字节的时间）。 此时间包括 1 次往返延迟时间及服务器准备响应所用的时间。<br>Content Download。 浏览器正在接收响应。<br>Receiving Push。 浏览器正在通过 HTTP/2 服务器推送接收此响应的数据。<br>Reading Push。 浏览器正在读取之前收到的本地数据。</li></ul></blockquote><p>Performance 面板：结合 FPS、CPU、Main等来分析页面存在什么性能问题。</p><ul><li>蓝色(Loading)：网络通信和 HTML 解析</li><li>黄色(Scripting)：JavaScript执行</li><li>紫色(Rendering)：样式计算和布局，即重排</li><li>绿色(Painting)：重绘</li><li>灰色(other)：其它事件花费的时间</li><li>白色(Idle)：空闲时间</li></ul><p>注意 FPS 中的红色区块和 Main 中事件右上角的小三角，它们都表示对应的事件可能存在性能问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器渲染网页的过程涵盖了很多内容，这其中的每一块内容都值得我们花费更多的精力深入理解。基于底层和原理的探索，能让我们更快地在工作中定位问题，找到更好更快的解决方案，节约项目团队的开发和执行成本，或许仅仅是某个微小的进步与改变，都能给团队带来不可估量的效益与价值。同时，建立在对浏览器原理的理解上，我们能更好地与运维、后端同事进行跨职业的沟通，进一步提升工作效率，也可以更容易的寻找到项目优化的突破点，提升用户体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在浏览器输入网站域名，并按下回车之后的一段时间里，其实发生了很多事情，比如协议补全、域名解析、TCP 三次握手、发送请求、页面解析等等，因此这一过程可优化的点也很多。本文旨在阐述浏览器渲染网页时的一系列过程，在对浏览器如何工作足够了解的基础上，使用调试工具来分析页面性能，借此找到阻碍浏览器性能的问题点，从而做出相应优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="chrome" scheme="https://gromimiss.github.io/tags/chrome/"/>
    
      <category term="优化" scheme="https://gromimiss.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>移动端的一些小问题</title>
    <link href="https://gromimiss.github.io/2019/04/11/autofocus/"/>
    <id>https://gromimiss.github.io/2019/04/11/autofocus/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2019-04-14T13:17:46.152Z</updated>
    
    <content type="html"><![CDATA[<p>刚接到一个需求，只是一个很简单的页面，只包含一个输入框，却遇到了挺多的问题，有些甚至还没解决，在这里记录一下。</p><a id="more"></a><p>问题：</p><ol><li>autofocus 在 ios 上有什么解决方案吗</li></ol><p>尝试了网上的一些解决方案，发现并不起作用。</p><ol start="2"><li><p>placeholder 设置不生效（在公司原生 APP 上）</p></li><li><p>因为要在 input 中有值并且聚焦状态时显示删除 icon，所以需要去判断是否聚焦</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">focus</span>=<span class="string">"focus"</span> @<span class="attr">blur</span>=<span class="string">"blur"</span> <span class="attr">autofocus</span>=<span class="string">"autofocus"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        isFocus: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    focus() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isFocus = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    blur() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isFocus = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会有一个问题：在 ios 上 autofocus 在页面上并不会产生聚焦的效果，但是会触发 focus 事件，所以它也会显示 icon。</p><p>刚开始打算用以下方式解决的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">focus</span>=<span class="string">"focus"</span> @<span class="attr">blur</span>=<span class="string">"blur"</span> <span class="attr">autofocus</span>=<span class="string">"autofocus"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        isFocus: <span class="literal">false</span>,</span><br><span class="line">        isFirstEnter: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    focus() &#123;</span><br><span class="line">        <span class="keyword">const</span> isIOS = !!navigator.userAgent.match(<span class="regexp">/(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</span><br><span class="line">        <span class="keyword">if</span> (IOS &amp;&amp; <span class="keyword">this</span>.isFirstEnter) &#123;</span><br><span class="line">            <span class="keyword">this</span>.isFirstEnter = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.isFocus = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    blur() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isFocus = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是试了之后发现 ios 在第一次用户点击触发页面上的聚焦效果时，并不会触发 focus 事件，这就导致只能通过判断系统决定是否要设置 autofocus了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">focus</span>=<span class="string">"focus"</span> @<span class="attr">blur</span>=<span class="string">"blur"</span> <span class="attr">:autofocus</span>=<span class="string">"isIOS ? 'autofocus' : undefined"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        isFocus: <span class="literal">false</span>,</span><br><span class="line">        isIOS: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.isIOS = !!navigator.userAgent.match(<span class="regexp">/(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此，就算基本的解决了这个问题，但是从根本上来讲，还是应该解决在 ios 上不 autofocus 的问题，没了这个问题也就不会有之后的一系列问题了，目前是考虑可以用 div 去模拟一个 input，这样的话样式，聚焦就都可控了，后期优化再补上。</p><ol start="4"><li>因为这个页面是在公司原生 APP 上使用的，修改之后需要返回到之前的页面，再让之前的页面的数据能够刷新，这是两个页面，返回不会刷新页面，所以也没法去触发更新数据,目前是进入修改页B前会关闭当前页A，修改完成后关闭B打开A，但是这样会有一个问题——这样是一个打开新页面的效果，而不是一个返回的效果，在移动端打开一个页面时从左到右的切换效果，而返回则是从右到左的切换效果，并且不会有刷新的问题，目前在想有没有什么两个页面间的通讯方式。</li></ol><h1 id="localStorage：因为是完全独立的两个页面，所以-localStorage-无效"><a href="#localStorage：因为是完全独立的两个页面，所以-localStorage-无效" class="headerlink" title="localStorage：因为是完全独立的两个页面，所以 localStorage 无效"></a>localStorage：因为是完全独立的两个页面，所以 localStorage 无效</h1><h1 id="window-opener"><a href="#window-opener" class="headerlink" title="window.opener"></a>window.opener</h1><h1 id="postMessage-但是是切换页面，不是两个窗口，不知道还可不可行"><a href="#postMessage-但是是切换页面，不是两个窗口，不知道还可不可行" class="headerlink" title="postMessage 但是是切换页面，不是两个窗口，不知道还可不可行"></a>postMessage 但是是切换页面，不是两个窗口，不知道还可不可行</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚接到一个需求，只是一个很简单的页面，只包含一个输入框，却遇到了挺多的问题，有些甚至还没解决，在这里记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="移动端" scheme="https://gromimiss.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>移动端——吸顶滚动</title>
    <link href="https://gromimiss.github.io/2019/04/11/h5Scroll/"/>
    <id>https://gromimiss.github.io/2019/04/11/h5Scroll/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2020-04-15T02:29:24.371Z</updated>
    
    <content type="html"><![CDATA[<p>最近接到一个需求，要求页面滚动到一定区域时，tab悬浮，换下面的区域滚动，现在记录下当时做的过程中遇到的问题。</p><a id="more"></a><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><center><br>    <img src="/assets/h5Scroll/1.png" width="40%"><br></center><center><br>    <img src="/assets/h5Scroll/2.png" width="40%"><br></center><ol><li>当滚动到一定位置时，设置内容区滚动</li></ol><p>刚看到这个需求的时候脑子里第一个想法就是来判断 scrollTop，当它大于 banner 的高度时，禁止容器滚动，设置下面的 content 区域滚动，这样子 tab 对应的两个 content 区域都有自己的滚动高度，也不需要存储滚动位置。在浏览器，短屏设备上都没问题，但是测试一下子就发现了一个问题：当滚动正好超过 banner 高度的时候，因为长屏已经显示了所有的内容，用户就会直接往上拉，这时会发现，没办法滚动了。这其实就是因为刚吸顶的那一下，容器禁止滚动了，下面的内容区也还没有触发scroll事件，就开始往上滑，以至于容器滚动和下面内容区滚动都触发不了。</p><ol start="2"><li>当滚动到一定位置时，将 tab 设为 fixed，并增加一个和 tab 相同高度的占位元素，当 tab 固定位置时，此元素显示，滚动回来时再重置。</li></ol><p>注意点1：对内容区设置 marginTop 会导致页面滚动后 scrollTop 会往后回退，猜测是引起了重新计算 scrollTop</p><p>注意点2：tab 切换时内容区的滚动条位置不变以至于滚动位置异常，所以需要去记录滚动条的位置。若在 scroll 事件中，将 scrollTop 保存会导致浏览器重新计算 scrollTop，就会出现往上回退的问题。所以要使用节流，50ms 中只触发一次保存。并且设置 scrollTop 时要记得使用 nextTick。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近接到一个需求，要求页面滚动到一定区域时，tab悬浮，换下面的区域滚动，现在记录下当时做的过程中遇到的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://gromimiss.github.io/tags/js/"/>
    
      <category term="移动端" scheme="https://gromimiss.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>记录 OAuth 机制</title>
    <link href="https://gromimiss.github.io/2019/03/29/oauth/"/>
    <id>https://gromimiss.github.io/2019/03/29/oauth/</id>
    <published>2019-03-28T16:00:00.000Z</published>
    <updated>2020-04-27T03:23:10.132Z</updated>
    
    <content type="html"><![CDATA[<p>之前在 H5 上使用过微信的网页授权，但只是按着文档中写的流程完成了一下，并没有去注意文档中写的 OAuth 机制，最近面试被提问到，所以就去了解了下，在此记录。（本文是看了阮一峰的 oAuth 2.0 记录的，<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">原文在这里</a>）。</p><a id="more"></a><h2 id="为什么使用-OAuth"><a href="#为什么使用-OAuth" class="headerlink" title="为什么使用 OAuth"></a>为什么使用 OAuth</h2><p>OAuth 可以用来解决第三方应用获取服务提供商的资源时所需的权限问题。</p><p>第三方应用获取服务提供商的资源，有以下两种方式：</p><ul><li><p>普通方式：将服务提供商上的用户名和密码告诉第三方应用，这样就会有以下几个问题：</p><ul><li>第三方应用会保存用户的密码，导致安全问题</li><li>服务供应商需要部署密码登录，但是单纯的密码登录并不安全</li><li>第三方应用拥有了获取用户存在服务供应商上所有资料的权利，但是用户并不能限制第三方应用获得授权的范围和有效期</li><li>用户只有修改密码，才能收回权利，但是若这样做，会导致其他获得了用户授权的第三方应用也都全部失效</li><li>只要其中一个第三方应用程序被破解，就会导致用户密码泄露，以及所有的资料被泄露</li></ul></li><li><p>OAuth 方式：它会通过一个授权服务器，让第三方应用安全可控的获取用户的授权，和服务提供商进行互动</p></li></ul><h2 id="OAuth-的大概思路"><a href="#OAuth-的大概思路" class="headerlink" title="OAuth 的大概思路"></a>OAuth 的大概思路</h2><p>在第三方应用和服务提供商之间设置一个授权服务器，第三方应用不能直接登录到服务提供商，而是只能登录到授权服务器，通过得到的令牌去获取服务供应商上用户的资料，并且用户可以指定授权令牌的权限范围和有效期。</p><h2 id="OAuth-的四种授权方式"><a href="#OAuth-的四种授权方式" class="headerlink" title="OAuth 的四种授权方式"></a>OAuth 的四种授权方式</h2><ul><li>授权码模式</li></ul><p>是功能最完整、流程最严密的授权模式，通过第三方应用的后台服务器与服务提供商的授权服务器进行互动。</p><p>步骤：</p><center><br>    <img src="/assets/oauth/1.png" width="80%"><br></center><ol><li><p>用户访问第三方应用</p></li><li><p>第三方应用将用户导向授权服务器</p></li><li><p>让用户选择是否授权，若用户同意授权，则授权服务器会重定向到第三方应用事先指定的重定向 uri 上，并且在 uri 的后面加上参数授权码</p></li><li><p>第三方应用收到授权码，带着应用的唯一标识、密钥、授权码以及重定向的 uri，向授权服务器申请令牌（在第三方应用的后台和服务器上完成，用户不可见）</p></li><li><p>授权服务器核对授权码和 uri，确认无误后，向第三方应用返回 access token 和 refresh token</p></li></ol><ul><li>隐式授权模式</li></ul><p>不通过第三方应用的服务器，直接在浏览器中向认证服务器申请令牌，跳过了授权码这个步骤，令牌对访问者是可见的。</p><p>步骤：</p><ol><li><p>第三方应用将用户导向授权服务器</p></li><li><p>用户选择是否给予第三方应用授权</p></li><li><p>若用户给予授权，则授权服务器会将用户导向之前第三方应用指定的重定向 uri，并在 uri 的 hash 部分包含了 access_token</p></li><li><p>浏览器向服务供应商发出请求，服务供应商返回一个网页，其中包含了可以获取 hash 值中的令牌</p></li><li><p>浏览器执行上一步获得的脚本，提取出令牌，将令牌发给客户端</p></li></ol><ul><li>密码模式</li></ul><p>用户向第三方应用提供自己的用户名和密码，第三方应用使用这些信息向服务提供商索要授权，但不能存储密码，通常在用户对第三方应用高度信任的时候使用。</p><ul><li>客户端认证模式</li></ul><p>第三方应用以自己的名义，向服务提供商进行认证，这种模式下，用户直接在第三方应用注册，第三方应用以自己的名义要求服务提供商提供服务，其实是不存在授权问题的</p><h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>若第三方应用的 access_token 过期，则要使用之前返回的 refresh_token 来重新申请一个新的 access_token。</p><h2 id="微信授权流程"><a href="#微信授权流程" class="headerlink" title="微信授权流程"></a>微信授权流程</h2><p>微信公众号就是通过 OAuth2.0 机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权 access_token），通过网页授权的 access_token 进行授权后接口调用，如获取用户基本信息。</p><p>若开发者有多个公众号，或者在公众号、移动应用之间有统一用户账号的需求，需要前往开发者平台绑定公众号后，利用 UnionID 机制来满足上述需求：开发者拥有多个移动应用、公众账号，可通过获取用户基本信息中的 UnionID 来区分用户的唯一性，因为同一用户，对同一个微信开发平台下的不同应用 unionid 是相同的。</p><p>微信授权步骤如下：</p><ol><li><p>引导用户进入授权页面同意授权，（传入 scope、redirect_url、appid、response_type、state）调用接口后会跳转到传入的 redirect_url，url 的后面会带上 code 和 state 参数</p></li><li><p>code作为换取 access_token 的票据，每次用户授权带上的 code 都不一样，只能使用一次，5分钟未使用就会自动过期，通过 code 换取网页授权 access_token 和 openid（要传入 appid、secret、code、grant_type）</p></li><li><p>若需要，可以刷新网页授权 access_token，避免过期（使用之前获取到的 refresh_token 进行刷新，它的有效期是 30 天）</p></li><li><p>通过网页授权 access_token 和 openid 获取用户基本信息（若 scope 为 snsapi_userinfo，通过传入参数 open_id 和 access_token拉取用户信息，包含了 unionid）</p></li></ol><p>scope 有两种：snsapi_base 静默授权，可以获取 openid，用户感知不到，能感知到的就是直接进入了回调页，snsapi_userinfo 是用来获取用户的基本信息的，但是这种授权需要用户手动同意，并且如果已经关注公众号的用户，如果从公众号的会话或者是自定义菜单中进入本公众号的网页授权页，即便 scope 是 snapi_userinfo 也是静默授权，用户无感知。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在 H5 上使用过微信的网页授权，但只是按着文档中写的流程完成了一下，并没有去注意文档中写的 OAuth 机制，最近面试被提问到，所以就去了解了下，在此记录。（本文是看了阮一峰的 oAuth 2.0 记录的，&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文在这里&lt;/a&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OAuth" scheme="https://gromimiss.github.io/tags/OAuth/"/>
    
      <category term="微信授权" scheme="https://gromimiss.github.io/tags/%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83/"/>
    
  </entry>
  
</feed>
