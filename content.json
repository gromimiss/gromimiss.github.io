[{"title":"Webpack 4 总结","date":"2019-03-18T16:00:00.000Z","path":"2019/03/19/webpack/","text":"以前用的 webpack 版本还是 2.6.1，现在 webpack 都更新到 4.29.6 了。最近学习了下 webpack 4，并且动手使用了下，感觉其中改变还蛮大的，就此作出一个总结。 背景为什么要使用 webpack？随着功能点的增加，浏览器本身又不提供模块管理的机制，为了简化开发的复杂度，提升开发效率，模块化、CSS 预处理器、各种框架层出不穷，并且还有 JS 的一些还没被浏览器支持的新特性，所以一整个项目里会包含着一大堆的 JS 代码和依赖包，前端项目越来越臃肿，越来越难以维护，而这个时候 webpack 出现了。 什么是 webpackwebpack 可以看做是一个模块打包机，它会分析你的项目结构，将一堆文件中的每个文件都作为一个模块，找出他们的依赖关系，将 js 模块以及其他一些浏览器不能直接运行的拓展语言（typescript、sass等），将其打包为合适的格式供浏览器来使用。 它拥有着庞大的社区，可以用来进行代码转换、文件优化、代码分割、模块合并、自动刷新、代码校验、自动发布等。 与其他工具的对比Grunt/Gulp: 都属于 Task Runner，一般用来优化前端工作流程，比如自动刷新页面、压缩 css、压缩 js、编译 sass等。它的工作方式是：在一个配置文件中，指明对某些文件进行类似编译、组合、压缩等任务的具体步骤，之后工具就会自动完成这些任务。 Webpack: 是一种模块化的解决方案，通过项目中的依赖关系产出最后的静态资源，它能拆分依赖树并按需加载，上面工具完成的工作它都可以胜任。 webpack 的使用核心概念 Entry：入口，作为 webpack 构建的第一步来找出依次的依赖关系 Module：模块，在 webpack 中一切皆模块，一个模块对应着一个文件，webpack 会通过 Entry 开始递归找出所有依赖的模块 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并及分割 Loader：模块转换器，将模块原内容按需转换成新内容 Plugin：扩展插件，在构建流程中的特定时机注入扩展逻辑来改变构建结果 Output：输出结果，在经过一系列处理并得到最终想要的代码后输出结果 Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module，每找到一个 Module，就会根据配置的 Loader 去找对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 会被分到一个 Chunk。最后 webpack 会将所有 Chunk 转换成文件输出，在整个流程中 webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 基本配置 webpack 安装 1npm i --save-dev webpack webpack-cli npx 可以直接运行 node_modules/.bin目录下面的命令通过配置 package.json 中的 script: { “build”: “webpack”} mode: 模式，有两种（production development），默认是 production entry: 打包的入口文件 单入口(只打包一个文件)： 1entry: './src/index.js' 多入口打包成多个文件： 1234entry: &#123; index: './src/index.js', base: './src/base.js'&#125; 多入口打包成一个文件： 1entry: ['./src/index.js', 'jquery'] // 相当于 entry: &#123; main: ['./src/index.js', 'jquery']&#125; output: 出口配置filename中的 name 是 entry 中对象的属性名，若 entry 是字符串或者是数组，则默认会是 main，hash 则是根据打包后的文件内容计算出来的 hash 值。 12345output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'build') // 打包后的文件的输出目录 publicPath: '' // 当资源托管到 CDN 时可使用&#125; module: 在 module 中可以配置 loader，loader 的执行顺序是从右向左，从下向上的;也可以配置 noParse，指定的包不用去解析其中的依赖关系（若这个包中没有依赖项） devServer：开发服务器的配置 123456devServer: &#123; port: 8080, // 端口号 progress: true, // 是否显示进度条 contentBase: './build', // compress: true, // 启动服务器的 gzip 压缩&#125; externals：指定某些包是外部引入的，不需要打包 devtool：增加映射文件，帮我们调试源代码 source-map：会单独生成一个 sourcemap 文件，出错了会显示当前报错的行和列 eval-source-map：不会产生单独的文件（集成到源文件中），但是可以显示行和列 cheap-module-source-map：不会显示列，会生成一个单独的映射文件，没有调试的功能，产生后可以保留起来以便之后调试 cheap-module-eval-source-map：不会产生文件，继承在打包文件中，会定位到行，不会定位到列 resolve：解析第三方包 12345678resolve: &#123; modules: [path.resolve(__dirname, 'node_modules')], // 只需要从这个目录中查找第三方包 extensions: ['.js', '.css'], // 若导入时没有添加扩展名，会根据这里的配置顺序去查找文件 alias: &#123; // 别名 bootstrap: 'bootstrap/dist/css/bootstrap.css' &#125;, mainFields: ['style', 'main'] // 先找package.json中的 style，再找 main&#125; optimization：优化 比如：多页应用可以将公共的代码抽离出来 123456789101112131415161718optimization: &#123; splitChunks: &#123; // 分割代码块 cacheGroups: &#123; // 缓存组 common: &#123; // 公共的代码 chunks: 'initial', minSize: 0, minChunks: 2 // 引入 2 次及以上就被抽离 &#125;, vendor: &#123; priority: 1, // 先抽离第三方模块 test: /node_modules/, chunks: 'initial', minSize: 0, minChunks: 2 &#125; &#125; &#125;&#125; watch: 在初始构建之后，webpack 将继续监听任何已解析文件的更改，若有更新就重新打包 12345watch: true,watchOptions: &#123; aggregateTimeout: 300, // 当第一个文件更改，会在重新构建前增加延迟，它允许 webpack 将这段时间内进行的任何其他更改都聚合到一次重新构建里 poll: 1000 // 每秒检查一次变动&#125; 常用的 loaderloader 一般都是单个 loader 负责单一的功能 expose-loader：把一个模块暴露为一个全局变量 expose-loader?$!jquery url-loader：可以在文件较小的时候，直接变成 base64 字符串内嵌到页面中（体积会比源文件大1/3，但是可以减少 http请求） 12345678910&#123; test: /\\.(png|jpg|gif|bmp|svg)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 9 * 1024, outputPath: 'images/'// 输出目录 &#125; &#125;,&#125; file-loader：解析图片地址，会将图片从原位置拷贝到目标位置并且修改原引用位置 html-withimg-loader：将 html 中引用的图片地址替换为实际的路径 1234&#123; test: /\\.html$/, use: 'html-withimg-loader'&#125; css-loader：解析 css 中的 @import/require 这种语法 sass-loader：把 sass 解析为 css style-loader：将 css 插入到 html 的 head 中 postcss-loader：使用 PostCSS 加载和转译 CSS/SSS 文件，可以用来添加浏览器前缀（当然不止这个功能） 1234567891011121314&#123; test: /\\.css$/, use: [ 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [ require('autoprefixer') ] &#125; &#125; ]&#125; babel-loader：将 ES6 语法 转换成浏览器都支持的 ES5 1234567891011&#123; test: /\\.js$/, use: &#123; loader: 'babel-loader', exclude: /node_modules/, // 排除不需要转译的目录 options: &#123; presets: ['@babel/preset-env'], plugins: ['@babel/transform-runtime'] // 引入 babel runtime 作为一个独立模块，来避免重复引入（若不使用，babel 会自动对每个文件 runtime 注入） &#125; &#125;&#125; @babel/core: 核心 api @babel/preset-flow: 删除静态类型注释 @babel/cli: 允许你从终端使用 babel @babel/preset-env: 将 ES6+ 转换为 ES5，默认转换语法，不转换新的 API @babel/polyfill: 会污染全局环境，在不支持某些 API 的浏览器中添加全局函数，比如像 Array.from 或 Object.assign，它是需要在源代码之前运行的 polyfill，下载时要 –save，可以配合 useBuiltIns 选项，当它设置为 usage 时，Babel 将检查你的所有代码，以查找目标环境中缺少的功能，并仅包含所需的 polyfill @babel/runtime: 只包含 helpers，要和 @babel/plugin-transform-runtime 一起用，它不会在每个用到某个特性的文件中都使用指定的函数，而是会引入 helpers 库中的函数 eslint-loader: 校验 js 代码 vue-loader: 解析 vue 文件，将其中的 script、style、template提取出来，交给对应的 loader 去处理（它会根据 lang 特性以及你 webpack 配置中的规则自动腿短出要使用的 loader） 常用的 plugin html-webpack-plugin: 自动产出 html 文件，配置了 title，则可以在模板文件的 title 标签中添加 &lt;%= htmlWebpackPlugin.options.title %&gt; 1234567891011new HtmlWebpackPlugin(&#123; template: './src/index.html', // 模板文件 filename: 'index.html', // 产出 html 的文件名称 title: 'hello world', // html 中 title 标签存放的标题 hash: true, // 资源文件后会加一串 hash 值，若引入的资源文件有更新，则会重新加载，而不是熊缓存中取 chunks: ['index', 'vendor'], // 在产出的 html 中引入的代码块 minify: &#123; // 对 html 做压缩处理 removeAttributeQuotes: true, // 删除属性的双引号 collapseWhitespace: true // 一行显示 &#125;&#125;) mini-css-extract-plugin: 将 css 抽离出来输出到一个文件中，若要抽离成多个可以多 new 几个（原来都是用 extract-text-webpack-plugin，但如今这个插件和 webpack 4 不太兼容） 12345678910111213141516module: &#123; rules: [ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader' ] &#125; ]&#125;,plugins: [ new MiniCssExtractPlugin(&#123; filename: 'index.css' &#125;)] optimize-css-assets-webpack-plugin：压缩 CSS 12345optimizations: &#123; minimizer: [ new OptimizeCss() ]&#125; uglifyjs-webpack-plugin: 压缩 js 123456789optimizations: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, // 是否使用缓存 paraller: true, // 是否并发打包 sourceMap: true // 是否添加映射文件 &#125;) ]&#125; webpack.ProvidePlugin: 在每个模块中注入一个变量 123new webpack.ProvidePlugin(&#123; $: 'jquery'&#125;) clean-webpack-plugin：在打包之前删除原先打包的文件 123new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns: path.resolve(__dirname, 'build')&#125;) copy-webpack-plugin: 将某文件夹复制一份到打包目录下 1234new CopyWebpackPlugin([&#123; from: './doc', to: './doc'&#125;]) webpack.BannerPlugin: 在打包后的 js 文件中添加版权声明 1new webpack.BannerPlugin('hello') webpack.DefinePlugin: 定义全局变量 123new webpack.DefinePlugin(&#123; DEV: JSON.stringify('production')&#125;) webpack.DLLPlugin: 抽离第三方库（比较稳定、不会轻易改变），这样在浏览器中就只会在第一次加载，之后都会缓存，它只需要初构建的时候打包一次(经测试速度快了 2 倍多，但就是两个地方不好：一是需要自己手动在模板文件中引入第三方库，二则是若第三方包有更新，还要自己手动再去执行第三方库的打包，有时候可能会忘记)，而 commons-chunk-plugin 主要用来提取公共包，它每次构建都会重新打包，就会增加编译时间（现使用 splitChunks） 在另一个打包配置文件下： 1234567891011121314entry: &#123; vendor: ['vue', 'vuex', 'vue-router']&#125;,output: &#123; filename: '_dll_[name].js', path: path.resolve(__dirname, 'build'), library: '_dll_[name]' // 产生的变量名&#125;,plugins: [ new webpack.DLLplugin(&#123; name: '_dll_[name]', // name === library path: path.resolve(__dirname, 'build', 'manifest.json') // 输出的清单目录 &#125;)] 在主打包配置文件中引入打包出来的第三方库： 123new webpack.DLLReferencePlugin(&#123; // 先去清单中找变量，找不到再去真正打包 manifest: path.resolve(__dirname, 'build', 'manifest.json')&#125;) happypack：可以实现多线程打包(项目大的时候可以使用，项目小的时候可能打包时间反而会更久，因为分配线程的过程中也会浪费一些性能) 1234567891011121314151617181920module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: 'Happypack/loader?id=js' &#125; ]&#125;new Happypack(&#123; id: 'js', use: [&#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' ] &#125; &#125;]&#125;) webpack.HotModuleReplacementPlugin: 热更新插件 1234devServer: &#123; hot: true&#125;,new webpack.HotModuleReplacementPlugin() scope hostingscope hosting: 作用域提升，在 webpack 3 中新增的功能，它会自动省略一些可以简化的代码 1234let a = 1;let b = 2;let c = a + b;console.log(c) // 会变成 console.log(1 + 2) 懒加载import(): 属于 es6 草案中的语法，通过 jsonp 实现动态加载，会返回一个 Promise 对象 123import('./src/index.js').then(data =&gt; &#123; console.log(data.default); // ./src/index.js' 中导出的数据&#125;) 适用于 vue 项目的优化配置将开发环境与生产环境分离： 开发时产生的debug或者是测试的代码不应出现在生产环境中 将页面部署到服务器时，会对代码进行各种优化，破坏代码可读性，不利于debug等工作 数据源差异，开发时，读取的往往是本地mock的数据 配置DllPlugin + DllReferencePlugin 和 splitChunks 可以一起使用，通过 splitChunks 把公共的部分抽离出来，DllPlugin 则抽离不易变动的第三方库，本来想尝试下在开发环境上加上 DllPlugin ，但是由于其服务使用内存来存储webpack开发环境下的打包文件，找不到另外打包出来的第三方库，并且开发环境上本来也是热更新的，所以就不再加了。 先创建一个基础的配置文件 webpack.base.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const path = require('path');const resolveCur = function(...p) &#123; return path.resolve(__dirname, ...p);&#125;;const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = function() &#123; return &#123; resolve: &#123; modules: [resolveCur('../node_modules')], extensions: ['.js', '.vue', '.json'], alias: &#123; vue$: 'vue/dist/vue.common.js' &#125;, &#125;, resolveLoader: &#123; modules: [resolveCur('../node_modules')] &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, use: 'vue-loader' &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, use: [ &#123; loader: 'babel-loader' &#125;, &#123; loader: 'eslint-loader', options: &#123; ignorePattern: eslintIgnore, // 不需要检验的正则匹配 formatter: require('eslint-friendly-formatter'), useEslintrc: false, parser: 'babel-eslint', parserOptions: &#123; sourceType: 'module' &#125;, env: ['browser'], plugins: [ 'html' ], rules: eslintRules // rules 配置文件 &#125; &#125; ] &#125;, &#123; test: /\\.html$/, use: 'html-withimg-loader' &#125;, &#123; test: /\\.(png|jpe?g|gif|bmp|svg)(\\?.*)?$/, use: &#123; loader: 'url-loader', options: &#123; limit: 9 * 1024, outputPath: 'images/[name].[hash:7].[ext]' &#125; &#125; &#125;, &#123; test: /\\.(woff2|eot|ttf|otf)(\\?.*)?$/, use: &#123; loader: 'url-loader', options: &#123; limit: 9 * 1024, outputPath: 'fonts/[name].[hash:7].[ext]' &#125; &#125; &#125; ] &#125;, plugins: [ new VueLoaderPlugin(), // 会将你定义过的其它规则复制并应用到 .vue 文件里相应语言的块 ] &#125;;&#125;; 创建开发环境的配置文件 webpack.dev.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const merge = require('webpack-merge');const webpack = require('webpack');const path = require('path');const baseWebpackConfig = require('./webpack.base')();const HtmlWebpackPlugin = require('html-webpack-plugin');const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin');module.exports = merge(baseWebpackConfig, &#123; mode: 'development', entry: &#123; app: [ 'webpack-hot-middleware/client?reload=true&amp;quiet=true', path.resolve(__dirname, '../src/dev/index.js') ] &#125;, output: &#123; filename: 'js/[name].js', path: path.resolve(__dirname, '../dist'), publicPath: '/' &#125;, devtool: 'source-map', optimization: &#123; noEmitOnErrors: true, //在编译出现错误时跳过输出阶段,确保输出资源不会包含错误 &#125;, module: &#123; rules: [ &#123; test: /\\.scss$/, use: [ 'vue-style-loader', 'css-loader', 'postcss-loader', // 会从样式文件所在目录慢慢往上找，直到根目录 'sass-loader' ] &#125;, &#123; test: /\\.css$/, use: [ 'vue-style-loader', 'css-loader', 'postcss-loader' ] &#125;, ] &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; template: 'template.html', filename: 'index.html', // 产出 html 的文件名称 &#125;), new FriendlyErrorsPlugin() ]&#125;); 创建起服务的文件 dev-server.js 123456789101112131415161718192021222324252627282930313233343536373839404142require('./check-version')();const ora = require('ora');const Koa = require('koa');const app = new Koa();const staticMiddleware = require('koa-static');const webpackMiddleware = require('koa-webpack');const historyFallback = require('koa2-history-api-fallback');const webpackConfig = require('./webpack.dev');const webpack = require('webpack');const compiler = webpack(webpackConfig);const path = require('path');const staticPath = path.posix.join(process.cwd(), webpackConfig.output.publicPath); app.use(staticMiddleware(staticPath));app.use(historyFallback());const webpackMiddlewareInstance = webpackMiddleware(&#123; compiler, hot: &#123; log: false &#125;, dev: &#123; quiet: true, publicPath: webpackConfig.output.publicPath &#125;&#125;);app.use(webpackMiddlewareInstance);const spinner = new ora('等待 webpack 打包完成...');spinner.start();let port = 8080;app.listen(port).on('error', err =&gt; &#123; if (err.code === 'EADDRINUSE') &#123; port += 1; app.listen(port); &#125;&#125;);webpackMiddlewareInstance.dev.waitUntilValid(() =&gt; &#123; spinner.stop(); const url = `http://localhost:$&#123;port&#125;`; require('opn')(url);&#125;); 创建 vendor 的配置文件 webpack.vendor.js 1234567891011121314151617181920const webpack = require('webpack');const path = require('path');module.exports = &#123; entry: &#123; vendor: ['vue/dist/vue.common.js', 'vue-router'] &#125;, output: &#123; filename: '_dll_[name].js', path: path.resolve(__dirname, '../dist'), library: '_dll_[name]' // 产生的变量名 &#125;, plugins: [ new webpack.DllPlugin(&#123; name: '_dll_[name]', // name === library context: __dirname, path: path.resolve(__dirname, '../dist', 'manifest.json') // 输出的清单目录 &#125;) ] &#125;; 创建生产环境的配置文件 webpack.prod.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const merge = require('webpack-merge');const webpack = require('webpack');const path = require('path');const baseWebpackConfig = require('./webpack.base')();const HtmlWebpackPlugin = require('html-webpack-plugin');const UglifyJsPlugin = require('uglifyjs-webpack-plugin');const OptimizeCssPlugin = require('optimize-css-assets-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = merge(baseWebpackConfig, &#123; mode: 'production', entry: &#123; app: path.resolve(__dirname, '../src/dev/index.js') &#125;, output: &#123; path: path.resolve(__dirname, '../dist'), filename: 'js/[name].[chunkhash:8].js' // hash：每次重新编译都会变化 chunkhash：内容不变就不会 &#125;, optimization: &#123; splitChunks: &#123; cacheGroups: &#123; common: &#123; chunks: 'initial', minSize: 0, minChunks: 2 &#125;, vendor: &#123; priority: 1, // 先抽离第三方模块 test: /node_modules/, chunks: 'initial', minSize: 0, minChunks: 1 &#125; &#125; &#125;, minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true &#125;), new OptimizeCssPlugin() ] &#125;, module: &#123; rules: [ &#123; test: /\\.scss$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', // 会从样式文件所在目录慢慢往上找，直到根目录 'sass-loader' ] &#125;, &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader' ] &#125;, ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'template.html', filename: 'index.html', minify: &#123; removeComments: true, removeEmptyAttributes: true, removeAttributeQuotes: true, collapseWhitespace: true &#125; &#125;), new webpack.DllReferencePlugin(&#123; manifest: path.resolve(__dirname, '../dist', 'manifest.json'), context: __dirname &#125;), new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns: ['**/*', '!_dll_vendor.js', '!manifest.json'] &#125;), new MiniCssExtractPlugin(&#123; filename: 'css/[name].[chunkhash:8].css' &#125;), ]&#125;); 遇到的问题 在这里遇到了个问题，一直报错，解析不了 jsx，一开始还以为是 babel 版本的问题，结果后来发现把项目中的 babel 相关降到原来的样子也还是报错，仔细一看是因为 babel-loader 中的规则增加了 jsx 的缘故，只包含 js，问题就没有了（我觉得应该是因为 vue-loader 中会解析 vue 文件，将相应的模块交给适合的 loader 去解析，而 vue 文件中的 render 函数部分就交给了 jsx，但是并没有相关的插件能去解析它，所以就报错了） exports is not defined 去查了下看到说是因为在 .babelrc 中的 modules: false 阻止了 babel 进行模块转化，于是去掉之后发现还是报错，没法把 commonjs 解析成功，也试过 babel-plugin-transform-commonjs 插件，但是会报新的错误：Duplicate export ‘default’，好像是因为我项目里也用了 ES6 Module，所以导致重复编译？最后决定将那几个使用了 commonjs 的代码都变成 ES6 的，问题就解决了 使用 DllPlugin + DllReferencePlugin 时碰到一个问题：最后打包时还是将依赖打包了进去，之后发现我在项目中用的是 vue.common.js，但是第三方库中 vendor 引用 vue 会自动引入 vue 中的 vue.runtime.esm.js，所以导致第三方还是被一起打包在了里面，所以要在配置文件中添加上 vue/dist/vue.common.js clean-webpack-plugin：建议可以自己写一个删除某个目录下的文件，这个的匹配规则实在是，试了好几种，都没办法把某个目录下的文件都保留，得把文件放到 dist 打包根目录下，再排除，不知道正确的匹配规则是什么，呼~ 总结webpack 4 中改动还是挺大的，也导致了挺多插件不能用了，所以在插件的使用上可能会碰到很多问题，需要花上挺多的时间，若之后又使用上再补充。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"https://gromimiss.github.io/tags/webpack/"},{"name":"打包","slug":"打包","permalink":"https://gromimiss.github.io/tags/打包/"}]},{"title":"记对 Vue 中 nextTick 的理解及总结","date":"2019-03-15T16:00:00.000Z","path":"2019/03/16/next-tick/","text":"前段时间面试被问到对 nextTick 的理解，虽说之前有看过源码，但是一来内容多，看的较浅，二来时间过去挺久了，脑海中只模糊记得用了 setTimeout。说到底，还是理解不够深，所以这次决定整理一下，把它彻底搞明白！ 基础介绍nextTick: 在下次 DOM 更新循环结束之后执行延迟回调。 最近又看了下更新的源码，发现 MutationObserver 又被使用上了，MessageChannel 被移除了(捂脸)。先简单介绍下 nextTick 中用到的一些 api以及事件循环的概念，知道了这些才能更好的理解 nextTick。 PromisePromise：用于表示一个异步操作的最终状态，以及该异步操作的结果值。可以解决回调函数的异步执行和嵌套问题。它接受一个带 resolve函数和 reject 函数两个参数的函数，有三种状态： pending、 fulfilled、 rejected。 resolve 会将对象的状态从 pending 变为 fulfilled，异步操作成功时调用，并将异步操作的结果，作为参数传递出去。 reject 会将对象的状态从 pending 变为 rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 但它也有一些缺点： 一旦新建就会立即执行，无法中途取消 若不设置回调，内部抛出的错误不会反应到外部 当处于 pending 状态时无法得知目前进展到哪个阶段 兼容性见这里。 MutationObserverMutationObserver：监听页面中 DOM 元素的变化。它和事件很接近，但本质上不同，事件是同步触发，一有变动就立刻触发相应事件，而 MutationObserver 则是异步触发， DOM 的变动会等到当前所有 DOM 操作都结束才触发。 特点如下： 等待所有脚本任务完成后，才会运行 当有多个 DOM 操作时，会把 DOM 变动记录封装成一个数组进行处理（只会触发一次回调，回调中会将变动记录作为参数传进来） 可以观察 DOM 的所有类型变动 123456789var outer = document.querySelector('outer');new MutationObserver(function(mutations, observer) &#123; console.log(mutations);&#125;).observe(outer, &#123; attributes: true&#125;);// 只会触发一次outer.setAttribute('data-random', Math.random());outer.setAttribute('data-random', Math.random()); 很强大，但是它也有挺严重的兼容性问题，并且在 ie11 中也存在 bug，兼容性看这里。 setImmediatesetImmediate：将一些需要长时间运行的操作放在一个回调函数里面，在浏览器完成后面的其他语句后，立刻执行这个回调函数。它只在 IE 上支持，兼容性看这里。 事件循环JS 是一种单线程语言，所有任务都在一个线程上完成，这样一旦遇到大量任务或者是一个耗时的任务，网页就会出现“假死”。那为什么js不能实现多线程呢 —— 作为浏览器脚本语言，若多线程的话，一个线程添加 DOM，一个线程删除 DOM，浏览器就不好判断了。而单线程就意味着所有的任务都需要排队，前一个任务执行完，才会执行后一个任务，若前一个任务耗时很长，后面的任务都会一直等着，直到前一个任务完成。并且有时并不是因为计算量大，CPU 忙不过来，而是因为 IO 设备很慢，所以之后就引入了事件循环的机制。 首先在主线程上排队执行任务，而任务队列由异步任务在有了运行结果后放置的事件组成，一旦主线程中的任务执行完，就会读取任务队列，对应的异步任务在结束等待状态之后进入主线程，开始执行。每次主线程空了就会去读取任务队列。任务队列是一个先进先出的数据结构，排在前面的事件优先读取。 具体运行机制如下： 所有同步任务都在主线程上执行，形成一个执行栈 主线程外存在一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件 当执行栈中的任务完成，就会读取任务队列中的任务，依次进入执行栈执行 下一次事件循环开始 （参考了阮一峰的 eventloop） 事件队列中有两种任务源：微任务 (microtask) 和宏任务(macrotask)，当执行完同步代码后执行栈为空，会先执行微任务，执行完所有的微任务后，如有必要渲染页面，然后再执行任务队列中的宏任务，也意味着新一轮事件循环的开始。 (macro)task -&gt; microtask -&gt; 渲染 -&gt; (macro)task (macro)task：script setTimeout MessageChannel postMessage setInterval setImmediate I/O UI渲染microtask：process.nextTick promise.then MutationObserver 小总结：看了这篇文章，从第二个例子中才发现用户触发 click 和 js 调用 click 事件是不同的，js 调用 click 就导致会等到两次 click 结束，主线程才算是清空，才开始执行任务队列中的事件，这也就让两次 click 中推到任务队列的那些微任务在同一个事件循环中了，因此 MutationObserver 就只会触发一次（一个事件循环中多次 DOM 操作只会增加变动记录，而不会触发多次事件）。 源码解析了解完涉及到的知识点后，开始进入主题 —— 看 nextTick 的源码。 flushCallbacks从头往下看，先是 flushCallbacks，上代码： 12345678function flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125; 这段代码是在异步任务被执行的时候触发的回调：将 pending 状态重新设置为 false，执行回调列表，清空回调列表（为下一次异步队列做准备）。 异步的选择重点就是关于异步 api 使用的选择了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // In problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // \"force\" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true &#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]' )) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true &#125; else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; // Fallback to setImmediate. // Techinically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125; &#125; else &#123; // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 为什么要优先使用 microtask 呢？macrotask 中两个不同任务之间可能穿插着 UI 的重渲染，所以需要在 microtask 中把所有 UI 重渲染之前将需要更新的数据全部更新，这样只需要一次重渲染就可以得到最新的 DOM。microtask 中最优的选择是使用 Promise，当浏览器不支持 Promise 再降级为 Mutation Observer，要注意的是 Mutation Observer 在 IE11 中是存在 Bug 的，见 issue #6466，所以在非 IE 的时候并且支持这个 API 才会使用，若这两个microtask 都不支持，那只能退而求其次，使用 macrotask 了。macrotask 中首选是 setImmediate，它比 setTimeout 拥有更好的性能，不需要不停的做超时检测，但是它只有 IE 兼容，其次是 MessageChannel，一个MessageChannel实例对象拥有两个属性port1和port2，我们只需要将其中一个port监听message事件，另一个port通过postMessage向前一个port发送消息，这样前一个port的message事件就会被注册为macrotask，由于它也不需要做任何检测工作，所以性能也比setTimeout，最后的选择则是setTimeout。 但是这里我又想到了一个问题，既然 nextTick 是为了在数据更新后解决操作最新 DOM 的问题，那这必然就已经发生了一次重渲染，而从这里看又希望把数据更新尽量放在一起重渲染，这不是相矛盾了吗？于是我又仔细的看了下源码，发现当数据赋新的值时，通知相关依赖响应更新时，除非将 sync 设置为 true了，否则会调用 scheduler.js 中的 queueWathcer 方法，若队列中没有保存这个更新 watcher，则将更新 watcher 给保存到一个队列中，设置 nextTick(flushScheduleQueue)，当执行栈为空时才真正调用 wachter。当真正调用 watcher 时，则会触发视图的重新渲染(run() -&gt; getAndInvoke() -&gt; get() -&gt; getter() -&gt; updateComponent())，用户调用的 nextTick 只是和 flushSchedulerQueue 放在了一个回调列表中，并且 flushSchedulerQueue 会先执行，所以后面的回调能获取到更新后的 DOM。 来个例子，直观一点。 123456789this.name = 'Tom';console.log('1');setTimeout(() =&gt; &#123; console.log('2');&#125;, 0);Promise.resove().then(() =&gt; &#123;console.log('3');&#125;this.$nextTick(() =&gt; &#123; console.log('4');&#125; 这段代码的运行结果为：1 -&gt; 4 -&gt; 3 -&gt; 2。 123456789101112131415161718192021222324export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 因为 nextTick 函数一开始 pending 为 false，会执行 timerFunc，也就是说把回调放到了任务队列中，然后将 pending 设置为true，接下来的调用的 this.$nextTick 其实还是在调用 nextTick，此时 timerFunc 已经生成，它只会把传入的 cb 放到 callbacks 中，此时 callbacks 中就会有2个成员，flushSchedulerQueue 和另一个 cb，所以这里的顺序会先打印 1，再打印 4，接着执行 3 和 2。 总结 可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 在 beforeMount 生命周期后会创建一个 watcher 观察者实例，这个 watcher 中会把 updateComponent 函数传入，watcher 实例就会对 updateComponent 函数求值，而执行 updateCompontnt 函数会间接触发渲染函数(vm.$options.render)的执行，继而触发数据属性的 get 拦截器函数，从而将依赖收集。当依次有多个属性更改时，比如 this.name 修改值，就会收集渲染函数的观察者，然后又修改了 this.age，就又会收集一次渲染函数的观察者，但是因为队列中已经收集了渲染函数的观察者了，就不会再重复添加，所以最后只会触发一次重渲染。 后面添加的 this.$nextTick 会和 flushSchedulerQueue(即渲染函数观察者或者还有定义的 watch等)一起被加到回调函数中。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://gromimiss.github.io/tags/vue/"},{"name":"源码","slug":"源码","permalink":"https://gromimiss.github.io/tags/源码/"}]},{"title":"JS 中的基本类型和引用类型","date":"2019-03-14T16:00:00.000Z","path":"2019/03/15/type/","text":"JS 中包含看两种类型：基本类型（原始类型）和引用类型。本文主要来总结下这两种类型的区别以及类型转换。 介绍基本数据类型基本数据类型：按值访问，可操作保存在变量中实际的值，指的是简单的数据段。它有6种： undefined、 null、 string、 number、 boolean、 symbol( es6 中新增)。 引用类型引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。除了基本类型，其他都是引用类型，包括了：Object、 Array、 RegExp、 Date、 Function、 特殊的基本包装类型（String、 Number、Boolean）以及单体内置对象（Global、 Math）。引用类型变量存放的是地址，当创建一个对象类型的时候，计算机会在内存中开辟一个空间来存放值，我们需要通过一个地址来找到这个空间。所以当复制这个变量的时候其实复制的是存放这个对象空间的地址，当修改数据的时候，就导致了两个变量的值都发生了改变。 区别除了上面的按值访问和按址访问的区别，还有以下区别： 基本类型按值访问，引用类型按址访问 123456789101112131415161718192021// 基本类型值var a = 'a';var b = a;a = 'b';alert(b); // a//引用类型值,以数组为例// 1. 对其中一个变量直接赋值不会影响到另一个变量（并未操作引用的对象）var a = [1, 2, 3];var b = a;a = [1, 2, 3, 4]; // 重新赋值，指向的就不是原来的哪个对象了alert(a); // 1,2,3,4alert(b); // 1,2,3// 2. 使用push(操作了引用的对象)var a = [1, 2, 3];var b = a;a.push(4);alert(a); // 1,2,3,4alert(b); // 1,2,3,4 引用类型可添加属性和方法，而基本类型不可以 123456789// 为引用类型值添加属性var p = new Object();p.age = 11;alert(p.age); // 11//为基本类型值添加属性var name = 'a';name.age = 11;alert(name.age); // undefined 传递参数：当变量为基本类型时，将变量赋值作为函数的参数（局部变量），在里面对局部变量进行操作时，不会影响到函数外部的值，而若参数为引用类型时，除非在内部重写了参数，否则外部的变量和函数内局部变量会引用同一个对象，内部发生改变也会影响到外部的变量 123456789101112131415161718192021// 基本类型function add(a) &#123; a += 10; return a;&#125;var num = 10;var result = add(num);alert(num); //10alert(result); //20// 引用类型function setName(obj) &#123; obj.name = 'a'; obj = new Object(); obj.name = 'b'; return obj;&#125;var p = new Object();var p2 = setName(p);alert(p.name); // aalert(p2.name); // b typeof vs instanceoftypeoftypeof 可用于判断基本类型，除了 null，其他都可以显示正确的类型。 1234567891011121314var num = 1;var a = 'a';var b;var flag = true;var o = null;var fn = function()&#123;&#125;;var rg = /hello/;alert(typeof num); // numberalert(typeof a); // stringalert(typeof b); // undefinedalert(typeof flag); // booleanalert(typeof o); // objectalert(typeof fn); // functionalert(typeof rg); // object(sarari5、chrome7前返回function) instanceofinstanceof 可以判断一个对象的正确类型。 1234var a = [1, 2,3 ];alert(a instanceof Object); //truealert(a instanceof Array); //truealert(a instanceof RegExp); //false 但它也不是完全可信的，因为通过 Symbol.hasInstance 我们可以自定义 instanceof 的行为。 12345class PrimitiveString &#123; static [symbol.hasInstance](x) &#123; return typeof x === 'string'; &#125;&#125; 类型转换JS中的类型转换JS 中类型转换只有三种情况： 转为布尔值 转为字符串 转为数字 在转 Boolean 中，除了 null/undefined/0/-0//NaN/false/‘’，其他值都转为 true。 转换对象时，会调用内置的 [[ToPrimitive]] 函数，先调用 valueOf，若未返回基本类型，再调用 toString。 四则运算符 加法运算符 若运算中其中一方为字符串，则将另一方也转换为字符串； 若双方都不是字符串并且不是对象，运算中其中一方为数字，则将另一方也转换成数字 若双方都不是字符串，其中一方是对象，则会将对象先转换为基本类型，再通过以上2点比较 123451 + '1' // '11'true + true // 24 + [1, 2] // '41,2'&#123;&#125; + 0 // 0 &#123;&#125; 会被当做一个空代码块，所以结果不是 '[object Object]0'a + + 'b' // 'aNaN' 相当于 a 加上 + 'b' 其他运算符，只要其中一方是数字，另一方就会转成数字 比较运算符当使用 == 时的类型转换，会将两值都转成数字，见下图： 使用上图规则解析 [] == ![], !会将变量转换成 boolean 类型，所以 ![] 会转成 false, [] == false -&gt; [] == 0 -&gt; ‘’ == 0 -&gt; 0 == 0 -&gt; true 特殊问题 null 不是一个对象类型，虽然 typeof null === &#39;object&#39;，但是这只是 JS 存在的一个悠久 Bug。因为最初 JS 使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头的代表对象，而 null 表示为全零，所以就错误的判断了。 0.1 + 0.2 !== 0.3 在计算机中数字都是以多位二进制存储的，而除了那些可以表示成x / 2^n的数可以被精确表示，其余小数都是以近似值的方式存在，可以使用以下方式计算浮点数。 12345678910111213141516// 计算浮点数function addFloat(a, b) &#123; var aLen,bLen; try &#123; aLen = a.toString().split('.')[1].length; &#125; catch(e) &#123; aLen = 0; &#125; try &#123; bLen = b.toString().split('.')[1].length; &#125; catch(e) &#123; bLen = 0; &#125; var max = Math.max(aLen, bLen); return (a * max + b * max) / max;&#125;","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"记录 hexo + github pages 搭建博客过程","date":"2019-03-13T16:00:00.000Z","path":"2019/03/14/hexo/","text":"一直想搞个博客，总是被各种事情阻扰，然后继续被搁置着。现在闲了，终于决定自己动手做一个。本文主要记录使用 hexo + github pages 搭建博客的过程及遇到的一些小问题（cu xin）。 背景为什么用 hexo + github pages？hexo: 一个快速、简洁且高效的博客框架，目前拥有 288 个插件以及 246 个主题可供选择。github pages：由 github 提供的一项功能，可以创建一个专属域名来展示自己的一些项目，考虑到域名备案还是比较麻烦，所以还是选择了这个。 准备工作 确保已经下载安装了 Node 以及 git 安装 Hexo 1npm i -g hexo-cli 新建一个 github 仓库，利用这个仓库来使用 github pages功能 建立本地和远程仓库的关联 创建 ssh，id_rsa 是个人电脑上的私人密钥，id_rsa.pub 是公共密钥，将公共密钥放到 github 上，这样连接 github 账户时，就会根据公钥来匹配电脑上的私钥，相互匹配时，才能顺利通过 git 上传文件到 github 上。 可以先检查本机是否已经存在 ssh。 12cd ~/. sshls 若不存在，则创建: 12ssh-keygen -t rsa -C \"youremail\"Enter file in which to save the key # 输入用于保存生成的SSH key的文件名，按回车则使用默认的 将 id_rsa.pub 文件中的密钥复制到 github -&gt; settings -&gt; SSH and GPGkeys -&gt; New SSH key 中 验证是否关联成功（注意：这个就是 git@github.com，不要把 git 换成自己的 username），显示 hi, your username 就说明成功了 1ssh -T git@github.com 创建博客项目这里可以选择先创建一个博客文件夹，再进入到这个文件夹执行命令 hexo init，也可以在指定文件夹中 hexo init blogname，我跟着网上的教程走，也没仔细看，就跟着复制粘贴，就出现了一个问题：我先新建了一个 myblog 文件夹，然后进入到这个文件夹执行了上面的指令后初始化 hexo init myblog，直接打开了外面的myblog，没有注意到刚才的指令其实是在 myblog 里面又创建了一个 myblog，所以在外面的 myblog 文件夹中就只有三个指令 —— init，help，version，到里面的myblog才会有 generate、server 等属性（所以说还是要动动脑子，不要只去复制粘贴）。 init后会出现一个目录： 12345678.├── _config.yml # 配置文件├── package.json├── scaffolds # 模板文件夹├── source # 资源文件夹| ├── _drafts # 草稿箱| └── _posts # 发布└── themes # 主题文件夹 根据自己的需求去修改配置文件中的信息。 主题主题可以自行去 官网 寻找自己喜欢的，本人更喜欢简约一点的，所以选择了 yilia。 1git clone https://github.com/litten/hexo-theme-yilia.git 将主题下载下来后放到 themes 目录中，再将站点中 _config.yml 的 theme 属性改成新添加的主题名。 1hexo s 这样就可以看到效果了。在 themes/新添加的主题 目录下也会有个 _config.yml，在里面可以根据个人的需求来调整，具体见 这里。 要特别说一下的是，如果要使用首页只显示前几行的话可以在文章中通过 &lt;!-- more --&gt; 来自定义自己想在首页显示的内容，并且需要将主题配置文件中的 excerpt_link: more 注释掉，并且要注意的是文章中 &lt;!-- more --&gt; 上面需要有内容（注释掉的也可以），否则会发现文章又显示全部内容了。 live2d 动画已经记不得是在哪个博客中看到了 live2d，觉得很可爱，就想着也加一个。 先下载 live2d 包 1npm i --save hexo-helper-live2d 选择自己喜欢的 模型 1npm i --save live2d-widget-model-模型名 在站点的 _config.yml 中添加配置信息,将 model 改为你选择的模型包名 123456789101112131415161718192021live2d:enable: truescriptFrom: localpluginRootPath: live2dw/pluginJsPath: lib/pluginModelPath: assets/tagMode: falsedebug: falsemodel: use: live2d-widget-model-tororodisplay: position: right width: 100 height: 200 hOffset: 30 vOffset: -60mobile: show: truereact: opacityDefault: 1 opacityOnHover: 0.7 可以根据自己想要的样子去调整一些属性，如位置、透明度等，详细见 这里。 评论系统评论系统我使用了 Valine，为什么选择它 —— 好吧，我完全只是喜欢它的颜值而已。看了我使用的 yilia 主题，发现配置文件中只有多说、网易云跟帖、畅言、Disqus、Gitment这五种评论系统可以配置，就去 github 上看一下，发现在2017年的时候就新增了对 Valine 的支持，使用如下： 注册 Leancloud，创建应用 在站点的 _config.yml 中增加配置信息，appId和 appKey 可以在 创建的应用 -&gt; 设置 -&gt; 应用 key 中找到。 12345678#6、Valine https://valine.js.orgvaline: appid: #Leancloud应用的appIdappkey: #Leancloud应用的appKeyverify: false #验证码notify: false #评论回复提醒avatar: mm #评论列表头像样式：''/mm/identicon/monsterid/wavatar/retro/hideplaceholder: Just go go #评论框占位符 在主题中的 layout/_partial/article.ejs 中添加代码（注意：要加在 &lt;% if (!index &amp;&amp; post.comments){ %&gt; 后 面，否则会出现首页也出现评论框的问题）。 12345678910111213&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;&lt;section id=\"comments\" class=\"comments\"&gt; &lt;style&gt; .comments&#123;margin:30px;padding:10px;background:#fff&#125; @media screen and (max-width:800px)&#123;.comments&#123;margin:auto;padding:10px;background:#fff&#125;&#125; &lt;/style&gt; &lt;%- partial('post/valine', &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt;&lt;/section&gt;&lt;% &#125; %&gt; 添加 layout/_partial/post/valine.ejs 文件，文件内容如下: 123456789101112131415161718&lt;div id=\"vcomment\" class=\"comment\"&gt;&lt;/div&gt;&lt;script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/valine/dist/Valine.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var notify = '&lt;%= theme.valine.notify %&gt;' == true ? true : false; var verify = '&lt;%= theme.valine.verify %&gt;' == true ? true : false; window.onload = function() &#123; new Valine(&#123; el: '#vcomment', notify: notify, verify: verify, app_id: \"&lt;%= theme.valine.appid %&gt;\", app_key: \"&lt;%= theme.valine.appkey %&gt;\", placeholder: \"&lt;%= theme.valine.placeholder %&gt;\", avatar:\"&lt;%= theme.valine.avatar %&gt;\" &#125;); &#125;&lt;/script&gt; 开启智能菜单中所有文章及标签的搜索 下载 hexo-generator-json-content 包 1npm i --save hexo-generator-json-content 在站点的 _config.yml 中添加配置信息 123456789101112131415161718jsonContent:meta: falsepages: falseposts:title: truedate: truepath: truetext: trueraw: falsecontent: falseslug: falseupdated: falsecomments: truelink: falsepermalink: falseexcerpt: falsecategories: falsetags: true 添加归档 在文件夹中 hexo new page archives 在主题下的 _config.yml 中添加 menu 字数/阅读时长/阅读量统计在文章标题下增加字数/阅读时长/阅读量统计这些内容。 阅读量统计阅读量统计我使用了不蒜子： 在主题下的 layout/_partial/after-footer.ejs 中最后添加代码： 1&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 在 after-footer 后面使用： 12本站总访问量 &lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; 次&amp;nbsp&amp;nbsp&amp;nbsp本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次 不过我只希望在文章中添加阅读量，所以放的位置也不一样，我会把它和字数/阅读时长一起放到头部，所以稍后在字数/阅读时长的内容中一起讲。 字数/阅读时长字数和阅读时长的统计我使用了插件 hexo-wordcount。 下载 hexo-wordcount 包 1npm i --save hexo-wordcount 在主题目录下 layout/_partial/post 中新建 word.ejs 文件，把之前的阅读量统计和字数及阅读时长的内容一起放到这个文件里(注意：首页中的每篇文章也会显示，但是那里只会统计站点访问量，所以要判断首页则不显示这些信息，暂时使用了 index 来区分是否是首页) 1234567891011121314151617181920212223242526272829&lt;% if (!index)&#123; %&gt; &lt;div style=\"margin-top:10px;font-size: 12px; color: #999;\"&gt; &lt;span class=\"post-time\"&gt; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fa fa-keyboard-o icon-acfun\" style=\"font-size: 12px;\"&gt;&lt;/i&gt; &lt;span class=\"post-meta-item-text\"&gt; 字数统计: &lt;/span&gt; &lt;span class=\"post-count\"&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;span class=\"post-time\"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fa fa-hourglass-half icon-clock\" style=\"font-size: 12px;\"&gt;&lt;/i&gt; &lt;span class=\"post-meta-item-text\"&gt; 阅读时长: &lt;/span&gt; &lt;span class=\"post-count\"&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;span class=\"post-time\"&gt; &amp;nbsp; | &amp;nbsp; &lt;i class=\"icon-book\" style=\"font-size: 12px;\"&gt;&lt;/i&gt; &lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量 &lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt; 次 &lt;/span&gt; &lt;/span&gt; &lt;/div&gt;&lt;% &#125; %&gt; 在文章中插入图片考虑到性能问题，打算把图片放到 七牛云 中，通过外链的形式插入。 注册七牛云，免费领取对象存储，新建存储空间（需要实名认证，包括支付宝、身份证等绑定，并且免费的话只能用测试域名，有效期30 天） 复制上传的图片外链，在文章中引入外链，居中设置宽度（默认的太大了） 123456&lt;center&gt; &lt;img src=\"外链地址\" width=\"80%\" /&gt;&lt;/center&gt; 添加 RSS可以使用一个插件 —— hexo-generator-feed 下载插件 1npm i --save hexo-generator-feed 在站点的 _config.yml 中添加以下代码 1234feed: type: atom path: atom.xml limit: 20 在主题下的 _config.yml 中添加以下代码 1rss: /atom.xml 部署 在站点 _config.yml 中配置部署 github 仓库信息 1234deploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master 通过指令生成页面后使用指令 hexo d 部署若发生错误：Deployer not found: Git，则说明要下载 hexo-deployer-git 1npm i --save hexo-deployer-git 结束语到这里，搭建博客就结束了，内容比较简单，就是自己想要的功能可以要自己花时间去找，还有就是 markdown 的语法一定要注意空格、tab，不要有多余的空格（之前代码块一直显示错乱，找了好久才发现 ~~~ 后面多了个空格）！！！","comments":true,"tags":[{"name":"hexo","slug":"hexo","permalink":"https://gromimiss.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://gromimiss.github.io/tags/github-pages/"}]}]