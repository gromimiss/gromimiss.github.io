[{"title":"微信小程序三方代发","date":"2021-03-12T16:00:00.000Z","path":"2021/03/13/3rdminiprogram/","text":"小程序运营者可以一键授权给第三方平台，由第三方平台来上传代码完成业务。在进行三方代发时，会涉及到很多流程，包括开发调试以及运营发布三方小程序（无需开发介入），本文旨在记录这一整套流程。 前期准备相关申请即设置 在微信公众平台申请一个小程序，然后在微信开放平台的第三方平台详情中绑定该小程序作为三方开发使用，该小程序就是模板小程序，上传该小程序，代码会被直接上传到开放平台 在第三方平台账号中配置小程序服务器域名，在三方代发前调用接口为小程序添加第三方平台的域名 申请一个小程序，用来日常开发测试 相关名词及字段 open3rd: 第三方平台，即提供三方服务的对外三方平台，是给其他客户管理小程序的平台 3rdMiniProgramAppid: 三方代发时需要一个模板小程序来提交代码分发到其他客户的小程序上，这就是模板小程序的 appid extAppid: 三方客户小程序的 appid extEnable: 是否开启本地的 ext.json，本地调试使用 ext: 服务端注入额外参数，在提交体验版前，服务端可以给不同小程序注入参数，比如使用 clientId 来区分不同的业务，这些注入的参数在小程序中可以使用 getExtConfig 来获取 extPages: 可以通过此配置设置对应 page 的配置信息（即 page.json） directCommit: 规定当前上传操作是否直接上传到三方小程序的审核列表中，设为 true 时即可支持开发者工具中执行上传操作则直接上传到对应三方小程序的审核列表，当为 false 时则直接上传到对应草稿箱，默认为 false 业务流程 客户在增值服务购买小程序服务，调用微信快速创建小程序接口，企业法人扫脸后创建小程序 云端收到创建成功通知，获取小程序原始 id 和 appid 去云端创建 clientId 映射服务 三方发布平台获取到新的未发布小程序，点击发布体验版，对小程序进行分发 客户进入商家运营中心配置小程序所需的审核材料和支付账户相关东西 确认体验版无误，对小程序正式提审 发布流程为了方便前端开发，在本地开发时可以另外创建小程序作为开发测试使用，在三方发布平台打包时再走三方代发流程。 当我们在三方发布平台（供运营使用）执行打包时，libra 会收到 mqtt 消息，进行三方打包，此时 appid 是模板小程序的 appid，三方发布平台轮询后端 mqtt 接口 libra 使用模板小程序打包完成后上传到第三方平台的草稿箱，并通知打包完成 三方发布平台收到打包完成消息，按钮变为提交体验版，选择要发布的小程序提交，将代码从草稿箱转移到模板库，注入相应的 clientId，提交代码到体验版 等待提交完成，查看发布到体验版的小程序，调用审核接口，审核通过后进行正式发布 三方代发整体流程 三方平台创建审核通过后微信服务器会向其授权事件接收 URL 每隔10分钟推送 component_verify_ticket，保存最近可用的 component_verify_ticket 可以通过上面的 component_verify_ticket 来获取令牌(component_access_token)，有效期 2 小时 通过 component_access_token 获取预授权码（pre_auth_code），有效期 1800 s 用户需要在第三方平台授权页中完成授权，授权通过后三方平台即可在回调 URL 中获取到授权码（authorization_code），通过授权码获取到授权方的 appid、authorizer_access_token、authorizer_refresh_token 等授权方相关信息 发布时先把代码上传到模板库 通过 authorizer_access_token、模板 id、ext.json（服务端在此注入相关业务参数）上传到体验版 提交审核，等待微信服务器推送审核结果 审核通过，使用 authorizer_access_token 发布正式版本 开发调试当我们需要对线上三方小程序进行调试时，可以在本地增加 ext.json，开启 extEnable 并且设置 extAppid 调试指定三方小程序。 相关文档第三方平台开发文档","comments":true,"tags":[{"name":"小程序","slug":"小程序","permalink":"https://gromimiss.github.io/tags/小程序/"}]},{"title":"React 源码解析之任务调度器 Scheduler","date":"2020-12-25T16:00:00.000Z","path":"2020/12/26/react1/","text":"Scheduler，用于完成任务调度工作。它以小顶堆的方式存放了两个队列：taskQueue 和 timerQueue。taskQueue 用于存放将被处理的任务，timerQueue 用于存放延期处理的任务。 堆在 Scheduler 中主要使用到了一种数据结构：堆。它是顺序存储的一颗完全二叉树，分为大顶堆和小顶堆。 大顶堆：arr[i] &gt;= arr[i * 2 + 1] &amp;&amp; arr[i] &gt;= arr[i * 2 + 2]，即父节点的值总是会比子节点的值大。小顶堆：arr[i] &lt;= arr[i * 2 + 1] &amp;&amp; arr[i] &lt;= arr[i * 2 + 2]，即父节点的值总是会比子节点的值小。 Scheduler 中使用堆来实现了优先队列： 类型 入队 出队 普通数组 O(1) O(n) 顺序数组 O(n) O(1) 堆 O(logn) O(logn) 就源码来看一下。 compare12345function compare(a, b) &#123; // Compare sort index first, then task id. const diff = a.sortIndex - b.sortIndex; return diff !== 0 ? diff : a.id - b.id;&#125; compare 方法，用来比较两个元素间的顺序，先通过 sortIndex，若一样则通过元素上的 id。 siftUp12345678910111213141516171819// 向上比较function siftUp(heap, node, i) &#123; let index = i; while (true) &#123; // 取父元素 const parentIndex = (index - 1) &gt;&gt;&gt; 1; const parent = heap[parentIndex]; if (parent !== undefined &amp;&amp; compare(parent, node) &gt; 0) &#123; // The parent is larger. Swap positions. heap[parentIndex] = node; heap[index] = parent; index = parentIndex; &#125; else &#123; // The parent is smaller. Exit. return; &#125; &#125;&#125; 当某节点可能与上一层节点交换就要用 siftUp。他会先取传入节点的父节点，通过 compare 方法来比较父节点和传入节点的优先顺序： 若传入的值小则将传入的值放置到父节点的位置，而父节点则放到传入的位置，再将 index 更新为父节点的位置，继续向上取父节点比较，直到堆顶 若传入的值大则位置不变 siftDown12345678910111213141516171819202122232425262728293031// 向下比较function siftDown(heap, node, i) &#123; let index = i; const length = heap.length; while (index &lt; length) &#123; const leftIndex = (index + 1) * 2 - 1; const left = heap[leftIndex]; const rightIndex = leftIndex + 1; const right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those. if (left !== undefined &amp;&amp; compare(left, node) &lt; 0) &#123; if (right !== undefined &amp;&amp; compare(right, left) &lt; 0) &#123; heap[index] = right; heap[rightIndex] = node; index = rightIndex; &#125; else &#123; heap[index] = left; heap[leftIndex] = node; index = leftIndex; &#125; &#125; else if (right !== undefined &amp;&amp; compare(right, node) &lt; 0) &#123; heap[index] = right; heap[rightIndex] = node; index = rightIndex; &#125; else &#123; // Neither child is smaller. Exit. return; &#125; &#125;&#125; 当某节点可能与下一层节点交换就要用 siftDown。从指定节点开始，取出子树中的左侧节点和右侧节点。 将左侧节点和传入的值比较：左侧节点小，比较左侧节点和右侧节点。若右侧节点比左侧节点小，将右侧节点放到子树顶部，将传入的值放入到右侧节点的位置，index 更新为改动的节点位置（需要重复进行这个操作，保证右侧节点下的子树是正确的）；反之，将左侧节点放到子树顶部，将传入的值放入到左侧节点的位置 将右侧节点和传入的值比较：右侧节点小，将右侧节点放到子树顶部，将传入的值放入到右侧节点的位置 上述都不符合，位置不改动 peek、push 和 pop基础的方法看完来看下基于它们实现的方法： 1234567891011121314151617181920212223242526export function push(heap: Heap, node: Node): void &#123; const index = heap.length; heap.push(node); // 向上比较，将 node 放置在合适的位置 siftUp(heap, node, index);&#125;// 取堆顶值，即最小值export function peek(heap: Heap): Node | null &#123; const first = heap[0]; return first === undefined ? null : first;&#125;export function pop(heap: Heap): Node | null &#123; const first = heap[0]; if (first !== undefined) &#123; const last = heap.pop(); if (last !== first) &#123; heap[0] = last; siftDown(heap, last, 0); &#125; return first; &#125; else &#123; return null; &#125;&#125; push：在堆中加入一个元素，并会向上比较，放置在合适的位置 peek：取堆顶值，即最小值 pop：去除堆顶节点并将这个堆顶节点返回，将堆中最后一个元素先放置到堆顶，向下比较，将这个元素放到合适的位置 SchedulerHostConfigunstable_scheduleCallback 方法里涉及到了 getCurrentTime、requestHostCallback、requestHostTimeout 等方法，都写在 SchedulerHostConfig.default.js 中。 getCurrentTime123456789if ( typeof performance === 'object' &amp;&amp; typeof performance.now === 'function') &#123; getCurrentTime = () =&gt; performance.now();&#125; else &#123; const initialTime = Date.now(); getCurrentTime = () =&gt; Date.now() - initialTime;&#125; 若有 performace，currentTime 会取 performace.now() ，它是当前时间与 performance.timing.navigationStart(即上一个页面被 unload 的时间戳，若没有上一个页面，则与 fetchStart 值相等) 的时间差。它与 Date.now() - performance.timing.navigationStart 的区别是不受系统程序执行阻塞的影响，因此更加精准；若不支持 performance 则取 Date.now() - initialTime，即当前时间和 SchedulerHostConfig.default.js 文件加载的时间差。总之，这里就取的是在执行该方法时到某一个时间节点的间隔差。 requestHostCallback流程图如下： 12345678910111213141516171819202122232425262728293031323334353637383940const performWorkUntilDeadline = () =&gt; &#123; if (scheduledHostCallback !== null) &#123; const currentTime = getCurrentTime(); deadline = currentTime + yieldInterval; const hasTimeRemaining = true; try &#123; // 执行传入的回调 const hasMoreWork = scheduledHostCallback( hasTimeRemaining, currentTime, ); // 是否还有更多的任务，若有则继续传递 if (!hasMoreWork) &#123; isMessageLoopRunning = false; scheduledHostCallback = null; &#125; else &#123; port.postMessage(null); &#125; &#125; catch (error) &#123; port.postMessage(null); throw error; &#125; &#125; else &#123; isMessageLoopRunning = false; &#125; needsPaint = false;&#125;;const channel = new MessageChannel();const port = channel.port2;channel.port1.onmessage = performWorkUntilDeadline;requestHostCallback = function(callback) &#123; scheduledHostCallback = callback; if (!isMessageLoopRunning) &#123; // 标识消息传递中 isMessageLoopRunning = true; port.postMessage(null); &#125;&#125;; 当存在 window 对象并且有 MessageChannel，那么 requestHostCallback 会使用 MessageChannel 来建立起一个通道，通过 port.postMessage(null) 来发送消息，channel.port1.onmessage 接受信息，并立即开始执行任务队列中的任务，类似一个发布订阅。 123456789101112131415161718192021222324const _flushCallback = function() &#123; if (_callback !== null) &#123; try &#123; const currentTime = getCurrentTime(); const hasRemainingTime = true; _callback(hasRemainingTime, currentTime); _callback = null; &#125; catch (e) &#123; setTimeout(_flushCallback, 0); throw e; &#125; &#125;&#125;;// 执行传入的 callback，执行完后置空// 若发现之前执行的还存在则递归执行 requestHostCallback，直到 callback 为 nullrequestHostCallback = function(cb) &#123; if (_callback !== null) &#123; setTimeout(requestHostCallback, 0, cb); &#125; else &#123; _callback = cb; setTimeout(_flushCallback, 0); &#125;&#125;; 而当不存在上面对象的话，就会使用 setTimeout 来实现。通过判断 _callback 是否存在，若不存在则会将传入的回调赋值给 _callback 并在下一个事件循环执行这个回调，重置 _callback；若 _callback 已经存在了则说明任务还在执行中，它会一直递归的查询 _callback，直到 callback 为空，再执行前面存在的流程。 requestHostTimeout设置一个定时器，在传入的指定 ms 之后触发。 12345requestHostTimeout = function(callback, ms) &#123; taskTimeoutID = setTimeout(() =&gt; &#123; callback(getCurrentTime()); &#125;, ms);&#125;; shouldYieldToHostReact 从 Stack Reconcile 转变为了 Fiber Reconcile，使用协作式多任务处理，将原来整个虚拟 DOM 的更新任务拆分成一个个小的任务，当有更高优先级的任务进入：比如绘制或者用户输入，就可以让出资源来让它们优先执行。这里放弃了 requestAnimationFrame 和 requestIdleCallback api 构成的帧对齐策略，人为的控制调度频率，提升任务处理速度，优化 React 运行时性能。相较之下，requestAnimationFrame 更依赖于显示器的刷新频率，而为了在每帧执行尽可能多的任务，采用了默认 5ms 间隔的消息事件来发起调度，通过高频调用 postMessage 来调用任务。不过它的风险是会更频繁的调度任务，加剧主线程与其他浏览器任务资源的争夺。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 默认 5mslet yieldInterval = 5;let deadline = 0;// 最大 300msconst maxYieldInterval = 300;let needsPaint = false;// 浏览器是否支持 navigator.scheduling，目前就 chrome 87 以上支持if ( enableIsInputPending &amp;&amp; navigator !== undefined &amp;&amp; navigator.scheduling !== undefined &amp;&amp; navigator.scheduling.isInputPending !== undefined) &#123; const scheduling = navigator.scheduling; // 是否要让出资源给别的任务 shouldYieldToHost = function() &#123; const currentTime = getCurrentTime(); if (currentTime &gt;= deadline) &#123; // 若需要渲染或者正在用户输入中则让出资源 if (needsPaint || scheduling.isInputPending()) &#123; return true; &#125; // 是否超过最大让出时间间隔 return currentTime &gt;= maxYieldInterval; &#125; else &#123; return false; &#125; &#125;; requestPaint = function() &#123; needsPaint = true; &#125;;&#125; else &#123; shouldYieldToHost = function() &#123; return getCurrentTime() &gt;= deadline; &#125;; requestPaint = function() &#123;&#125;;&#125;// 提供给开发者的公共 api：允许开发者根据不同设备刷新率设置调度策略forceFrameRate = function(fps) &#123; if (fps &lt; 0 || fps &gt; 125) &#123; console['error']( 'forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported', ); return; &#125; if (fps &gt; 0) &#123; yieldInterval = Math.floor(1000 / fps); &#125; else &#123; yieldInterval = 5; &#125;&#125;; 核心回到 Scheduler 的核心代码，先上一张流程图： 在这里 scheduler profiling 记录 task event 相关的代码我会先隐藏掉，主要看主流程代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function unstable_scheduleCallback(priorityLevel, callback, options) &#123; // 获取当前执行该方法时到 js 加载的时间 var currentTime = getCurrentTime(); var startTime; var timeout; if (typeof options === 'object' &amp;&amp; options !== null) &#123; var delay = options.delay; // 延迟开始 if (typeof delay === 'number' &amp;&amp; delay &gt; 0) &#123; startTime = currentTime + delay; &#125; else &#123; // 立刻开始 startTime = currentTime; &#125; // timeoutForPriorityLevel:通过优先等级获取 timeout 时间 // 当浏览器一直在执行任务可能导致当前任务被一直挂起，可以设置超时时间，在该时间内，该任务会被优先放入浏览为的执行队列 timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel); &#125; else &#123; timeout = timeoutForPriorityLevel(priorityLevel); startTime = currentTime; &#125; // 算出过期时间 var expirationTime = startTime + timeout; var newTask = &#123; id: taskIdCounter++, callback, priorityLevel, startTime, expirationTime, sortIndex: -1, &#125;; // 这里其实就是设置一个定时器：从延迟队列里取任务可执行的任务执行 if (startTime &gt; currentTime) &#123; // This is a delayed task. newTask.sortIndex = startTime; // 放到延迟队列里 push(timerQueue, newTask); // 任务队列里面没有任务，并且是延迟队列里的第一个就是当前任务 if (peek(taskQueue) === null &amp;&amp; newTask === peek(timerQueue)) &#123; // 若之前已经在执行延迟任务调度则取消之前的定时器，否则则设置 isHostTimeoutScheduled 标识 if (isHostTimeoutScheduled) &#123; cancelHostTimeout(); &#125; else &#123; isHostTimeoutScheduled = true; &#125; // 执行一个定时器 requestHostTimeout(handleTimeout, startTime - currentTime); &#125; &#125; else &#123; // 这里是执行任务队列里的任务 newTask.sortIndex = expirationTime; push(taskQueue, newTask); if (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) &#123; isHostCallbackScheduled = true; requestHostCallback(flushWork); &#125; &#125; return newTask;&#125; 每个任务节点都会有以下几个属性： id：任务节点的序号，创建任务时自增 1 callback：真正要执行的任务 priorityLevel：任务优先级，按 ImmediatePriority、UserBlockingPriority、NormalPriority、LowPriority、IdlePriority 的顺序依次降低 startTime：任务预期开始的时间，默认为当前时间，可通过 options.delay 设置为延时任务。只有 startTime 小于或等于 currentTime 的情况下才会被加入到 taskQueue 中 expirationTime：过期时间，scheduler 基于该值来判断任务是否要开始进行调度。通过 options.timeout 设定或 priorityLevel 计算 timeout 值后将 timeout 与 startTime 相加就得到了 expirationTime sortIndex：默认值为 -1。timerQueue 中，该值是 startTime，而 taskQueue 中该值是 expirationTime 它会先计算出 startTime 和 expirationTime 的值，创建一个具有以上属性的任务节点，通过对比startTime 和 currentTime 来决定要将任务放到哪个队列中，并执行不同的操作。 advanceTimers12345678910111213141516171819// 取出延迟队列中可开始执行的任务放入到任务队列中function advanceTimers(currentTime) &#123; // 取出堆中最优先的延迟任务 let timer = peek(timerQueue); while (timer !== null) &#123; // 若没有任务回调则直接移除这次任务 if (timer.callback === null) &#123; pop(timerQueue); &#125; else if (timer.startTime &lt;= currentTime) &#123; // 将任务从延迟队列中移除，存到任务队列中，按过期时间排序 pop(timerQueue); timer.sortIndex = timer.expirationTime; push(taskQueue, timer); &#125; else &#123; return; &#125; timer = peek(timerQueue); &#125;&#125; 先看下 advanceTimers，它会取出堆中最优先的延迟任务，也就是说从堆顶开始，以优先级依次执行，移除没有回调的任务，若任务的 startTime 已经小于或等于当前时间了，则说明可以开始执行了，就会将这个任务推到任务队列里并从延迟队列里移除。总的来说，它做的就是处理延迟队列里的任务，将没有回调的任务过滤掉，把可以开始执行的任务依次推到任务队列中，等待执行。 handleTimeout1234567891011121314151617181920// 执行从延迟队列中取出的可开始执行的任务function handleTimeout(currentTime) &#123; isHostTimeoutScheduled = false; advanceTimers(currentTime); // 当前没有在执行的任务则执行任务 if (!isHostCallbackScheduled) &#123; if (peek(taskQueue) !== null) &#123; isHostCallbackScheduled = true; requestHostCallback(flushWork); &#125; else &#123; // 若任务队列中没有任务，则取出延迟队列中的最优先任务，以最优先任务的开始时间到执行此方法时的时间为间隔时间 // 到那个时候再执行 handleTimeout，延迟任务又会被放到任务队列里被执行 const firstTimer = peek(timerQueue); if (firstTimer !== null) &#123; requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime); &#125; &#125; &#125;&#125; 当调用 advanceTimers 处理出了可执行的任务之后，若当前没有在执行的任务并且任务队列里有任务那么就执行任务；否则若延迟队列里还有任务则继续递归执行 handleTimeout。 flushWork这里真正在执行的其实就是 workLoop。它会以 workLoop 的方式循环调度 taskQueue 队列或调用 handleTimeout 来递归调度 timerQueue 队列。这两种方式中只会有一个在激活状态。当 taskQueue 队列调度完毕，会调用 requestHostTimeout 处理 timerQueue 队列；timerQueue 队列有任务进入 taskQueue，又会调用 requestHostCallback 处理 taskQueue 队列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// hasTimeRemaining 目前看传入的都是 truefunction flushWork(hasTimeRemaining, initialTime) &#123; // 重置是否有在执行的任务的标识 isHostCallbackScheduled = false; // 清除这个定时器 if (isHostTimeoutScheduled) &#123; isHostTimeoutScheduled = false; cancelHostTimeout(); &#125; // 执行任务的标识 isPerformingWork = true; const previousPriorityLevel = currentPriorityLevel; try &#123; if (enableProfiling) &#123; //... &#125; else &#123; return workLoop(hasTimeRemaining, initialTime); &#125; &#125; finally &#123; // 重置相关变量 currentTask = null; currentPriorityLevel = previousPriorityLevel; isPerformingWork = false; &#125;&#125;function workLoop(hasTimeRemaining, initialTime) &#123; let currentTime = initialTime; advanceTimers(currentTime); currentTask = peek(taskQueue); while ( currentTask !== null &amp;&amp; !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused) ) &#123; // 任务还没有到过期时间，直接跳出循环(取出了最优先的任务，其过期时间还是比当前时间要大，那其他任务肯定更大，所以直接跳出) if ( currentTask.expirationTime &gt; currentTime &amp;&amp; (!hasTimeRemaining || shouldYieldToHost()) // 达到任务的最大运行时长，让出主线程 ) &#123; break; &#125; const callback = currentTask.callback; if (callback !== null) &#123; currentTask.callback = null; currentPriorityLevel = currentTask.priorityLevel; // 相当于 true const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime; markTaskRun(currentTask, currentTime); // 执行回调 const continuationCallback = callback(didUserCallbackTimeout); currentTime = getCurrentTime(); // 回调如果返回了一个函数则继续给当前任务的 callback 属性，否则从任务队列中移除该任务 if (typeof continuationCallback === 'function') &#123; currentTask.callback = continuationCallback; &#125; else &#123; if (currentTask === peek(taskQueue)) &#123; pop(taskQueue); &#125; &#125; // 继续查延迟队列里是否有任务要加入到任务队列里 advanceTimers(currentTime); &#125; else &#123; // 若 callback 没有则直接移除该任务 pop(taskQueue); &#125; // 再取堆顶，依次执行任务，直到执行完了所有到了过期时间的任务 currentTask = peek(taskQueue); &#125; // 这里代表还有没执行的任务，即过期时间还没到的任务，则返回 true，否则继续创建一个延迟监听，返回 false if (currentTask !== null) &#123; return true; &#125; else &#123; const firstTimer = peek(timerQueue); if (firstTimer !== null) &#123; requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime); &#125; return false; &#125;&#125; 具体看下，workLoop 中会先通过 advanceTimer 整理出可执行的任务队列。从堆顶任务开始处理，遇到还没到过期时间的任务会直接跳出循环，因为任务队列的数据结构是以堆的方式，它会先取出最优先的任务，这里优先级就是按 expirationTime 来计算的，expirationTime 小的会被排在前面。当该任务过期时间比当前时间要大，那排在其后面的其他任务的过期时间肯定更大，所以直接跳出循环，等待之后执行。若是到了过期时间的任务则会取出其 callback 执行，若 callback 返回的还是函数，会继续将返回的函数赋值给 currentTask，并且不会移除该任务，当继续通过 peek 取堆顶任务的时候取出的还会是该任务，直到 callback 不再返回一个函数，才会去将该任务移除，继续取剩下的优先任务，重复上面的操作。若剩余还有未执行的任务(过期时间还没到的任务)，则继续通过 handleTimeout 来取出可执行的任务执行或继续进行下一次监听。 总结Scheduler 里面其实就是将传入的 callback 封装成一个 task，按优先级及传入的 options 来决定任务的执行顺序及执行时间。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"源码","slug":"源码","permalink":"https://gromimiss.github.io/tags/源码/"},{"name":"react","slug":"react","permalink":"https://gromimiss.github.io/tags/react/"}]},{"title":"支付","date":"2020-11-04T16:00:00.000Z","path":"2020/11/05/pay/","text":"在做电商项目中会涉及到很多的支付方式，每个支付方式的对接都有些许不同，这里记录下各大支付方式的对接流程。 微信支付流程 用户 h5 页下单 创建订单 调用微信支付接口下单 下单接口返回支付相关参数 mweb_url 跳转 mweb_url，并且可在 url 后携带参数 redirect_url 中间页进行 h5 权限校验 完成支付及取消支付都会跳转到 redirect_url（未配置则回到支付发起页） 引导用户主动发起支付结果查询，后端判断是否接收到微信侧的支付结果通知，若没有，后台调用订单查询接口确认状态 展示订单支付结果 实现微信支付需要在微信支付后台配置授权域名。 调用后端接口，后端向微信发起下单请求后会返回支付相关参数，前端再通过返回的 mweb_url 调起微信支付的中间页，呼起收银台，支付完成后会返回到前端在 mweb_url 后面拼接的 redirect_url 参数。 安卓: 微信回调地址由前端控制 ios: 同上，ios 端支付完成一样不会跳回客户端，只是微信会打开 safari。所以需要做处理: 回调页面需要是一个中转页面，判断若是自己的 app 环境，就跳正常链接，若是 safari 则通过 scheme 打开 app（微信打开 safari 的同时，app 里的第三方支付会自己判断支付完成，并已经跳到回调页，所以我们在 safari 中只需要做的是: 返回 app）。 123456789101112// 中间页const url = isInApp ? `$&#123;window.location.origin&#125;/orderPaySuccess?orderId=$&#123;orderId&#125;` : `$&#123;scheme&#125;://`;location.href = url;const getRediectUrl = async (selectedPay, params) =&gt; &#123; const &#123;isIOS &#125; = judgeDevice(); const host = window.location.origin; let extra = '?'; params &amp;&amp; Object.keys(params).forEach((key) =&gt; extra += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`)); return selectedPay === 'wechat_pay' &amp;&amp; isIOS ? `$&#123;host&#125;/wxIosBack$&#123;extra&#125;scheme=$&#123;scheme&#125;` : `$&#123;host&#125;/ orderPaySuccess$&#123;extra&#125;`;&#125; 支付宝支付流程 用户 h5 下单 后台通过支付接口生成订单数据 前端通过 form 表单形式请求到支付宝 支付宝自动将页面跳转至支付宝 H5 收银页 用户在支付宝 app 或 H5 收银页完成支付后，会根据在支付 api 中传入的前端会跳地址 return_url 自动跳转回 h5 实现调用后端接口，后端通过支付接口生成订单数据，前端再以 form 表单的形式请求到支付宝，将生成的订单数据除了 bizContent 以外都编码后拼接在返回的 api 地址后，bizContent 通过隐藏域发送，表单提交请求到支付宝，支付宝跳转到支付宝 h5 收银页（若用户安装了支付宝 app 则唤起支付宝），用户在完成支付后会根据支付 api 中传入的 return_url 跳转到我们的页面，并在 url 中带上支付结果参数。 安卓: 支付宝的回调地址一般配置在服务端，比如: https://xxx.com/orderPaySuccess?orderId=xxx，支付 api 带上的支付结果参数则会被拼接在回调地址后 ios: 同上，只是支付完成后不会自动跳回 app，需要手动切换 stripe 支付流程 用户 h5 下单 跳转 stripe checkout 页 用户支付成功后跳转至配置的 successUrl 实现点击支付从接口中获取到 publicKey 和 sessionId，重定向到 stripe checkout 页，用户支付成功后跳转到配置的 success_url 页，success_url 和 cancel_url 前后端都可以控制。 12345const &#123; publicKey, sessionId &#125; = res.extendMap; // 从接口中获取const stripe = window.Stripe(publicKey);stripe.redirectToCheckout(&#123; sessionId&#125;); paypal 支付流程 用户点击 paypal 生成的按钮在 h5 下单 弹出 paypal 弹窗 支付成功后由前端这边做一个支付成功的跳转 实现通过嵌入 paypal 的按钮，点击按钮时会呼起 paypal 支付弹窗进行支付，通过 approve 验证是否成功，并且做一个成功的跳转。 安卓: 由 approve 验证函数控制（即前端传入） ios: 同上 123456789101112131415161718192021222324paypal.Button.render(&#123; env: 'production', style: &#123; label: 'paypal', size: 'large', shape: 'rect', color: 'gold', tagline: false, &#125;, payment: () =&gt; &#123; const &#123; getPaymentId, paymentId &#125; = this.props; if (paymentId) &#123; return paymentId; &#125; return getPaymentId().then((res) =&gt; res) &#125;, onAuthorize: (res) =&gt; &#123; const &#123; approve &#125; = this.props; approve(&#123; paymentId: res.paymentId, payerId: res.payerId &#125;); &#125;&#125;, '#paypal_button'); 其他 stripe 若要接入 apple pay 需要将 checkout 页在 safari 中打开或者 app 提供 SFSafariViewController 加载能力打开 checkout 页。最好是可以在 app 中打开，跳出到 safari 涉及到 APP 呼起。(apple pay 支付测试需要用海外的信用卡) stripe 接入 google pay 需要将 checkout 页在 chrome 中打开并登录 google 账号绑定有效的卡片并且下载了 google pay 才会显示。这里会有一个问题，app 打开浏览器只会让用户选择一次浏览器，若用户选择的不是 chrome 浏览器将无法显示。 paytm 支付流程 用户 h5 下单 若要呼起 Paytm APP 需要 app 提供插件支持 检测是否支持呼起 app，若不能呼起则走 h5 支付 h5 跳转 paytm checkout 页 用户支付完成后跳转至配置的 callbackUrl 实现点击支付从接口中获取到 mid、txnToken 和 orderId，重定向到 paytm checkout 页，用户支付完成后三方平台会跳转到我们配置的 callback_url，将支付状态返回给这个 url。paytm 和别的支付方式流程不太一样，它会通过 form 表单提交的方式请求我们的 callback_url。 12345678910111213141516171819202122232425262728293031323334353637const PaytmForm = (props) =&gt; &#123; const &#123; mid, txnToken, payApiAddress, orderId, &#125; = props.payInfo; const actionUrl = `$&#123;payApiAddress&#125;?mid=$&#123;mid&#125;&amp;orderId=$&#123;orderId&#125;`; return ( &lt;form id=\"pay_form\" name=\"pay_form\" method=\"POST\" action=&#123;actionUrl&#125; &gt; &lt;input type=\"hidden\" name=\"mid\" value=&#123;mid&#125; /&gt; &lt;input type=\"hidden\" name=\"txnToken\" value=&#123;txnToken&#125; /&gt; &lt;input type=\"hidden\" name=\"mid\" value=&#123;mid&#125; /&gt; &lt;/form&gt; )&#125;const paytmPay = (values) =&gt; &#123; if (!values) &#123; return; &#125; const payDiv = document.createElement('div'); ReactDom.render( &lt;PaytmForm payInfo=&#123;values&#125; /&gt;, payDiv ); document.body.appendChild(payDiv); document.forms.pay_form.submit();&#125;; paytm 需要注意的是: paytm 支付完成之后会通过 form 表单提交 post 请求，跳转到配置的 callback_url，一般情况下我们都会跳转到支付结果页，但是只是提供 get 请求的方式，所以这里需要加一个 post 请求，通过这个 url 转发到我们的页面。 1ctx.redirect(`/orderPay?$&#123;ctx.queryString&#125;`); paytm 中需要传入的 orderId 是 paytm 中的交易流水号，不是自己订单系统中的 orderId。 paytm 联调时需要 vpn，否则无法访问。 paytm h5 页在安卓 app 中需要安装 Paytm APP 才可以使用 paytm 钱包支付，ios 中可以直接显示。 注意事项由于 app 内 h5 支付会打开第三方支付页面，所以会破坏导航历史堆栈，支付完成后跳到的支付结果页直接返回会返回到第三方支付页，再次调起支付，并且支付失败，体验极差，所以要在回调地址页手动控制历史堆栈。 123456789101112131415161718const pushHistory = () =&gt; &#123; window.history.pushState( &#123; title: 'title', url: '#', &#125;, 'title', '#' );&#125;;const fixHistoryBack = () =&gt; &#123; pushState(); // 为了触发 popstate 事件 window.addEventListener('popstate', () =&gt; &#123; // 首页 -&gt; 详情页 -&gt; 下单页 -&gt; 第三方支付页 -&gt; 支付成功页 -&gt; history push const len = history.length - 2; len &gt; 1 ? history.go(-l) : history.back(); &#125;);&#125;; 总结各大支付方式的支付成功消息都是异步的，所以用户虽然支付完了，但是可能有一些特殊情况，导致并没有真正支付成功，这种情况下若不进行轮询，支付状态就会显示异常。而倘若在回调页执行轮询，微信和支付宝取消订单和支付成功的回调地址都是同一个，导致无法区分，所以统一流程应该使用微信官方提供的那一套：当用户支付完之后，无论是否完成支付，回到 h5 页时都可以弹出一个确认框，让用户选择是否已完成支付，若用户选择完成支付，则进行轮询，否则直接跳转到订单详情页。 相关文档 微信 支付宝 Stripe Paypal Paytm","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"Redux 和 Vuex 的源码解析","date":"2020-09-22T16:00:00.000Z","path":"2020/09/23/vuxAndRedux/","text":"在部分 SPA 项目中我们会使用到状态管理，方便去管理一些在多个组件下都可以使用或操作的数据。 这篇文章主要就来分析一下 Vuex 和 Redux 两个状态管理库。 ReduxRedux 更灵活可扩展，开发者可以根据自己的需求使用，不仅限于 react 项目。 重要概念 store: 通过 createStore 生成的对象，对象包含 getState、dispatch、subscrible、replaceReducer 等方法 state: 数据对象，只能通过 getState 去获取 action: 描述发生了什么的关键词 reducer: 描述 action 如何改变 state。需要是纯函数，内部的执行操作必须无副作用，不能对 state 进行直接修改而是应该返回一个全新的 state 以此来达到状态更新可预测的目的。 dispatch: 触发 state 更新 流程：dispatch action -&gt; 执行 reducer -&gt; 返回新的 state 源码分析 compose.ts 从右到左开始，后一个函数会作为前一个函数的参数。比如 compose(f1, f1, f3) =&gt; f1(f2(f3))。 1234567891011export default function compose(...funcs: Function[]) &#123; if (funcs.length === 0) &#123; return &lt;T&gt;(arg: T) =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args: any) =&gt; a(b(...args)))&#125; bindActionCreators.ts 遍历对象形式传入的 actionCreators，返回 dispatch(actionCreate) 组合成的对象。开发者可以不直接接触 dispatch 来进行 state 的更新。 12345678910111213141516171819export default function bindActionCreators( actionCreators: ActionCreator&lt;any&gt; | ActionCreatorsMapObject, dispatch: Dispatch) &#123; if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch) &#125; // ... const boundActionCreators: ActionCreatorsMapObject = &#123;&#125; for (const key in actionCreators) &#123; const actionCreator = actionCreators[key] if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; combineReducers.ts 在 redux 中 reducer 负责生成 state，并且在整个应用中只有一个 state 对象，当应用很大的时候， state 也会因此十分庞大，以至于 reducer 也十分庞大，那么 combineReducers 就是为了解决这个问题的。 在开发中我们可以对 reducer 函数进行拆分，每个小的 reducer 都可以独立负责 state 中的某一部分。combineRecuders 会接收一个 reducers 对象，这个对象的每一个 key 都对应了一个 reducer，并且这个 key 需要和 state 中的 key 保持一致，以标识使用哪个 reducer 来改变 state 的哪一部分。这里会先过滤出是函数的 reducers，得到最终可用的 reducers 对象，然后循环遍历拆分的 reducers，处理对应的 state 部分，将它又合并成一个 nextState。 通过 hasChanged 来记录前后 state 是否发生改变，若发生了改变则返回新的 nextState，否则返回原来的 state，保证了在不变的情况下仍然返回的是同一个对象。这也是之前要求 reducer 必须是纯函数的原因，combineReducers 只会对新旧 state 进行了浅比较，若直接更改旧的 state，实则引用地址没有变，将不会触发 view 层的 render。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export default function combineReducers(reducers: ReducersMapObject) &#123; const reducerKeys = Object.keys(reducers) const finalReducers: ReducersMapObject = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key \"$&#123;key&#125;\"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) // ... return function combination( state: StateFromReducersMapObject&lt;typeof reducers&gt; = &#123;&#125;, action: AnyAction ) &#123; // ... let hasChanged = false const nextState: StateFromReducersMapObject&lt;typeof reducers&gt; = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; const errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length return hasChanged ? nextState : state &#125;&#125; applyMiddleware.ts 用户可以在 createStore 中传入该方法来自定义一些功能。它提供给开发者自定义一些扩展的行为，比如说打印日志、错误校验等。当传入中间件时，它会串联的执行中间件而不影响原有的业务状态，每个中间件中都可以拿到 getState 和 dispatch 两个方法，执行所有中间件，将中间件返回的函数组成一个数组通过上面的 compose 方法，以函数柯里化的方式将多个参数转换成单一的参数，依次的去执行中间件返回的函数，最终返回一个增强后的 store 对象。 12345678910111213141516171819202122232425262728293031323334export default function applyMiddleware( ...middlewares: Middleware[]): StoreEnhancer&lt;any&gt; &#123; return (createStore: StoreEnhancerStoreCreator) =&gt; &lt;S, A extends AnyAction&gt;( reducer: Reducer&lt;S, A&gt;, preloadedState?: PreloadedState&lt;S&gt; ) =&gt; &#123; const store = createStore(reducer, preloadedState) let dispatch: Dispatch = () =&gt; &#123; throw new Error( 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.' ) &#125; const middlewareAPI: MiddlewareAPI = &#123; getState: store.getState, dispatch: (action, ...args) =&gt; dispatch(action, ...args) &#125; /** * 为什么要将 middlewareAPI 传递给每个中间件？ * 为了将 getState 和 dispatch 方法缓存在闭包中，并将这两个方法传递到每一个中间件中 * 当发生扩展更新时，由于它存在于闭包中，所有中间件都可以取到最新的 dispatch 方法 */ const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose&lt;typeof dispatch&gt;(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; createStore.ts createStore 是 redux 中最核心的一部分代码，它会创建一个带有 dispatch、subscribe、getState、replaceReducer 等方法的一个对象。它可以接收 reducer、初始化 state、以及 applyMiddleware，下面代码中的 enhancer 其实就是 applyMiddleware，它会返回增强后的 store 对象。具体看下代码： enhancer 会提供中间件扩展后的 store。 12345678910if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)( reducer, preloadedState as PreloadedState&lt;S&gt; ) as Store&lt;ExtendState&lt;S, StateExt&gt;, A, StateExt, Ext&gt; &amp; Ext&#125; subscribe: 订阅 state 的更新，调用时会被加入到 nextListeners 队列中，并返回取消订阅的方法。 12345678910111213141516171819202122232425262728293031323334353637383940function subscribe(listener: () =&gt; void) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected the listener to be a function.') &#125; if (isDispatching) &#123; throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.' ) &#125; let isSubscribed = true/** * 在每次 dispatch 之前都会保存一份 listeners 快照，这样可以保证在每次 dispatch 的时候，循环体是不会混乱的 */ ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; // 保证当前 listener 只会被取消注册一次 if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; // ... &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) currentListeners = null &#125;&#125; dispatch: 触发 state 的更新，并且依次触发订阅函数 12345678910111213141516171819202122232425262728293031323334function dispatch(action: A) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action&#125; Vuex与 Redux 不一样的是 Vuex 一般都是和 vue 搭配使用。 重要概念 state: 单一状态树 mutation: 进行状态的更改，通过 commit 触发 action: 类似于 mutation，可以包含异步操作。但是应该在里面提交 mutation，而不是直接修改 state，通过 dispatch 触发 module: 模块，每个模块都会拥有自己的 state、mutation、action、getter，避免 store 对象过于臃肿 getter: 从 state 中派生出的一些状态 流程：commit -&gt; 执行 mutation -&gt; 改变 statedispatch -&gt; 执行 action -&gt; commit -&gt; 执行 mutation -&gt; 改变 state 源码分析当我们创建根组件的时候，会把通过 new Vuex.Store({…}) 创建的 store 对象传入到根组件中。 123456Vue.use(Vuex)new Vue(&#123; el: '#app', store, // ...&#125;) Vue.use(Vuex) 会去调用 Vuex 上的 install 方法，install 方法实际上就是将根组件上的 store 对象传递给子孙组件。 12345678910111213141516171819202122232425const version = Number(Vue.version.split('.')[0])// vue 2 及以上会在每个 vue 组件上混合 beforeCreate 钩子，在这里初始化 $store 属性// 执行顺序：rootVm beforeCreate -&gt; vm beforeCreate -&gt; childVm beforeCreate -&gt; ...// 所以 vuexInit 在自身的 options 上找不到 store，就必定可以在 parent.$store 上找到// 实际上 vuex 就是通过根组件来将 $store 属性传递给一个个的子孙组件if (version &gt;= 2) &#123; Vue.mixin(&#123; beforeCreate: vuexInit &#125;)&#125; else &#123; // override init and inject vuex init procedure // for 1.x backwards compatibility. // ...&#125;function vuexInit () &#123; const options = this.$options if (options.store) &#123; this.$store = typeof options.store === 'function' ? options.store() : options.store &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; this.$store = options.parent.$store &#125;&#125; 当我们在初始化一个 store 对象的时候，会去 installModule。module 是一个树状结构，它会从根 module 开始递归的去处理每一个 module，每个 module 上会挂载一个 context 属性，这个属性上的 dispatch、commit、getters、state 都会去处理/获取当前 module 下的 state。它会将每个 module 下的 mutations、actions、getters 以 [‘namespaceA/namespaceB/key’] 的形式为键名，分别存储在 store 的 _mutations、_actions、_wrappedGetters 属性下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function installModule (store, rootState, path, module, hot) &#123; const isRoot = !path.length const namespace = store._modules.getNamespace(path) // 将 module 存储到 _modulesNamespaceMap if (module.namespaced) &#123; if (store._modulesNamespaceMap[namespace] &amp;&amp; __DEV__) &#123; console.error(`[vuex] duplicate namespace $&#123;namespace&#125; for the namespaced module $&#123;path.join('/')&#125;`) &#125; store._modulesNamespaceMap[namespace] = module &#125; // 传入的 state 会覆盖原有的 state if (!isRoot &amp;&amp; !hot) &#123; const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] store._withCommit(() =&gt; &#123; // ... Vue.set(parentState, moduleName, module.state) &#125;) &#125; // 创建一个 local 对象，它上面绑定了当前模块下处理过后的 dispatch、commit、getters、state const local = module.context = makeLocalContext(store, namespace, path) // 遍历 module 上的 mutations、getters、actions // 将它们放到 store 的 _mutations、_actions、_wrappedGetters 属性下 module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) &#125;) module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) &#125;) module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) &#125;) // 递归处理 module 下的 module module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot) &#125;)&#125; 这里还需要注意的是我们经常考虑的一点，action 和 mutation 的区别。 首先 action 肯定返回的是一个 promise，一般来说异步请求会放到 action 里，并且在 action 里还是需要使用 commit 来提交一个 mutation 来改变 state。 在 mutation 外部或者没有调用 replaceState 方法来改变 state 在 strict 的情况下会抛错。 1234567891011121314151617181920212223242526/** * 默认 _commiting 为 false * 当通过 store 上的 replaceState 及 commit 改变 state 时都会将 commiting 设置为 true，以此来区分是在内部改变还是外部改变 * 在 mutation 外部改变 state 时则报错 */_withCommit (fn) &#123; const committing = this._committing this._committing = true fn() this._committing = committing&#125;replaceState (state) &#123; this._withCommit(() =&gt; &#123; this._vm._data.$$state = state &#125;)&#125;function enableStrictMode (store) &#123; store._vm.$watch(function () &#123; return this._data.$$state &#125;, () =&gt; &#123; if (__DEV__) &#123; assert(store._committing, `do not mutate vuex store state outside mutation handlers.`) &#125; &#125;, &#123; deep: true, sync: true &#125;)&#125; 可以发现 commit 方法及 replaceState 方法在改变 state 的时候都会在外面包一个 _withCommit 方法，以此来区分是否是内部改变。 并且执行 commit 除了会去执行 mutation 来更新 state，也会依次执行注册的订阅者函数，dispatch 除了会去执行 action 还会依次执行 action 订阅者函数。 区别redux 可以和别的框架搭配着使用，但是 vuex 只能和 vue 搭配使用，不过 vuex 中会有贴合 vue 的更多特性，比如像计算属性一样的 getters。redux 在 react 中使用还需要用到 react-redux，它会通过 connect 生成容器组件（将 state 映射到组件的 props；将用户对 UI 组件的操作映射成 action），在根组件外包裹 Provider，将 createStore 创建的 store 由 Provider 组件提供到子组件。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"Webpack 的打包原理","date":"2020-05-05T16:00:00.000Z","path":"2020/05/06/webpack2/","text":"在之前一篇 webpack 的文章中我曾记录过 Webpack 的打包配置。这篇文章则用来记录 Webpack 大概做了什么。 构建流程 从配置文件和 shell 语句中读取合并参数，得到最终的参数 创建 Compiler 对象，传入上述参数，执行 compiler.run() 开始编译 根据配置中的 entry 找到所有的入口文件 从入口文件出发，调用所有配置的 loader 对相应模块进行递归处理，得到每个模块被处理后的内容以及依赖的关系 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk 确定输出内容后，根据 output 配置确定输出的路径和文件名，把文件内容写入文件系统 在以上过程中，webpack 会在特定时间广播出特定的事件，插件在监听到感兴趣的事件后执行相应的逻辑，使用 webpack 提供的 api 改变 webpack 的运行结果。 webpack 做了什么？通过 webpack 编译后的代码来看下，webpack 究竟做了什么。 编译前的代码： show.js 123export function show(content) &#123; document.getElementById('app').innerText = `hello, $&#123;content&#125;`;&#125; main.js 12const &#123; show &#125; = require('./show');show('webpack'); 编译后: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/******/ (function(modules) &#123; // 这里传入所有的模块文件，模块以路径作为键名，一个函数做为键值，函数内会 eval 模块的 code/******/ // 缓存注册的模块/******/ var installedModules = &#123;&#125;;/******//******/ // 浏览器是不支持 commonjs 的，所以需要定义一个 require 方法/******/ function __webpack_require__(moduleId) &#123;/******//******/ // 检查被引入的模块是否已经被注册，若已被注册则直接导出/******/ if(installedModules[moduleId]) &#123;/******/ return installedModules[moduleId].exports;/******/ &#125;/******/ // 否则创建一个新的模块/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId, // 模块 id，即模块路径/******/ l: false, // 模块是否已经加载完/******/ exports: &#123;&#125; // 导出/******/ &#125;;/******//******/ // 执行指定模块的代码，this 指向一个空对象/******/ // 调用的函数接受3个参数: // module: 当前模块 // module.exports: 当前模块导出内容，在模块中导出自己，让别的模块可以使用 // __webpack_require__: require 方法（供模块代码中使用，可以在模块中继续导入子模块）/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/ // 标识模块已被加载/******/ module.l = true;/******//******/ // 返回模块的导出/******/ return module.exports;/******/ &#125;/******//******//******/ // 暴露传入的模块/******/ __webpack_require__.m = modules;/******//******/ // 暴露所有被注册的模块/******/ __webpack_require__.c = installedModules;/******//******/ // 为导出的某个属性定义 getter 函数/******/ __webpack_require__.d = function(exports, name, getter) &#123;/******/ if(!__webpack_require__.o(exports, name)) &#123;/******/ Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;);/******/ &#125;/******/ &#125;;/******//******/ // 在 exports 上定义 __esModule 属性，并且为 exports 设置 Module 类型/******/ __webpack_require__.r = function(exports) &#123; /** * Symbol.toStringTag 用来表示自定义对象的类型标签 * class CustomClass &#123; * get [Symbol.toStringTag]() &#123; * return \"CustomClass\"; * &#125; * &#125; * Object.prototype.toString.call(CustomClass) // [object CustomClass] **//******/ if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123;/******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;);/******/ &#125;/******/ Object.defineProperty(exports, '__esModule', &#123; value: true &#125;);/******/ &#125;;/******//******/ // create a fake namespace object/******/ // mode &amp; 1: 值是模块 id 则引入它/******/ // mode &amp; 2: 将传入 value 的属性都合并入 ns 中/******/ // mode &amp; 4: 若传入的 value 就是一个自定义的模块则直接返回/******/ // mode &amp; 8|1: behave like require/******/ __webpack_require__.t = function(value, mode) &#123;/******/ if(mode &amp; 1) value = __webpack_require__(value);/******/ if(mode &amp; 8) return value;/******/ if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value;/******/ var ns = Object.create(null);/******/ __webpack_require__.r(ns); // 在 ns 上定义 default 属性为传入的 value /******/ Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;);/******/ if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key));/******/ return ns;/******/ &#125;;/******//******/ /******/ __webpack_require__.n = function(module) &#123; // 若是自定义的模块则直接返回模块中的 default 属性，否则返回传入的模块/******/ var getter = module &amp;&amp; module.__esModule ?/******/ function getDefault() &#123; return module['default']; &#125; :/******/ function getModuleExports() &#123; return module; &#125;; // 在 getter 上定义 a 属性/******/ __webpack_require__.d(getter, 'a', getter);/******/ return getter;/******/ &#125;;/******//******/ // Object.prototype.hasOwnProperty.call/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;/******//******/ // __webpack_public_path__/******/ __webpack_require__.p = \"\";/******//******//******/ // 加载入口模块，并且返回对应的 exports/******/ return __webpack_require__(__webpack_require__.s = \"./main.js\");/******/ &#125;)/******/ (&#123;\"./src/main.js\":(function(module, __webpack_exports__, __webpack_require__) &#123;\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _show_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./show.js */ \\\"./src/show.js\\\");\\n\\nObject(_show_js__WEBPACK_IMPORTED_MODULE_0__[\\\"showContent\\\"])('webpack');\\n\\n//# sourceURL=webpack:///./src/main.js?\");&#125;),\"./src/show.js\":(function(module, __webpack_exports__, __webpack_require__) &#123;\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"showContent\\\", function() &#123; return showContent; &#125;);\\nfunction showContent(content) &#123;\\n document.body.innerText = `hello111, $&#123;content&#125;`;\\n&#125;\\n\\n//# sourceURL=webpack:///./src/show.js?\");&#125;)/******/ &#125;); webpack 打包出来的立即执行函数中会包含一个 webpack_require 函数，用来注册模块，执行模块代码，并返回相应的模块。 webpack_require.m: 所有依赖模块文件 webpack_require.c: 已被注册的模块 webpack_require.d: 在导出的模块上定义一个属性并为其设置 getter 函数 webpack_require.r: 将导出的模块定义为 Module 类型，并设置 __esModule 为 true webpack_require.t: 定义 default 属性？ webpack_require.n: ？ webpack_require.o: 传入对象上是否有某个属性 将所需模块集合作为参数传入到一个立即执行函数中，所有的模块会以路径为键名，以一个函数为键值（这个函数会直接通过 eval 来执行解析后的文件中的代码，并且会拥有三个参数，module： 当前模块对象，exports：当前模块导出的代码，webpackrequire__：注册模块的方法（会带上 sourceURL 指向文件路径））组成一个对象。立即执行函数中定义了一个 webpackrequire__ 方法来注册模块，并且执行模块代码，返回模块内容。将模块的路径作为 moduleId, l 来标识模块是否加载完了， exports 为模块导出的代码，入口文件会在立即执行函数中使用 webpack_require 导入，入口文件的代码中会继续使用 webpackrequire__ 导入依赖文件，直到不再有相关的依赖文件。 手写一个简易版 webpack Parser.js 12345678910111213141516171819202122232425262728293031323334const fs = require('fs');const path = require('path');const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const &#123; transformFromAst &#125; = require('@babel/core');const Parser = &#123; // 通过 @babel/parser 将代码解析成 ast 对象 getAst(filePath) &#123; const content = fs.readFileSync(filePath, 'utf-8'); return parser.parse(content, &#123; sourceType: 'module' &#125;); &#125;, // 通过 @babel/traverse 将 ast 中依赖的对象递归抽取出来 // dependencies 是保存了依赖引入的相对路径和文件真实路径的键值对 getDependencies(ast, filePath) &#123; const dependencies = &#123;&#125;; traverse(ast, &#123; ImportDeclaration(&#123;node&#125;) &#123; dependencies[node.source.value] = `./$&#123;path.join(path.dirname(filePath), node.source.value)&#125;`; &#125; &#125;); return dependencies; &#125;, // 通过 @babel/core 将 ast 转换为编译后的代码 getCode(ast) &#123; const &#123; code&#125; = transformFromAst(ast, null, &#123; presets: ['@babel/preset-env'] &#125;); return code; &#125;&#125;module.exports = Parser; Compiler.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const Parser = require('./Parser');const fs = require('fs');const path = require('path');class Compiler &#123; constructor(options) &#123; this.entry = options.entry; this.output = options.output; this.modules = []; &#125; build(path) &#123; const &#123; getAst, getDependencies, getCode &#125; = Parser; const ast = getAst(path); const dependencies = getDependencies(ast, path); const code = getCode(ast); return &#123; path, dependencies, code &#125; &#125; generate(graph) &#123; const outputFile = path.join(this.output.path, this.output.filename); // 生成编译后的代码 const bundle = ` (function (graph) &#123; function require(moduleId) &#123; function localeRequire(path) &#123; return require(graph[moduleId].dependencies[path]); &#125; var exports = &#123;&#125;; (function (require, exports, code) &#123; eval(code); &#125;)(localeRequire, exports, graph[moduleId].code); return exports; &#125; require('$&#123;this.entry&#125;'); &#125;)($&#123;JSON.stringify(graph)&#125;); `; //写入文件 if (!fs.existsSync(outputFile)) &#123; fs.mkdirSync(this.output.path); &#125; fs.writeFileSync(outputFile, bundle, 'utf-8'); &#125; getDependenciesGraph(dependenciesGraph = &#123;&#125;, module) &#123; dependenciesGraph[module.path] = &#123; dependencies: module.dependencies, code: module.code &#125;; return dependenciesGraph; &#125; run() &#123; const module = this.build(this.entry); console.log(module) this.modules.push(module); const dependenciesGraph = &#123;&#125;; this.modules.forEach((module) =&gt; &#123; const &#123; dependencies &#125; = module; this.getDependenciesGraph(dependenciesGraph, module); if (dependencies) &#123; for (let dependency in dependencies) &#123; const dependencyModule = this.build(dependencies[dependency]) this.modules.push(dependencyModule); this.getDependenciesGraph(dependenciesGraph, dependencyModule); &#125; &#125; &#125;); this.generate(dependenciesGraph); &#125;&#125;module.exports = Compiler; 这里要生成的代码中也有我们提供的 require 方法，require 方法里会自执行当前传入模块的代码，并且把 localeRequire 传入该立即执行函数中。localeRequire 中是对模块提供 require 方法，让模块可以通过这个方法引入其他模块。 参考文章webpack打包原理 ? 看完这篇你就懂了 !","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"https://gromimiss.github.io/tags/webpack/"},{"name":"打包","slug":"打包","permalink":"https://gromimiss.github.io/tags/打包/"}]},{"title":"Hybird APP","date":"2020-04-22T16:00:00.000Z","path":"2020/04/23/hybrid/","text":"众所周知，Native APP 虽然用户体验很好但开发及发布成本高，而 Web APP 虽然开发成本低无需安装但是用户体验没有 Native APP 那么好，并且无法调用全部硬件底层功能，受限较多。这个时候 Hybird APP 出现了，它兼具了 Native APP 的用户体验和 Web APP 的跨平台以及其他优点。 混合方案基于 WebView基于 WebView UI 的方案是现如今大多数 APP 采取的方案。它本质其实是在原生 APP 中，使用 WebView 作为容器直接承载 Web 页面，所以最核心的点在于 Native 与 H5 之间的通信。如微信的 JSSDK 就是通过 JSBridge 完成 Native 与 H5 之间的通信，从而赋予 H5 一定程度的原生能力。 基于 Native在赋予 H5 原生 API 能力的基础上，进一步通过 JSBridge 将 JS 解析成的虚拟节点数传递到 Native 并使用原生渲染。代表框架有以下三种： React Native：采用 React 的设计模式，但是 UI 渲染、动画效果、网络请求都由原生端实现。开发者编写的 JS 代码会通过 React Native 的中间层转化为原生控件和操作。 Weex：采用 Vue 设计模式，包括 JS Bridge、Render、Dom 三大部分。JSBridge 会和 JS 端实现双向通信，DOM 负责 dom 的解析、映射，最后通知 UI 线程更新，Render 则负责在 UI 线程中对 dom 实现渲染。它和 RN 一样，JS 代码中生成的 dom 最终也会由 Native 端解析。 Flutter：基于 Dart 语言，不需要 JS 引擎，最终也通过原生渲染。 通信方式JS 通知客户端弹窗拦截 alert：可以被 WebView 的 onJsAlert 监听 confirm WebView 的 onJsConfirm 监听 prompt：可以被 WebView 的 onJsPrompt 监听 当 Web 页面调用这其中的方法时，客户端就会通过监听相应的事件，拦截传入的参数，若参数符合定义的规范就解析参数，做后续的处理。上面三种方式最常用的就是 prompt，因为 alert 和 confirm 相对而言在 Js 中使用到的会更多些。 URL shema + iframeH5 端通过创建一个隐藏的 iframe，并且 src 指向我们指定的 URL，插入到文档中，触发 URL 请求，安卓和 ios 可以通过拦截跳转页 URL 请求，解析这个 scheme 协议，符合约定规则就给对应的 Native 方法去处理。android 会通过 shouldOverrideUrlLoading 方法拦截，而 ios 则通过 UIWebView 的 delegate 函数。 1234567891011121314151617181920212223242526272829303132333435363738394041(function(window) &#123; function _invoke(action, data, callback) &#123; let schema = `jack://utils/$&#123;action&#125;?a=a`; Object.keys(data).forEach((key) =&gt; &#123; schema += `&amp;$&#123;key&#125;=$&#123;data[key]&#125;`; &#125;); let callbackName = ''; if (typeof callback === 'string') &#123; callbackName = callback; &#125; else &#123; callbackName = action + Date.now(); window[callbackName] = callback; &#125; schema += `&amp;callback=$&#123;callbackName&#125;`; let iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.src = schema; document.body.appendChild(iframe); setTimeout(() =&gt; &#123; document.body.removeChild(iframe); iframe = null; &#125;); &#125; function invokeShare(data, callback) &#123; _invoke('share', data, callback); &#125; window.fsInvoke = &#123; share: invokeShare, &#125;;&#125;)(window);window.fsInvoke.share(&#123;title: 'xxx', content: 'xxx'&#125;, result =&gt; &#123; if (result.errno === 0) &#123; alert('分享成功') &#125; else &#123; // 分享失败 alert(result.message) &#125;) 缺点： url 长度有限制 创建请求需要一定的耗时，比注入 API 的方式耗时会更长 JS 上下文注入Native 获取到 JS 的环境上下文，直接在上面挂载对象或方法，使 JS 可以直接调用。 Android 使用 addJavascriptInterface() 可以在 window 上定义一个 jsbridge 对象，这个对象有一个 call 方法可以直接去调用原生的方法，但是 Android 4.2 以下有安全问题。 客户端通知 JS通过上面 JS 通知客户端的方法，会把回调放在 window 上，然后客户端就可以通过以下方法调用绑定在 window 上的函数。 loadUrl在安卓 4.4 以前没有 evaluationJavaScript API，只能通过 loadUrl 来调用 js，让某个 js 方法执行，但是无法获取该方法的返回值。 12// mWebView = new WebView(this); //即当前webview对象mWebView.loadUrl(\"javascript: 方法名('参数,需要转为字符串')\"); evaluationJavaScriptIOS 的 WKWebView（IOS 8 中引入的新组件，摆脱过去 UIWebView 内存占用量过大的问题） 和 Android 4.4 后版本的 WebView 使用这个方法来调用。 1234567//异步执行JS代码,并获取返回值mWebView.evaluateJavascript(\"javascript: 方法名('参数,需要转为字符串')\", new ValueCallback() &#123; @Override public void onReceiveValue(String value) &#123; //这里的value即为对应JS方法的返回值 &#125;&#125;); stringByEvaluatingJavaScriptFromStringIOS 的 UIWebView（IOS 8之前的版本） 使用这个方法来调用。 1234// Swiftwebview.stringByEvaluatingJavaScriptFromString(\"方法名('参数')\")// oc[webView stringByEvaluatingJavaScriptFromString:@\"方法名(参数);\"]; 实现在注入了上下文的情况下，只需要通过 postMessage 向 Native 端发送消息，Native 端执行完后执行 actionDidFinish，即执行之前存放的回调函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const DELAY_TIME = 17;const isAndriod = /andriod/.test(window.navigator.userAgent);let callbacks = &#123;&#125;;let id = 0;const initBridge = () =&gt; &#123; let bridge = isAndriod ? window.WebViewJavaScriptBridge : &#123;&#125;; bridge.send = (message, callback) =&gt; &#123; message[id] = id; callbacks[id] = (error, result) =&gt; &#123; callback(&#123;error, result&#125;); &#125; this.sendMessage(isAndriod ? JSON.stringify(message) : message); id++; &#125;; // 客户端执行方法完成后调用这个方法让 JS 执行回调 const actionDidFinish = (id, error, result) =&gt; &#123; const callback = callbacks[id]; if (typeof callback === 'function') &#123; if (!result || !result.usable) &#123; delete callbacks[id] &#125; callbak(error, result); &#125; &#125;; if (isAndriod) &#123; bridge.actionDidFinish = actionDidFinish; &#125; else &#123; window.WebViewJavascriptBridge_actionDidFinish = actionDidFinish; bridge.sendMessage = (message) =&gt; &#123; let nativeBridge = window.WebViewJavaScriptBridge; // 苹果在 WKWebView 的 js runtime 中事先注入了 window.webkit.messageHandlers.XXX.postMessage 这个方法 // 可以直接使用这个方法向 Native 传值 if (!nativeBridge &amp;&amp; window.webkit &amp;&amp; window.webkit.messageHandlers) &#123; nativeBridge = window.webkit.messageHandlers.WebViewJavaScriptBridge; &#125; if (nativeBridge) &#123; nativeBridge.postMessage(message); &#125; else &#123; // 客户端若还没有注入上下文对象，则一直超时获取，直到获取到 setTimeout(() =&gt; &#123; this.sendMessage(message); &#125;, DELAY_TIME); &#125; &#125;; &#125; return bridge;&#125;;export default initBridge(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let id = 0;let callbacks = &#123;&#125;;let jsbridge = &#123; // js 调用 native 端方法 call: function (&#123;method, args, cb&#125;) &#123; if (type cb === 'function') &#123; callbacks[id] = cb; &#125; // 安卓会通过 addJavascriptInterface 注入 _jsbridge 对象 if (window._jsbridge) &#123; window._jsbridge.call(method, args); return; &#125; prompt(`_jsbridge=$&#123;method&#125;`, arg); &#125;, // js 端注册可供客户端调用的方法 register: function (&#123;name, fn&#125;) &#123; if (!window._jsInit) &#123; window._jsInit = true; setTimeout(() =&gt; &#123; this.call('jsInit'); &#125;); &#125; window.jsFn[name] = fn; &#125;, // 回调调用 actionDidFinish: function (&#123;id, error, result&#125;) &#123; const callback = callbacks[id]; if (typeof callback === 'function') &#123; if (!result || !result.usable) &#123; delete callbacks[id] &#125; callbak(error, result); &#125; &#125;, // 客户端调用 js 注册方法 handleMessageFromNative: function (info) &#123; const args = JSON.parse(info.data); const ret = &#123; id: info.callbackId, complete: true, &#125;; const fn = window.jsFn[info.method]; if (typeof fn === 'function') &#123; ret.data = fn.apply(window.jsFn, args); this.call('returnValue', ret); &#125; &#125;&#125;;window.jsbridge = jsbridge; 参考文章 JSBridge 的原理 大前端必须了解的 Hybrid","comments":true,"tags":[{"name":"移动端","slug":"移动端","permalink":"https://gromimiss.github.io/tags/移动端/"},{"name":"hybird","slug":"hybird","permalink":"https://gromimiss.github.io/tags/hybird/"}]},{"title":"Web 中的用户认证机制","date":"2020-04-21T16:00:00.000Z","path":"2020/04/22/user-auth/","text":"HTTP 是一种无状态的协议，客户端每个发起的请求都是独立的，所以服务端并不能知道当前这个请求究竟是哪个用户发送的，为了追踪用户就有了以下的几种用户认证机制。 基于 Cookie/Session 的认证简单流程前端登录后，后端会根据用户信息生成一个 Token，并把这个 Token 和对应用户 id 保存到数据库或 Session 中，然后在 set-cookie 响应头添加上这个 token，向用户浏览器中种入该 Token，之后浏览器请求就会带上这个 Cookie，后端再根据这个 Cookie 来查询用户，验证是否过期。 虽然用这种方法是比较方便的，前端也不需要做什么处理，但是它的缺点也很明显。由于后端每次都要根据 Token 来查出用户 id，增加了数据库的查询和存储的开销，若把验证信息放到 Session 中，则增加了服务器端的存储压力。并且，使用 Cookie 的方式安全性是比较低的，它需要防止 XSS 和 CSRF 的攻击。由于在浏览器端 Cookie 也是可操作的，它可以通过 js 去读取，一旦网站没有过滤用户输入的内容，不法网站就可以通过注入代码获取到 Cookie，或者直接以用户的身份向服务端发起请求，做一些危险的操作。 XSS 和 CSRFXSSXSS，即跨站脚本攻击（cross site scripting）。它主要分为三类： 反射型 XSS：攻击者事先做好攻击链接，欺骗用户点击链接触发 XSS 代码 存储型 XSS：通过评论、发布文章等加入代码，若没有过滤或者过滤不严，那这些代码会被存储到服务器中，当有用户访问这个页面的时候就会触发代码执行 DOM 型 XSS：DOM 树中的所有节点都可以通过 js 访问或操作 CSRFCSRF，即跨站请求伪造（cross site request forgery），伪装成受信任的用户向第三方网站发送恶意请求。怎么伪造的呢？ 用户浏览并登录网站 A 网站 A 在登录验证后将 cookie 携带给浏览器，cookie 信息会在浏览器端保存一定时间 用户没有登出A的情况下，访问了恶意网站 B 恶意网站 B 携带了网站 A 的 Cookie 以用户的身份进行一些恶意请求 具体参考这里。 如何尽量避免 XSS 和 CSRF 攻击？ 过滤用户输入的内容 校验 referer 请求头 加验证码 在 form 中加上一个隐藏 input，填入服务端生成的 token，用户提交表单后会对比 token 对 cookie 设置 httpOnly，那么在浏览器中就将无法通过 js 来操作或读取 对 cookie 设置 secure，cookie 就只允许通过 HTTPS 传输，可以过滤掉一些使用 HTTP 协议的 XSS 注入 设置 same-site：用来限制第三方 Cookie，Samesite 有 3 个参数，strict、lax、none。见这里 疑问目前浏览器对于不同域的 Cookie 不是不会携带，所以将静态资源放到别的域上来防止 Cookie 的携带吗？ 这其实是两种情况：现在比如一个网站是 a.com，它将静态资源放在了 b.com，a.com 设置了 Cookie，这个时候访问 b.com/xx.js 的时候这个请求不会携带 a.com 域名下的 cookie，但如果 b.com 也设置了 Cookie，这个时候在 a.com 下访问 b.com 其实就是一个跨域请求，但是它会携带 b.com 上设置的 Cookie。也就是说每个域上的 Cookie 只会在发送给相应域的请求才会被携带，而 Samesite 是为了解决 CSRF 的问题，即只有你在 a.com 页面下访问 a.com 请求，才会携带 a.com 域名上的 cookie。 基于 JWT 的认证一个开发标准，定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。 JWT 组成：Header、Payload、Signature Header：包含 token 的类型和采用的加密算法，它会使用 Base64 编码组成 JWT 结构的第一部分 1234&#123; \"alg\": \"HS256\", \"typ\": \"JWT\"&#125; Payload 负载：存放信息，也会使用 Base64 编码组成 JWT 结构的第二部分 1234567&#123; \"iss\": \"lion\", // 签发者 \"iat\": 1441593502, // 签发时间 \"exp\": 1441593502, // 过期时间 \"aud\": \"www.wxample.com\", // 接收方 \"sub\": \"lion@163.com\" // 面向的用户&#125; Signature 签名：使用编码后的 header 和 payload 以及提供的密钥，使用 header 中指定的签名算法进行签名。（保证 JWT 没有被篡改过） 在 JWT 中不应该加入任何敏感的数据，比如密码，它适合向 web 应用传递一些非敏感的信息，常用于设计用户认证和授权系统，单点登录 JWT 使用： 前端通过表单将用户名和密码发送到后端，建议通过 SSL 加密传输 后端核对用户名和密码，将用户 id 等其他信息作为负载按头部指定的签名算法进行签名，形成 JWT 后端将 JWT 作为登录成功的返回结果返回给前端，前端保存在 localStorage 或 sessionStorage，退出登录时前端删除 JWT 前端每次请求时将 JWT 放入 HTTP header 中的 Authorization。（解决XSS和XSRF问题）。Authorization: Bearer Token 后端检查是否存在，若存在验证 JWT 的有效性 验证通过后使用 JWT 中包含的用户信息进行其他逻辑操作，返回相应结果 JWT 虽然也有 XSS 的危险，但是它相比 Cookie 的方式，将用户状态分散在了客户端中，减轻了服务端的内存压力。 基于 OAuth 的认证OAuth 主要用于第三方认证，比如我们在进入某个网站的时候底下会有第三方登录，通过一个授权服务器来获取服务提供方上的用户同意被获取的信息。具体见我另一篇文章。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"手写一个 call/apply/bind","date":"2020-04-20T16:00:00.000Z","path":"2020/04/21/bind/","text":"JS 中的 this 一般取决于函数调用的位置，现在有 3 种方法可以改变 this 的指向，今天来手写实现一下。 call/apply/bind 的区别 call：调用一个函数，并且 this 指向传入的第一个参数，后面的参数会依次传入到调用的函数中。明确参数有多少个的时候可以用 call apply：调用一个函数，并且 this 指向传入的第一个参数，第二个参数是一个数组或者一个类数组 bind：返回一个新的函数，它会将传入的第一个参数作为原函数的 this，后面的参数加上函数运行时的参数按照顺序作为原函数的参数来调用原函数 实现若第一个参数是 string/number/boolean 等这种基本类型的数据的话，就要将 this 指向其包装对象。实现这几个方法核心原理就是将函数放到传入的第一个上下文对象上，再直接调用这个上下文对象上的该函数，调完将该函数从上下文对象上删除。 call12345678910111213141516171819202122232425Function.prototype.customCall = function () &#123; // 取出上下文对象 let context = arguments[0]; // 判断上下文对象的类型，基本数据类型则指向其包装对象 if (context === null || typeof context === 'undefined') &#123; context = window; &#125; if (typeof context === 'string') &#123; context = new String(context); &#125; if (typeof context === 'number') &#123; context = new Number(context); &#125; if (typeof context === 'boolean') &#123; context = new Boolean(context); &#125; // 对对象添加 symbol 属性，避免覆盖别的属性 const fn = Symbol('fn'); context[fn] = this; const args = [...arguments].slice(1); // 执行 context 上的该函数，让 this 指向 context const result = context[fn](...args); delete context[fn]; return result;&#125;; apply123Function.prototype.customApply = function () &#123; return this.customCall(arguments[0], ...arguments[1]);&#125;; apply 实现上基本与 call 一致，只是参数的处理不同。 bind1234567891011Function.prototype.customBind = function () &#123; const context = arguments[0]; const outerArgs = [...arguments].slice(1); const _self = this; return function() &#123; return _self.apply(context, [ ...outerArgs, ...arguments, ]); &#125;;&#125;; 基于 apply 方法，返回一个可以改变 this 指向为第一个参数的函数。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"Vue-router 中的 hash 模式和 history 模式","date":"2020-04-15T16:00:00.000Z","path":"2020/04/16/vue-router/","text":"Vue-router 中的 hash 模式和 history 模式的区别是什么？它们的原理是什么？ 基础history保存着用户上网的历史记录，是 window 对象的属性，每个浏览器窗口、每个标签页乃至每个框架都有自己的 history 与特定的对象关联。 属性、api及事件 length： 保存着历史记录的数量（hash的改变也会生成一条新的历史记录） go()：在用户的历史记录中任意跳转，可以向前或前后，参数若是数值，负值是后退一个整数值，正值则是前进一个整数值，参数是字符串，则会跳转到历史记录中包含该字符串的第一个位置（可前可后，取最近） 123history.go(-1) // 后退一页history.go(1) // 前进一页history.go('test.com') // 跳转到最近的test.com页面 back()：返回上一页，和history.go(-1)等价 forward()： 前进一页，和history.go(1)等价 pushState(stateObj, title, url): 新生成一条历史记录，页面内容不刷新，方便用浏览器的后退和前进来导航（目的：让无跳转的单站点可以将它的各个状态保存为浏览器的多条历史记录，当通过历史记录重新加载站点时，站点可以直接加载到对应的状态） stateObject：状态对象，存储自定义数据的元素 title：标题，用作页面标题，目前各类浏览器都忽略它，所以目前建议设置为空字符串 url：url地址，必须和当前url同源 replaceState()：和 pushState 基本相同，区别在于此方法不会新生成历史记录，而是将当前历史记录替换掉 window.onpopstate：浏览器取出历史记录并加载时触发，pushState 及 replaceState 本身调用时是不触发 popstate 事件的，只有点击浏览器的前进、后退及调用 go、back、forward 方法才会触发。 vue-router 中的 history 模式用到的主要就是 pushState 和 replaceState 方法。 hashURL 中从 # 开始的那一部分（search 取的是 ? 后 # 前的那一部分），可以通过 window.location.hash 获取到。 属性、api及事件 window.onhashchange：hash 值更改的时候触发。 原理 区别vue-router 默认会使用 hash 模式，即使用 url 的 hash 来模拟一个完整的 url，当 url 的 hash 改变时，页面不会重新加载，兼容到IE8。它不适合推广宣传，有的 app 里面 url 不允许带有 #。 而history 模式兼容到 IE10，当设置 mode 为 history 时，若浏览器不支持 h5 history api 会自动降级为 hash 模式。由于我们的应用是一个单页客户端应用，如果后台没有正确的配置，当用户刷新页面，会返回 404，因为刷新会实实在在地去请求服务器，所以要在服务端增加一个覆盖所有情况的候选资源，若 url 匹配不到任何静态资源，则应该返回同一个 index.html 页面（app 依赖的页面）。当配置了后，服务器就不会再返回 404 错误页面了，为了避免这种情况，就需要在 vue 应用里面覆盖所有的路由情况，然后给出一个 404 页面。 这两种模式后退都会触发组件的生命周期，但是会保留原来的滚动位置。 后退不刷新，前进刷新简单的实现在开发过程中，我们 会遇到这样一个场景：当我们点击进入到一个新的页面时，希望页面是重新加载的，但是当我们返回时可以像浏览器中正常的返回一样，缓存当前页面，不需要再进入组件的一系列生命周期，重新请求数据。这次情况下可以使用以下两种方法： 使用 keep-alivekeep-alive组件第一次进入时的生命周期：beforeRouteEnter -&gt; created -&gt; mounted -&gt; activated -&gt; deactived非首次：beforeRouteEnter -&gt; activated -&gt; deactivated 在路由映射对象中：12345routes: [ // 在路由元数据配置是否要缓存，是否是返回 &#123; path: '/', name: 'home', component： Home, meta: &#123; keepAlive: true, isBack: false &#125;, &#123; path: '/detail', name: 'detail', component: Detail, meta: &#123; keepAlive: true， isBack: false &#125; ] 入口页面：1234&lt;keep-alive&gt; &lt;router-view v-if=\"$route.meta.keepAlive\"&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=\"!$route.meta.keepAlive\"&gt;&lt;/router-view&gt; 在 home 组件中：12345678910111213141516171819beforeRouteEnter(to, from, next) &#123; if (from.name = 'detail') &#123; //若是从详情页回来的，则说明是返回 to.meta.isBack = true; &#125; next();&#125;// 若被缓存 created 只有在第一次进入会执行created() &#123; this.firstEnter = true;&#125;activated() &#123; if (this.firstEnter || !this.$route.meta.isBack) &#123; //重新获取数据 &#125; // 恢复默认的isBack this.$route.meta.isBack = false; this.firstEnter = false;&#125; 若有表单页，表单页的操作会影响到上一页的数据则要刷新上一页，比如淘宝的订单列表，点击订单，操作订单后订单的状态就会改变（比如不在待收货列表了），表单页操作成功后关闭会返回到订单列表，此时详情页需要刷新下数据。（仔细想还会有很多问题，比如：希望刷新数据后还是停留在当前滚动位置上） 并且缓存过多 keep-alive 组件，因常驻内存会导致内存占用过多，需要及时销毁掉内存缓存的组件。 若直接在离开组件的时候通过 $destory() 销毁组件会出现一个问题：再次进入此组件时，组件不能再被缓存了。 方法一：设置 include，就只会缓存包含的组件，includes 改变，自动删除不再包含了的已缓存组件。 12345&lt;div id=\"app\"&gt; &lt;keep-alive :include=\"includes\"&gt; &lt;component :is=\"compName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt; 方法二：直接操作页面上层 keepAlive 对象中的 cache 列表。 1234567891011121314151617181920212223242526272829303132Vue.mixin(&#123; beforeRouteLeave:function(to, from, next)&#123; if (from &amp;&amp; from.meta.rank &amp;&amp; to.meta.rank &amp;&amp; from.meta.rank&gt;to.meta.rank) &#123;//如果返回上一层，则摧毁本层缓存。 if (this.$vnode &amp;&amp; this.$vnode.data.keepAlive) &#123; if (this.$vnode.parent &amp;&amp; this.$vnode.parent.componentInstance &amp;&amp; this.$vnode.parent.componentInstance.cache) &#123; if (this.$vnode.componentOptions) &#123; var key = this.$vnode.key == null ? this.$vnode.componentOptions.Ctor.cid + (this.$vnode.componentOptions.tag ? `::$&#123;this.$vnode.componentOptions.tag&#125;` : '') : this.$vnode.key; var cache = this.$vnode.parent.componentInstance.cache; var keys = this.$vnode.parent.componentInstance.keys; if (cache[key]) &#123; if (keys.length) &#123; var index = keys.indexOf(key); if (index &gt; -1) &#123; keys.splice(index, 1); &#125; &#125; delete cache[key]; &#125; &#125; &#125; &#125; this.$destroy(); &#125; next(); &#125;,&#125;); 详见这里。 嵌套路由（在父路由组件中还有个 router-view，子路由对应的组件会被渲染到父路由组件中的 router-view），从子路由返回到父路由时是不刷新的，但是子路由强制刷新后，父子路由的组件都会重新渲染，执行各自路由组件的生命周期，并且子路由若被其他页面共用，会导致其父路由都会更新，所以尽量独立使用。这种方法适用于在一个页面上可跳转多个页面，最多二级。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"vue-router","slug":"vue-router","permalink":"https://gromimiss.github.io/tags/vue-router/"}]},{"title":"记对 Vue 中的双向绑定的理解和总结（一）","date":"2020-04-10T16:00:00.000Z","path":"2020/04/11/vue1/","text":"Vue 是一个 MVVM 框架，什么是 MVVM？MVVM，即 Model-View-ViewModel，它的核心就是 ViewModel。ViewModel 向上与 View 进行一个双向数据绑定，向下则与 Model 通过接口请求进行数据交互，能起到一个数据驱动视图的作用。它的核心原理就在于：响应式（监听 data 中的数据变化）以及数据改动引发的视图更新。这篇文章主要记录对响应式这块的理解及总结。 响应式原理基础 API Object.freeze(): 冻结对象，使对象不可修改 Object.preventExtensions(): 阻止添加新属性 Object.seal(): 封闭一个对象，阻止添加新属性并将现有属性标记为不可配置 Object.isExtensible(): 判断一个对象是否是可扩展的（是否可在它上面添加新的属性） Object.isFrozen(): 判断对象是否被冻结 Object.hasOwnProperty(): 自身实例上的属性(非继承) Object.getOwnPropertyNames(): 返回对象自身属性，包括不可枚举的属性，但是不包括 symbol 属性 Reflect.ownKeys(): 相当于结合了 getOwnPropertyNames 和 getOwnPropertySymbols Object.keys(): 返回可枚举的属性（包括原型链上的可枚举属性） 原理解析Vue 中对数据中对象的监听其实就是数据劫持 + 订阅发布，它内部使用了 Object.defineProperty 中的 getter/setter 拦截函数，获取属性值的时候会触发到 getter 函数，将依赖收集起来，当属性值改变时则会触发 setter 函数，通知依赖更新。 而数组的监听则是通过重写数组的指定方法来达到响应式的效果，每当调用数组的方法时都会通知相关依赖。 Object.definePropertyObject.defineProperty(obj, prop, descriptor)：在一个对象上定义或修改一个属性，并返回此对象。obj： 要修改的对象，prop：要定义或修改的属性名，descriptor：属性描述符对象。我们主要讲一下 descriptor。 descriptor 分为数据描述符和存取描述符。 数据描述符： configure：该属性是否可配置，只有当它为 true 时，才可以改变该属性的描述符。默认为 false enumerable：该属性是否可枚举，只有当它为 true 时，该属性才会出现在对象的可枚举属性里。默认为 false writable：该属性是否可修改，只有当它为 true 时，该属性的值才可以被赋值运算符改变。默认为 false value：该属性对应的值。默认为 undefined 若默认为 false 为什么我们没有定义描述符的对象的属性还是可以被修改？—— 这里的默认值指的都是定义了描述符对象但没有指明具体某个数据描述符的值 存取描述符： get：当访问该属性时会调用此函数，该函数的返回值会被用作属性的值 set：当该属性值被修改时会调用此函数 与 proxy 的区别Proxy：可以对外界的访问进行过滤和改写，它可以说是 Object.defineProperty 的全方位加强版，但是兼容性不怎么好，不兼容 IE。 区别： 可以直接监听对象而非属性 可以直接监听数组的变化 有多达 13 种拦截方式 详见这里。 源码分析对数组的监听对数组的数据监听主要通过重写数组的某些方法，在这些方法里面除了调用原有的数组方法并返回，还会调用一开始绑定的 ob 来通知依赖更新并且对新插入的元素继续进行监听。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; def &#125; from '../util/index'/** 创建一个继承 Array 原型的对象：拥有 Array 原型上的方法 在这个新的对象上重写指定方法：不光拥有原来方法的功能，还加上了监听 */const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)// 这些方法都是会改变原数组的const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']methodsToPatch.forEach(function (method) &#123; // 获取原生 Array 上的指定方法 const original = arrayProto[method] // 在新的数组对象上增加 method 属性，并设定其值，该属性可配置可写入 def(arrayMethods, method, function mutator (...args) &#123; // 执行原生的数组方法 const result = original.apply(this, args) // 获取观察者实例，判断数组是否有新增元素 const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; // 若有新增的元素，则再观察新插入的元素 if (inserted) ob.observeArray(inserted) // 通知相关依赖 ob.dep.notify() return result &#125;)&#125;) Observer观察者实例会被绑定在每个被观察的对象上，并且由绑定在观察者实例上的发布者来存储/通知相应的依赖。 12345678910&#123; a: &#123; b: &#123; d: 1 __ob__: [Observer Object] &#125; __ob__: [Observer Object] &#125; __ob__: [Observer Object]&#125; hasProto、protoAugment、copyAugment 1234567891011121314export const hasProto = '__proto__' in &#123;&#125;// 使用 __proto__ 截断原型链来增强目标对象或数组function protoAugment (target, src: Object, keys: any) target.__proto__ = src&#125;// 通过定义不可枚举的属性来增强目标对象或数组function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i] def(target, key, src[key]) &#125;&#125; dependArray(): 让数组中的每一项含有观察则实例的元素上的 dep 被添加到当前 watcher 中，若数组中的值还是一个数组则递归执行 123456789function dependArray (value: Array&lt;any&gt;) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() if (Array.isArray(e)) &#123; dependArray(e) &#125; &#125;&#125; observe(): 对数组或者对象上的值进行检测，若是对象并且不是 VNode 类型，则继续判断该 value 上是否有观察者实例，若已存在则返回，否则判断该值是否可监听，创建一个观察者实例（观察者实例里做了什么下面会讲到）。 1234567891011121314151617181920212223242526// value: 要观测的数据，asRootData:被观测的数据是否是根级数据export function observe (value: any, asRootData: ?boolean): Observer | void &#123; // 若value不是对象或者value是VNode类型的则返回 if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void // 若value有__oj__属性并且__ob__是Observer类型 if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( // 创建观察者 shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; // 是否在服务器加载中 (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; // Object.isExtensible() 判断一个对象是否是可扩展的（是否可在它上面添加新的属性） !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; defineReactive(): 对象的数据响应式在 defineReactive 方法中，它会为对象的每个属性创建一个发布者，通过 Object.defineProperty 设置属性的 getter 函数收集订阅了当前属性变化的依赖，若属性值上也有观察者对象，则也收集依赖，若属性值是一个数组，则需要检查每个元素项是否有观察者对象，有观察者对象的元素都一一收集依赖。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, // 用来打印辅助信息 shallow?: boolean) &#123; // 1.为属性创建一个发布者 const dep = new Dep() // 返回指定对象上一个自有属性对应的属性描述符 const property = Object.getOwnPropertyDescriptor(obj, key) // 若不可配置则返回 if (property &amp;&amp; property.configurable === false) &#123; return &#125; // 若开发者定义的属性原本就有 setter/getter 则予以保留 const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set // 当该属性没有定义 getter 方法或者定义了 setter 方法并且只传入了前两个参数，则 val 就是 obj[key](未处理过的值) // 并且这种情况下 shallow 为 false，就不需要再对其值进行监听了 if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; // 2.这里使用到了上面的 observe 函数，判断是对象或数组则创建或者返回已有的观察者实例 let childOb = !shallow &amp;&amp; observe(val) // 对该对象上的属性设置属性描述符 Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, // 每一个数据字段都通过闭包引用着一个属于自己的 dep 常量 get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val // Dep.targrt 指向需要被收集的依赖 if (Dep.target) &#123; // 3.依赖收集（绑定wachter) dep.depend() if (childOb) &#123; // 4.为属性值添加依赖收集 childOb.dep.depend() // 若对象中的属性值为数组，要为数组元素递归调用 dependArray 继续收集依赖 if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val // newVal !== newVal &amp;&amp; value !== value 检查值是否是 NaN // 若前后值没有变化或者值是一个 NaN，值直接返回 if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; // 执行原来的 setter 函数 if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) // 将新的属性值声明成响应式的 // 通知依赖更新 dep.notify() // 用于由于对象属性修改，即其子元素而触发 setter 函数导致闭包中的 dep 通知所有绑定的 watcher 对象 &#125; &#125;)&#125; Observer: 每个响应式的属性上都会挂有一个 ob 属性，该属性上存储着 Observer 实例，当我们创建实例的时候也会在该实例上创建一个发布者，后续通过该发布者来收集依赖。若属性是数组则按前面的方法重写数组方法，并且对数组的每一项为对象的元素都绑定上观察者。若是普通的对象则将对象上的属性都通过 defineReactive 定义为响应式的属性，这些属性会另外创建发布者来执行依赖的收集及监听。（对象上会有 ob 属性存储绑定在该对象上的观察者实例，并且一个观察者实例对应了一个发布者实例，但是对象的属性监听是另外创建发布者实例来监听的，若属性值还是一个对象并且需要深度观察则也会有 ob 属性）。 12345678910111213141516171819202122232425262728293031323334353637383940export class Observer &#123; value: any; dep: Dep; vmCount: number; // 将此对象作为根数据的vm数量 constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 // 定义一个不可枚举的属性__ob__(防止遍历数据对象时遍历到这个属性) def(value, '__ob__', this) if (Array.isArray(value)) &#123; // 使用哪种方式来增加数组，有 __proto__ 则直接通过替换 __proto__ 改变原型链指向，使其拥有改造过后的数组方法 // 否则直接重写传入数组的方法 const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) // 遍历数组，对可观察的属性进行监听 this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; // 将对象的每个属性都转换成getter/setters walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; // 观察数组中的每一个项 observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; Dep发布者，负责收集订阅者并且通知订阅者。它和订阅者是多对多的关系，运行时会保存当前订阅者。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let uid = 0export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; // 收集订阅者 addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; // 在当前订阅者中存储该发布者 depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; // 通知订阅者执行 notify () &#123; const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;// 在任何时间全局只会有一个 Watcher 依赖的对象的值被计算// 保存即将要收集的目标Dep.target = nullconst targetStack = []// 设置当前订阅者，并将该订阅者放入到订阅者队列里export function pushTarget (_target: ?Watcher) &#123; if (Dep.target) targetStack.push(Dep.target) Dep.target = _target&#125;export function popTarget () &#123; // 删除并返回数组的最后一个元素 Dep.target = targetStack.pop()&#125; WatcherWatcher 会解析一个表达式，通过对这个表达式求值来触发 getter 函数，收集依赖。 parsePath(): 解析简单的路径，比如 a.b.c，使用 . 分割该字符串，形成一个数组，返回一个函数，这个函数接收一个对象参数，函数里面会遍历上面的数组，在传入的 obj 上作为属性获取，即 obj.a.b.c，返回这个值。 12345678910111213141516171819// \\w等价于 [A-Za-z_0-9], .:任何单个字符//匹配不符合包含下划线的任意单词数字组合的字符串// 遍历访问path指定的属性值const bailRE = /[^\\w.$]/export function parsePath (path: string): any &#123; //非法字符串则返回 if (bailRE.test(path)) &#123; return &#125; // 如a.b.c, 返回obj[c] const segments = path.split('.') return function (obj) &#123; for (let i = 0; i &lt; segments.length; i++) &#123; if (!obj) return obj = obj[segments[i]] &#125; return obj &#125;&#125; traverse: 递归遍历一个值去唤起所有的 getters，以至于所有对象里嵌套的属性会作为一个 dep 依赖被收集起来。这里会先判断传入的值是否是一个数组，若不是数组或普通对象或者对象被冻结或者是 VNode 对象则直接返回，否则判断 dep 是否已存在，不存在则将 dep 存在 Set 中，递归遍历值。这里主要就是用于获取值，触发 get 拦截器，seenObjects 用于避免死循环，所以最后要清空掉 12345678910111213141516171819202122232425262728293031export function traverse (val: any) &#123; _traverse(val, seenObjects) seenObjects.clear()&#125;// 将 depId 存储起来function _traverse (val: any, seen: SimpleSet) &#123; let i, keys const isA = Array.isArray(val) // isFrozen 判断一个对象是否被冻结 if ((!isA &amp;&amp; !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) &#123; return &#125; // 若被观察属性值是一个循环引用对象，将会导致死循环，下面的代码就是避免死循环的 // 若 val 绑定了观察器，seen 中没有这个 dep 的话就添加到 seen 中 if (val.__ob__) &#123; const depId = val.__ob__.dep.id if (seen.has(depId)) &#123; return &#125; seen.add(depId) &#125; // 递归遍历直到将所有 depId 全部加入到 seen 中 if (isA) &#123; i = val.length while (i--) _traverse(val[i], seen) &#125; else &#123; keys = Object.keys(val) i = keys.length while (i--) _traverse(val[keys[i]], seen) &#125;&#125; Watcher: 解析传入的 expOrFn，若是一个函数则直接作为 getter 函数，否则使用 parsePath 来解析 expOrFn，将返回的函数作为 getter 函数。若不是计算属性订阅者函数，则直接求值，通过 pushTarget 将全局订阅者设置为该订阅者并执行 getter，若设置了 deep 则递归的求值执行 getter 拦截函数，每个设置了响应式的属性都会调用其对应的 dep.depend，使全局订阅者（即当前订阅者）调用 addDep ，在 newDeps 中存储这个属性的 dep 发布者，发布者不能被重复收集，导致重复通知重复执行设置的监听回调，并且在此方法中会调用发布者的 addSub 方法收集当前订阅者。此时，订阅者存储了所有需要的发布者，并且发布者中也存储了该订阅者，当其中某个属性触发了 setter 拦截函数时，则会执行属性对应的 dep.notify 通知订阅者执行 update，如果订阅者设置的是同步更新，则在 active 的状态下直接调用 getAndInvoke 重新求值(为了得到新的值)并执行传入的监听回调，若是异步更新则放入到一个队列中。 若是计算属性订阅者函数，则会新创建一个 dep，用于收集观察该计算属性的订阅者，计算属性是惰性求值，当该计算属性上没有订阅者时则不用求值，否则通过 this.dep.notify 通知订阅者执行 update。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260let uid = 0export default class Watcher &#123; vm: Component; expression: string; cb: Function; id: number; deep: boolean; user: boolean; computed: boolean; sync: boolean; dirty: boolean; active: boolean; dep: Dep; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) &#123; this.vm = vm // 组件实例的 _watcher 引用着该组件的渲染函数观察者 if (isRenderWatcher) &#123; vm._watcher = this &#125; // 包括渲染函数的订阅者和非渲染函数的订阅者 vm._watchers.push(this) // options.deep: 告诉观察者实例对象是否是深度观测 // options.user: 用来标识当前观察者实例对象是开发者定义的还是内部定义的 // options.computed: 用来标识当前观察者实例对象是否是计算属性的观察者 // options.sync: 用来告诉观察者当数据变化时是否同步求值并执行回调，默认不会同步 // options.before 当数据变化后，触发更新前调用 if (options) &#123; // 转换成boolean类型 this.deep = !!options.deep this.user = !!options.user this.computed = !!options.computed this.sync = !!options.sync this.before = options.before &#125; else &#123; this.deep = this.user = this.computed = this.sync = false &#125; // 回调 this.cb = cb this.id = ++uid this.active = true // 该观察者实例对象是否是激活状态 this.dirty = this.computed // 开启了计算属性，ditry 就为 true，标识脏数据 this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() // 解析 getter 的表达式 if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; // 若expOrFn = 'a.b.c',则返回一个函数：这个函数循环访问path指定的属性值，返回一个obj[c] this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = function () &#123;&#125; // watcher只接受简单的点化分路径，想要完全控制就使用 function 替 process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Failed watching path: \"$&#123;expOrFn&#125;\" ` + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm ) &#125; &#125; // 若是计算属性则另外创建一个发布者 if (this.computed) &#123; this.value = undefined // 惰性求值 this.dep = new Dep() &#125; else &#123; this.value = this.get() &#125; &#125; // 目的：1.触发访问其属性的 get 拦截器函数，收集该订阅者 2.获得被观察目标的值 get () &#123; // 将当前 watcher 设置为全局 watcher，并且把之前全局的 watcher 加入到 target 堆栈中 pushTarget(this) let value const vm = this.vm try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher \"$&#123;this.expression&#125;\"`) &#125; else &#123; throw e &#125; // finally 的作用: 无论出现什么情况，finally 块里的代码一定会被执行并且 finally 块里的代码也是在 return 之前执行的/// 若 try 或者 catch 中有 return，并且 finally 中也有 return，finally 中的 return 会覆盖别处的 return 语句 &#125; finally &#123; // 若是深度观察 if (this.deep) &#123; // 递归每一个对象或者数组，触发它们的 getter，使得对象或数组的每一个成员都被依赖收集 traverse(value) &#125; // 将上一个全局从队列中移除并作为当前全局 Watcher // 一开始会推入渲染订阅者，当我们计算值的时候别的订阅者被推入到全局，但计算完之后，需要继续将渲染订阅者作为全局订阅者 popTarget() this.cleanupDeps() &#125; return value &#125; // 添加一个依赖到这个指令 // 避免收集重复依赖 addDep (dep: Dep) &#123; const id = dep.id // this.newDepIds 避免在一次求值中收集重复的依赖 if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) // this.depIds 避免在多次求值中收集重复的依赖（多次求值：当数据变化时重新求值） if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; // 清空依赖收集 // 将旧的依赖编号与新的依赖编号进行对比，若旧依赖中存在的编号在新依赖集合编号中不存在，就删除对应的编号依赖 // 交换新旧依赖集合编号，清空新依赖集合 // 交换新旧依赖数组，清空新依赖数组 cleanupDeps () &#123; // this.deps 上次清空之前存放的发布者 // this.newDeps 保存的是当前正在收集依赖的发布者 let i = this.deps.length while (i--) &#123; const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) &#123; // 更新 dep 中保存的依赖 dep.removeSub(this) &#125; &#125; /** 为什么 newDepIds 明明要被 clear 掉的却还是要赋值一个 tmp？ `this.depIds = this.newDepIds this.newDepIds.clear()` 若直接这样写那 depIds 中刚赋值的数据也会被 clear 掉，因为指向的是一个引用 但若是增加一个 tmp 中间变量，则正好可以保留 newDepIds 中的数据，删除 depIds 中的数据 **/ let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 &#125; // 由 dep 通知相关依赖响应更新 update () &#123; if (this.computed) &#123; // 一个 computed 属性 watcher 有两种模式:lazy 和 activated // 初始化默认是 lazy，并且只有在至少一个订户依赖时才被激活，这通常是另一个计算属性或组件的渲染功能 if (this.dep.subs.length === 0) &#123; // 在 lazy 模式中，我们不希望在必要之前执行计算 // 所以我们简单的标记 watcher 是被污染的，真实的计算是在计算属性被访问时在 this.evaluate 方法中被执行 this.dirty = true &#125; else &#123; // 在 activated 模式中，我们希望主动执行计算，但是仅在值确实发生改变时通知我们的订户 this.getAndInvoke(() =&gt; &#123; // 通知订阅者一一更新 this.dep.notify() &#125;) &#125; &#125; else if (this.sync) &#123; this.run() &#125; else &#123; //异步更新的好处： 当修改多个值时分别都会触发一次重新渲染，导致严重的性能问题，而使用异步更新则解决了这个问题 queueWatcher(this) &#125; &#125; // 调度程序工作接口 // 会被调度程序调用 run () &#123; if (this.active) &#123; this.getAndInvoke(this.cb) &#125; &#125; // 当值发生变化时调用（触发响应时要重新求一次值） getAndInvoke (cb: Function) &#123; // 对于渲染函数的观察者来说，重新求值等价于重新执行渲染函数，最终结果就是重新生成虚拟DOM并更新真实DOM const value = this.get() // 这个判断是为非渲染函数类型的观察者准备的，用来对比新旧两次求值的结果，当值不相等时就调用通过参数传递进来的回调 if ( value !== this.value || // 当值一样时深度 watcher 和 object 类型 watcher 应该触发，因为值可能有改变 isObject(value) || this.deep ) &#123; // 设置新的值 const oldValue = this.value this.value = value // 表明求过值了 this.dirty = false // 是由开发者定义的，通过 watch 选项或 $watch 函数定义的观察者，回调函数行为不可预知，需要放在 try catch 中，友好提示错误 if (this.user) &#123; try &#123; cb.call(this.vm, value, oldValue) // 将回调函数的作用域修改为当前Vue组件实例 &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher \"$&#123;this.expression&#125;\"`) &#125; &#125; else &#123; cb.call(this.vm, value, oldValue) &#125; &#125; &#125; // 计算并返回 watcher 的值，这只是获得计算属性 watchers 的 evaluate () &#123; // 表示当前观察者对象没有被求值 if (this.dirty) &#123; this.value = this.get() this.dirty = false &#125; return this.value &#125; // 添加这个 watcher 依赖。只针对计算属性 watchers // 渲染函数执行前 Dep.target 肯定是渲染函数的观察者对象，所以计算属性观察者对象的 this.dep 收集的就是渲染函数的观察者对象 depend () &#123; if (this.dep &amp;&amp; Dep.target) &#123; this.dep.depend() &#125; &#125; // 从所有依赖的订阅用户列表中移除自己 teardown () &#123; if (this.active) &#123; // 如果 vue 实例未被销毁，则从 vue 实例的 watcher 列表中移除自己 if (!this.vm._isBeingDestroyed) &#123; remove(this.vm._watchers, this) &#125; // 将订阅者实例对象从所有的 dep 实例对象中移除 let i = this.deps.length while (i--) &#123; this.deps[i].removeSub(this) &#125; this.active = false &#125; &#125;&#125; 整体链路被观察的对象都绑定了一个 __ob__ 的内部属性，指向了一个观察者实例，这个观察者实例上则保存了一个 dep 属性，指向一个发布者实例，发布者实例的 subs 属性存储着一个依赖列表（由想监听当前数据变化的订阅者们组成），而每个订阅者中的 deps 属性中存储着上一次求值时的发布者列表，newDeps 属性中则存储着当前求值时的发布者列表。 实现一个简易的响应式基于上面的思想，我们来简单的实现一个响应式数据更新。 Observe.js 1234567891011121314151617181920212223242526272829303132333435363738394041import Dep from './dep';class Observe() &#123; constructor(value) &#123; this.value = value; this.walk(value); &#125; walk(obj) &#123; for (let key in obj) &#123; this.defineReactive(obj, key, val); &#125; &#125; observe(val) &#123; if (val !== null &amp;&amp; typeof val === 'object') &#123; Object.keys(value).forEach(key =&gt; &#123; defineReactive(value, key, value[key]); &#125;); &#125; &#125; defineReactive(obj, key, val) &#123; const dep = new Dep(); observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; if (Dep.target) &#123; dep.depend(); &#125; return val; &#125;, set(newVal) &#123; if (val !== newVal) &#123; val = newVal; observe(newVal); dep.notify(); &#125; &#125; &#125;); &#125;&#125; Dep.js 1234567891011121314151617181920212223let uid = 0;class Dep() &#123; constructor() &#123; this.id = uid++; this.subs = []; &#125; addSub(sub) &#123; this.subs.push(sub); &#125; depend() &#123; Dep.target.addDep(this); &#125; notify() &#123; const subs = this.subs.slice(); subs.forEach((sub) =&gt; &#123; sub.update(); &#125;); &#125;&#125;Dep.target = null;export default Dep; Watcher.js 12345678910111213141516171819202122232425262728293031import Dep from './dep';class Watcher() &#123; constructor(vm, expFn, cb) &#123; this.vm = vm; this.expFn = expFn; this.cb = cb; this.val = this.get(); this.deps = []; &#125; get() &#123; Dep.target = this; const val = this.vm[expFn]; Dep.target = null; return val; &#125; addDep(dep) &#123; const ids = this.deps.map((dep) =&gt; dep.id); if (ids.indexOf(dep.id) &lt; 0) &#123; this.deps.push(dep); dep.addSub(this); &#125; &#125; update() &#123; const val = this.get(); if (val !== this.val) &#123; this.val = val; this.cb.call(this.vm, val); &#125; &#125;&#125;","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://gromimiss.github.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"源码","slug":"源码","permalink":"https://gromimiss.github.io/tags/源码/"}]},{"title":"JS 中的执行上下文、作用域链、闭包以及this","date":"2020-04-02T16:00:00.000Z","path":"2020/04/03/context/","text":"为了总结执行上下文、this、作用域以及闭包这几个基础知识点，看了很多的文章，但发现大多是对其表现进行总结，为了更好的记忆我就去了解了下 JS 的编译原理。 JS 属于什么语言？什么是解释型语言？不需要在运行前编译，在运行程序时才进行翻译，专门的解释器会负责在每个语句执行的时候解释程序代码。 什么是编译型语言？在计算机运行代码前，需要先将代码翻译成计算机可以理解的文件再执行，他只要经过一次编译就可以运行，除非修改代码，否则无需重新编译。 JS 属于解释型语言，每句代码只有在运行时才能知道这句代码是否有错，而编译型语言在运行之前进行了编译，编译器会对所有代码进行检查，以至于不会出现使用了不存在的变量等问题。 但是若 JS 属于解释型语言，那为什么还会有变量提升和 JIT 代码优化呢？ 变量提升在函数作用域内的任何变量的声明都会被提升到顶部，并且赋值 undefined，所以是 JS 引擎解释了两次同一段代码？第一次变量提升然后第二次再执行代码还是说先编译了整个代码然后再运行的呢？ 这就要了解下 JS 的运行机制了。 JS 的运行机制浏览器会先按照 js 的顺序加载外部或者内嵌的脚本代码（不异步加载的情况下），然后开始按顺序执行代码 JS 首先会进入一个执行上下文（函数），对代码进行词法分析，将这段程序分解成词法单元。 在对当前作用域分析完成后，引擎会将词法单元解析成 AST。 引擎遇到声明语句时会询问作用域在当前作用域集合中是否已存在该名称的变量，若已存在则会忽略该声明，否则它会要求作用域在当前作用域集合中声明一个新的变量（若是没有 var，则会向上查找，直到全局作用域也没找到，则在全局作用域中声明一个新的变量），每次声明都会为变量分配内存，注意，只是分配内存，并不会修改源代码将变量声明语句提升。 之后引擎再赋值或取值时会询问作用域在当前作用域集合中是否存在该名称的变量，若不存在则往上查找，直到到最外层的作用域，即全局作用域，若找到了则会赋值给这个变量，若未找到则抛出一个 ReferenceError 异常。 最后，再由引擎生成 CPU 可以执行的机器码。 代码执行完毕。 变量提升并不是代码修改，在这个过程中并没有生成中间代码，它只是 JS 解释器处理事情的方式。 变量提升具体示例从上面的处理过程就可以看出，当我们写 var a = 2 时，会被分为两部分任务，第一个是声明变量并赋值 undefined，第二个是将值赋值给变量，所以无论作用域中的声明出现在什么位置，都将会在代码被执行前进行处理。 需要注意的是函数声明会被提升，但是函数表达式是不会被提升的。 12345foo();bar();var foo = function bar() &#123; // 代码内容&#125; 在经过提升后，上面代码会变成： 1234567var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function () &#123; // 为什么最终打印出来的并不是一个匿名函数呢？ var bar = ...self... //...&#125; 虽然函数声明和变量声明都会被提升，但是当函数声明和变量声明重复的时候，若函数声明是在后面，则可以覆盖前面的变量，若函数声明在前面，变量并不能覆盖掉前面的函数。（个人理解函数声明可以当成是把声明和赋值都提升到了上面，而后面遇到同变量名的是不会再去重新声明分配内存的） 123console.log(foo); // function foo() &#123;&#125;var foo;function foo() &#123;&#125; 123console.log(foo); // function foo() &#123;&#125;function foo() &#123;&#125;var foo; 123var foo; console.log(foo); // function foo() &#123;&#125;function foo() &#123;&#125; JITJIT 及时编译是为了解决多次重复编译的问题的，比如说下面这段代码在解释型语言中执行时就会将 sum+= i 编译 1000 次，造成非常大的性能损耗。参考该文章 123for (let i = 0; i &lt; 1000; i++) &#123; sum += i;&#125; JIT 只是 Mozila 和 Google 的开发人员为了提升浏览器性能才引入的，JS 并没有强制要求使用 JIT。 执行上下文即 JS 代码解析执行时所处的环境，它会以栈(先入后出)的方式被存放。 当 JS 代码开始执行时，会先进入全局环境，此时全局上下文被创建并入栈，之后当调用函数时则进入相应的函数环境，相应函数上下文被创建并入栈，当处于栈顶的执行上下文执行完毕后，则会将其出栈。 一个执行上下文的生命周期：创建阶段（生成变量对象、建立作用域链、确定 this 指向），执行阶段（变量赋值、执行其他代码）。 生成变量对象： 检索当前上下文中的参数，生成 arguments 对象，建立以形参变量名为属性名，形参变量值为属性值的属性 检索当前上下文中的函数声明，建立以函数名为属性名，函数所在内存地址引用为属性值的属性 检索当前上下文中的变量声明，建立以变量名为属性名， undefined 为属性值的属性（若变量名和形参变量名或函数相同，则该变量声明不会影响已存在的这类属性） 12345function test(a) &#123; console.log(a); var a;&#125;test(2); // 2 词法作用域词法作用域由书写代码时函数声明的位置来决定的，词法分析阶段就可以知道全部变量的位置以及是如何声明的，从而预测在执行过程中如何对它们进行查找。但在 JS 中有两个机制可以 “欺骗” 词法作用域：eval() 和 with。 eval：执行一段包含一个或者多个声明的代码字符串，以至于在运行时修改了已经存在的词法作用域。 with：将一个对象的引用作为作用域来处理，对象的属性作为作用域中的变量来处理，从而创建了一个新的词法作用域。 为什么要尽量避免使用 eval 和 with？引擎将无法在词法分析时对作用域查找进行优化，导致性能问题。 作用域链作用域链是指当前上下文和上层上下文的一系列变量对象组成的层级链，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。在执行上下文的执行阶段，当需要查找某个变量或函数时，会在当前上下文的变量对象中进行查找，若未找到，则沿着上层上下文变量对象进行查找，直到全局上下文中的变量对象。 函数作用域是在函数被声明时确定的。每个函数都会包含一个 [[scope]] 内部属性，在函数被声明时，该函数的 [[scope]] 属性会保存其上层上下文的变量对象，形成包含上层上下文变量对象的层级链。当函数被调用时，其执行上下文会被创建并入栈。在创建阶段生成其变量对象后，会将该变量对象添加到作用域链的顶端，并将 [[scope]] 添加进该作用域中。 在 JS 中我们熟悉的只有全局作用域和函数作用域，但事实上还有两个特殊的情况： with：在上面就讲过了 with 会从对象中创建出作用域。 try/catch：catch 中捕获到的 err 对象只有在 catch 代码块中才能访问到。 闭包指有权访问另一个函数作用域中变量的函数，它可以创建内部变量，即私有变量，让外部不能随意修改这些变量，暴露一个访问器（函数）来让外部间接访问。 应用场景主要有结果缓存，模块，函数节流等。1234567function resultCache(fn) &#123; const cache = Object.create(null); return (function cachedFn (str) &#123; const hit = cache[str]; return hit || (cache[str] = fn(str)); &#125;);&#125; this它取决于函数调用的位置。 分为以下几种情况： new 创建的对象实例，绑定到新创建的对象(非显示返回函数或对象的情况下) call/apply/bind：严格模式下指向第一个参数，非严格模式下，null 和 undefined 指向全局对象，基本数据类型指向其包装对象 事件，指向绑定事件的那个元素 对象上的函数调用，绑定到那个对象 普通函数调用，严格模式下绑定到 undefined，非严格模式绑定到全局对象 箭头函数指向包裹箭头函数的第一个普通函数的 this（定义时指向谁就是谁，不会随着调用者的改变而改变） 结尾记录一道面试题： 123456789var foo = 1;function bar() &#123; foo = 10; return; function foo() &#123;&#125;&#125;bar();alert(foo); 结果： 1解析：123456789var foo;function bar() &#123; function foo() &#123;&#125; // 这里在 bar 函数中声明了局部变量 foo foo = 10; return;&#125;foo = 1;bar();alert(foo); 代码实际上会变成以上所示，bar 函数里面的 foo 函数声明会被提升，由于后面又有 foo = 10 会把函数声明的值给覆盖，相当于变成了 var foo = 10，这里面的 foo 是 bar 函数执行上下文中的变量对象，在外面获取不到，所以 alert 的其实还是外面的 foo 变量。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"JS 中的对象继承","date":"2019-09-20T16:00:00.000Z","path":"2019/09/21/extend/","text":"对象继承作为 JS 的基础知识点之一，它是怎么做到的呢？ES5 的继承和 ES6 的继承之间的区别又是什么呢？ 基础原型每个普通函数都有一个 prototype 属性，它指向了一个对象，这个对象就是原型，每个原型上都有一个 constructor 属性指向构造函数。 每个对象上都有一个内置属性 __proto__，这个属性会指向该对象的原型。 new 操作符new 操作符做了什么？它会创建一个用户定义的对象类型的实例或者具有构造函数的内置对象的实例。它内部的实现原理： 继承自 Ctor.prototype 的新对象会被创建 将 this 绑定到新创建的对象 构造函数若没有显式的返回一个对象或函数，则返回创建的对象，若显式的返回了一个对象或者函数则会覆盖创建的对象（非对象类型不会覆盖，如 null，string，number，undefined，boolean，symbol） 123456789function newOperator(Ctor) &#123; let obj = Object.create(Ctor.prototype); let params = [...arguments].slice(1); let result = Ctor.apply(obj, params); if (result !== null &amp;&amp; typeof result === 'object' || typeof result === 'function') &#123; return result; &#125; return obj;&#125; 原型链每个对象都拥有一个 __proto__ 内置属性，它指向了该对象的原型对象，而原型对象也会拥有一个 __proto__ 内置属性，他也会指向一个原型对象。 当在查找一个对象上的方法或属性时，会先在构造函数内部查找，若没有找到，则会在其原型对象上查找，若还没有找到则会继续往上搜索，直到最后指向了 null。 实现 原型继承 将父类实例赋值给子类的原型，形成一条原型链。 1234567891011121314151617function Parent(name) &#123; this.name = name;&#125;Parent.prototype.getName = function() &#123; return this.name;&#125;function Child(age) &#123; this.age = age;&#125;Child.prototype = new Parent('Tom');Child.prototype.getAge = function() &#123; return this.age;&#125;let p = new Child(12);console.log(p); 缺点：不能在创建子类实例的时候向父类构造函数传递参数，并且若父类构造函数中的属性是一个引用类型的值，之后创建出来的实例的该属性将会指向一个引用，互相影响。 组合继承 结合原型链和借用构造函数的方式实现一个继承。 12345678910111213141516171819function Parent(name) &#123; this.name = name;&#125;Parent.prototype.getName = function() &#123; return this.name;&#125;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;Child.prototype.getAge = function() &#123; return this.age;&#125;let p = new Child('Tom', 12);console.log(p); 缺点：执行了两次构造函数。 寄生组合继承 12345678910111213141516171819202122232425function Parent(name) &#123; this.name = name;&#125;Parent.prototype.getName = function() &#123; return this.name;&#125;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = Object.create(Parent.prototype, &#123; constructor: &#123; value: Child, enumerable: false, writable: true, configurable: true, &#125;,&#125;);Child.prototype.getAge = function() &#123; return this.age;&#125;let p = new Child('Tom', 12);console.log(p); ES6 继承原代码：1234567891011121314151617class Parent &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;class Child extends Parent &#123; constructor(name, age) &#123; super(name); this.age = age; &#125; getAge() &#123; return this.age; &#125;&#125; 解析后的主要代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596\"use strict\";function _inherits(subClass, superClass) &#123; if (typeof superClass !== \"function\" &amp;&amp; superClass !== null) &#123; throw new TypeError(\"Super expression must either be null or a function\"); &#125; // 设置 subClass.prototype：以父类原型对象为基础创建一个新对象，这个对象的 constructor 指向子类构造函数 subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123; constructor: &#123; value: subClass, writable: true, configurable: true &#125; &#125;); // 设置 subClass.__proto__ 为父构造函数 if (superClass) _setPrototypeOf(subClass, superClass); &#125;function _createSuper(Derived) &#123; return function () &#123; // 前面通过 _inherts 方法设置了 __proto__ 为父构造函数，所以这里指向父构造函数 var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) &#123; var NewTarget = _getPrototypeOf(this).constructor; /** 类似于 new: 创建一个以 Super 为构造函数，arguments 为传入构造函数中的参数，NewTarget 为新创建对象的原型对象的实例 和以下代码等价： var result = Object.create(NewTarget.prototype); Super.apply(result, args); **/ result = Reflect.construct(Super, arguments, NewTarget); &#125; else &#123; // 为什么不直接使用 new Super() 返回一个父类实例? // 因为这样返回的就是一个单纯的父类实例，后面在子类原型上挂的方法将获取不到 result = Super.apply(this, arguments); &#125; // 若调用以上方法没有得到返回值或者返回值不是对象或函数，则会直接返回子类实例，否则返回返回值 return _possibleConstructorReturn(this, result); &#125;; &#125;// 在原型和构造函数上定义相应的属性function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; &#125;var Parent = /*#__PURE__*/function () &#123; function Parent(name) &#123; // 不能像调用函数那样调用类 _classCallCheck(this, Parent); this.name = name; &#125; // 创建原型对象上的属性和构造函数上的属性 _createClass(Parent, [&#123; key: \"getName\", value: function getName() &#123; return this.name; &#125; &#125;]); return Parent;&#125;();var Child = /*#__PURE__*/function (_Parent) &#123; // 将 Child 子类的 prototype 设置成 Parent.prototype // 将 Child 子类的 __proto__ 设置成 Parent _inherits(Child, _Parent); // 创建一个 super 函数，这里会去执行父构造函数，将父类中设置的实例属性添加在子实例上 var _super = _createSuper(Child); function Child(name, age) &#123; var _this; _classCallCheck(this, Child); _this = _super.call(this, name); _this.age = age; return _this; &#125; _createClass(Child, [&#123; key: \"getAge\", value: function getAge() &#123; return this.age; &#125; &#125;]); return Child;&#125;(Parent); 区别ES6 的继承其实就是 ES5 中的寄生组合继承，区别只在于 ES5 的继承实际上是创建一个子类的实例对象，然后将父类的属性都添加到这个实例对象上，而 ES6 的继承中子类必须在 constructor 方法中调用 super 方法，通过调用 super 方法在支持 Reflect.construct 的情况下创建一个以父构造函数为构造函数，子类构造函数为原型对象的实例，后面子类的属性都会添加到这个实例上，若不支持的话才会像 ES5 的继承一样通过 Parent.call(Child, args) 创建一个子类的实例对象，然后将父类的属性都添加到这个实例对象上。 上面例子的结构对比图：","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"浅拷贝和深拷贝","date":"2019-08-09T16:00:00.000Z","path":"2019/08/10/copy/","text":"浅拷贝和深拷贝作为面试必考知识点之一，特此记录下。 浅拷贝什么是浅拷贝？对象只会被会克隆最外部的一层，更深层的对象还是通过引用指向同一块堆内存。 浅拷贝有哪些？Object.assign()、展开运算符、Array.from() 等 简单实现12345678910function shallowClone(obj) &#123; if (obj === null || typeof obj !== 'object') &#123; return obj; &#125; let result = &#123;&#125;; for (let key in obj) &#123; result[key]= obj[key]; &#125; return result;&#125; 深拷贝什么是深拷贝？对对象中的对象也会进行一份拷贝，指向不同的堆内存。 深拷贝有哪些？JSON.parse(JSON.stringify(obj))、jquery 中的 extend、lodash 中的 extend 等。 简单实现12345678910function simpleDeepClone(obj) &#123; if (obj === null || typeof obj !== 'object') &#123; return obj; &#125; let result = Array.isArray(obj) ? [] : &#123;&#125;; for (let key in obj) &#123; result[key] = simpleDeepClone(obj[key]); &#125; return result;&#125; 但是像 JSON.parse(JSON.stringify(obj)) 和上面的 simpleDeepClone 其实都只是实现了简单的深拷贝，实际上我们还需要考虑一些特殊的场景。 对函数、regexp、symbol、Date 等的克隆 稀疏数组（指有部分内存空间未被使用的数组，虽然定义了 n 个元素的空间，但实际上没有放满 n 个元素，有部分空间是 empty） 自定义对象的对象类型会丢失，所有对象都会指向 Object 循环引用会报错：RangeError: Maximum call stack size exceeded 当不考虑函数、自定义对象以及 symbol 的克隆的话可以直接使用 MessageChannel。 1234567function structuralClone(obj) &#123; const &#123;port1, port2&#125; = new MessageChannel(); port2.onmessage = (ev) =&gt; &#123; console.log(ev.data); &#125;; port1.postMessage(obj);&#125; 完整的实现123456789101112131415161718192021222324252627282930313233343536 function deepClone(obj) &#123; const oldList = []; const newList = []; const _clone = (obj) =&gt; &#123; // 函数、自定义对象、日期、正则、循环引用需要特殊处理 if (obj === null || typeof obj !== 'object' || typeof obj === 'function') &#123; return obj; &#125; if (obj instanceof Date) &#123; return new Date(obj); &#125; if (obj instanceof RegExp) &#123; return new RegExp(obj.source, obj.flags); &#125; // 解决循环引用的问题 let result = Object.create(Object.getPrototypeOf(obj)); const idx = oldList.indexOf(obj); if (idx !== -1) &#123; return newList[idx]; &#125; oldList.push(obj); newList.push(result); // 遍历 symbol 类型的属性 let symbolKeys = Object.getOwnPropertySymbols(obj); if (symbolKeys.length) &#123; symbolKeys.forEach((key) =&gt; &#123; result[key] = _clone(obj[key]); &#125;); &#125; for (let key in obj) &#123; result[key] = _clone(obj[key]); &#125; return result; &#125;; return _clone(obj);&#125; 获取属性的方法： for…in 返回所有能通过对象访问的可枚举属性，包括实例和原型中的属性 Object.keys 返回对象自身所有的可枚举属性，不包括原型中的属性 Object.getOwnPropertyNames 返回对象自身的属性（包括不可枚举属性但是不包括 Symbol 值作为名称的属性），不包括原型中的属性 Object.getOwnPropertySymbols 返回对象中以 Symbol 值作为名称的属性 Reflect.ownKeys 返回对象自身的属性（包括不可枚举属性以及 Symbol 属性），相当于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)) 总结深克隆需要注意的情况可能还不止这些，并且如果对象特别大特别深的情况下，对性能会有影响，后续有时间看一下 lodash 的源码再来记录下。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"charles 的常用操作","date":"2019-07-24T16:00:00.000Z","path":"2019/07/25/charles/","text":"Charles 是一个功能十分强大的抓包工具，如果说在 Windows 上用的比较多的是 Fiddler，那么在 Mac 上用的比较多的就是 Charles 了。它有很多实用的功能，给我带来了很多惊喜，并且还需要我去继续发现，解锁新的技能，借此先总结一波。 常用功能抓包抓包是使用 charles 最基础也是最常见的操作了，它会通过将自己设置成代理服务器来完成抓包。一般移动端页面由于没有开发者工具，所以调试的时候使用的比较多，它能抓取请求，将请求数据和响应数据等信息都一一展示以便于我们去捕捉到问题的根源。并且，当对项目不了解，页面又比较多的时候，也可以通过 charles 来找到你需要改动的页面。 默认情况下，charles 会勾选系统代理，以至于在本地发出的请求也会被截取到，在移动端调试的时候可能不想抓取本地的请求，可以在 Proxy -&gt; macOS Proxy 取消勾选。 抓取移动设备上的 http 请求 在 Proxy -&gt; ProxySettings 设置 HTTP 代理的端口，默认是 8888 在 Help -&gt; Local IP Addresses 中查看本机的 IP 地址 手机上在连接的 WIFI 中设置代理：设置 -&gt; 无线局域网 -&gt; 指定 wifi -&gt; HTTP 代理 -&gt; 设置为手动，填写上面的 ip 地址和端口 在 charles 中允许访问，如果不想每换个手机都需要点击允许访问，可以在 Proxy -&gt; Access Control Settings 中加入 0.0.0.0/0(IPv4) 或 ::/0(IPv6) 在 charles 中查看抓取到的请求相关的信息 抓取移动设备上的 https 请求https 请求不同于 http 请求， 它加了一层 SSL 验证，所以在以上步骤后还需要： 在手机上安装证书：在浏览器中打开 http://chls.pro/ssl 下载并安装证书（可以在 SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser 中查看如何安装证书）。 在 Charles 中允许 SSL 代理：Proxy -&gt; SSL Proxying Settings -&gt; 添加要抓取的 https 请求，若想抓取所有 https 请求，可以添加 *:443 遇到的问题： charles 抓取 https 请求失败，提示： Failure SSLHandshake:Received fatal alert: unknown_ca You may need to configure your browser or application to trust the Charles Root Certificate.这是因为在 ios 10.3 之前安装自定义证书会默认信任，但之后安装新的证书默认是不受信任的，需要手动去设置，设置路径：设置 -&gt; 通用 -&gt; 关于本机 -&gt; 设置信任证书 某些 app 禁止了 https 代理，比如微信新版本现在就不可以抓取 https 代理了，我的微信版本 7.0.5 还可以抓取 模拟请求和后端调试过程中，后端定位问题时，往往会打断点让我们再请求一次，就可以直接在 charles 中重新发起请求，而不需要再到页面中手动走流程，更快捷省力。 重复发送请求 选中一个请求 -&gt; 右键 -&gt; Repeat(发送一次) 选中一个请求 -&gt; 右键 -&gt; Repeat Advanced -&gt; 配置并发量和重复请求次数 手动添加参数，模拟请求 选中一个请求 -&gt; 右键 -&gt; Compose -&gt; 配置请求相关信息 -&gt; Execute 执行请求（模拟指定的请求） Tools -&gt; Compose New Request -&gt; 配置请求相关信息 -&gt; Excute 执行请求（模拟新的请求） 过滤请求通常情况下，网络请求会很多，有时候我们需要从几十个请求里去找到我们想要抓取的哪个请求，比较费时，这个时候就可以对网络请求进行过滤，过滤出我们想要的请求。 在界面中点击 Sequence -&gt; Filter -&gt; 输入想匹配到的请求包含字符串，比如想抓取百度的请求，就可以输入 baidu。 Proxy -&gt; Recording Settings -&gt; 配置需要监控的协议，地址，端口（高级配置） 代理转发一般我们的服务都分为本地、测试、预发、线上环境，在开发过程中我们可能需要连的是后端的 ip，并且可能一个项目需要和多个后端对接，之后上测试，上预发又需要连接到相应的环境，就需要用到 charles 的代理转发功能了。 Tools -&gt; Map Remote Settings -&gt; 勾选 Enable Map Remote -&gt; Add 它不像 switchhost，它的配置可以精确到协议，端口，路径。 重写设置我们可以配置对某些请求重写它的请求信息，每次发送请求匹配到配置好的 url 时，charles 就会截取到请求，重写配置好的请求信息。比如同一个 ip 的不同端口对应着不同的环境，就可以通过种不同的 cookie 来映射要连接的是什么环境。并且在开发的过程中也可以通过种 cookie 来隔离某些请求，做一些和其他请求不同的操作。 使用： Tools -&gt; Rewrite Settings -&gt; 勾选 Enable Rewrite -&gt; Add 总结charles 是开发调试过程一个强大的工具，不光开发，测试也可以通过它来更好的定位到问题，找对应的开发去解决问题。它还有很多功能是我没有用到的，等用到过之后再来补充。","comments":true,"tags":[{"name":"charles","slug":"charles","permalink":"https://gromimiss.github.io/tags/charles/"},{"name":"工具","slug":"工具","permalink":"https://gromimiss.github.io/tags/工具/"},{"name":"抓包","slug":"抓包","permalink":"https://gromimiss.github.io/tags/抓包/"}]},{"title":"文件上传","date":"2019-07-02T16:00:00.000Z","path":"2019/07/03/upload/","text":"一直对文件相关的 API 不是很了解，这次做到移动端上传图片的需求就想着总结记录一下。 相关对象FileReaderFileReader 用来异步读取存储在用户计算机上的文件内容，可读取 Blob 或 File 对象。 常用方法： readAsDataUrl(file/blob)：将指定的对象读取为一个 base64 编码的 URL readAsText(file/blob, [,encoding])：将指定的对象根据特殊的编码格式转化为响应的字符串，* encoding 默认为 utf-8 readAsArrayBuffer(file/blob)：将指定的对象读取为一个 ArrayBuffer 常用事件： load：文件成功读取时触发 error：文件读取失败时触发 123456const reader = new FileReader();reader.onload = function (ev) &#123; // 读取的结果，ev.target.result === reader.result console.log(ev.target.result)&#125;;reader.readAsDataURL(file); Blob一个不可变、原始数据的类文件对象，可以通过 Blob() 构造函数将一个非 Blob 对象和数据构造为一个 Blob 对象。 Blob(array, [,options]): 可将由 ArrayBuffer, ArrayBufferView, Blob, DOMString 或者其他类似对象的混合体组成的数组转换为一个 Blob 对象。 FileFile 基于 Blob，它继承了 Blob 的功能并且支持用户系统上的文件。以下三种情况下都会返回这种对象： 用户通过 &lt;input&gt; 元素选择文件后返回的 FileList 对象 拖放操作时生成的 DataTransfer 对象 HTMLCanvasElement 中的 mozGetAsFile() ArrayBuffer一个用来表示通用、固定长度的原始二进制数据缓冲区。通过 ArrayBuffer 构造函数分配一段可以存放数据的连续内存区域。详细见这里。 URLURL.createObjectURL()：返回一个 URL，这个URL表示指定的 File 对象 / Blob 对象，一般用来显示图片。URL.revokeObjectURL()：用完释放 URL 以获得最佳性能和内存使用状况。 具体实现如果需要一次上传多张图片则要设置 multiple 属性，这个属性在 ios 中有效，但是 android 中还是只能上传单张图片。 123456&lt;input type=\"file\" ref=\"uploadImg\" multiple accept='image/*' @change=\"change\"&gt; 移动端上传图片，由于现在很多手机像素都很高，所以上传的手机中的照片都很大，以至于上传会很慢，所以需要对图片先做一个压缩再进行上传。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788change(event) &#123; const files = this.$refs.uploadImg.files; const len = this.imgList.length; if (len + files.length &gt; 9) &#123; note('图片最多可上传9张', &#123; mask: false, &#125;); return; &#125; Array.prototype.forEach.call(files, (file, index) =&gt; &#123; let url = URL.createObjectURL(file); this.imgList.push(&#123; status: 'loading', displayPath: url, realPath: '', &#125;); if (window.ArrayBuffer &amp;&amp; window.Uint8Array &amp;&amp; window.Blob &amp;&amp; window.File &amp;&amp; file.size &gt; 1024 * 1024) &#123; this.compress(url, file, index, len); return; &#125; this.uploadImg(file, index, len); &#125;);&#125;,compress(url, file, index, len) &#123; const img = new Image(); img.src = url; img.onload = () =&gt; &#123; let width = img.width; let height = img.height; let ratio; if ((ratio = width * height / 1000000) &gt; 1) &#123; ratio = Math.sqrt(ratio); width /= ratio; height /= ratio; &#125; else &#123; ratio = 1; &#125; let canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; let ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, width, height); // 进行最小压缩 let ndata = canvas.toDataURL('image/jpeg', 0.5); canvas = null; this.transformFile(ndata, file, index, len); &#125;;&#125;,transformFile(url, file, index, len) &#123; // 解码使用 base-64 编码的字符串 let bytes = atob(url.split(',')[1]); let arrBf = new ArrayBuffer(bytes.length); let unitArr = new Uint8Array(arrBf); for (let i = 0; i &lt; bytes.length; i++) &#123; unitArr[i] = bytes.charCodeAt(i); &#125; const blob = new Blob([arrBf], &#123; type: file.type, &#125;); const result = new File([blob], name, &#123; type: file.type, &#125;); if (result &amp;&amp; result.size) &#123; this.uploadImg(result, index, len); &#125; else &#123; this.uploadImg(file, index, len); &#125;&#125;,uploadImg(file, index, len) &#123; uploadImage([file]).then((urls) =&gt; &#123; this.imgList[len + index].status = 'success'; this.imgList[len + index].realPath = urls[0]; &#125;) .catch((err) =&gt; &#123; this.imgList[len + index].status = 'failed'; note('服务器异常', &#123; mask: false, &#125;); &#125;);&#125;,removeImg(index) &#123; URL.revokeObjectURL(this.imgList[index].displayPath); this.imgList.splice(index, 1);&#125;, 遇到的问题 使用相机拍照后上传，上传一次后 change 事件不再触发（在公司APP内是这样子，在浏览器中正常） 在安卓手机中直接打开相册上传图片只能选择一张，目前没办法做到选择多张 在公司 APP 中上传图片只能选择图片不能选择照相 在 app 上页面请求和其他资源请求协议不一致可能会出问题。页面是 http 请求，但是图片是 https 请求，图片在公司 APP 中就无法正常显示，所以不能写死协议，由浏览器自动补全 在安卓手机中当上传一次图片之后取消选择也会触发 change 事件，所以要在 change 事件中加一层判断 总结若是承载在 app 上的 h5 页面做上传图片最好还是使用原生提供的方法或者在微信上可以使用 jssdk 提供的上传图片，要不然体验还是不怎么好。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"表情编辑器组件的简单实现","date":"2019-06-23T16:00:00.000Z","path":"2019/06/24/emojiEditor/","text":"在项目中遇到需要用到表情编辑器的需求，看到老后台里面的表情编辑器一堆 Bug，正好这个项目要迁移新后台，就想着重构一版，原本以为挺简单的一玩意，但是真正开发的过程中遇到了很多问题。之前也没有这块的经验，都是直接使用的网上现成的库，所以这次想着记录一下摸索的过程。 基本功能介绍这个表情编辑器不同于别的富文本编辑器，它只支持插入表情，功能比较单一，正也是因为需要支持表情，涉及到标签，所以不能通过 textarea 来写。并且前期我一直在考虑这个编辑器是否要双向绑定，如果双向绑定就意味着要去区分这个值是在哪里改变的，因为 value(真正的数据，会传到数据库的数据，不带标签) 和 content(展示在页面上的数据，带标签，展示表情图) 是不同的，而 value 改变，content 就要改变，所以需要监听 value 是组件内的改变还是组件外的改变，若是组件内的改变，则不应该触发 content 的改变。最后考虑到如果使用传入默认值的形式，那么就只能暴露出方法，每次有改动都需要调用这个方法去改变值，相较于双向绑定，使用起来没有那么方便，并且表情编辑器也是表单组件中的一部分，所以还是做成双向绑定更为合适。 根据项目需要，分析出编辑器需要有以下可配置项： value 编辑器的 value 值 width 编辑器的宽度，默认 100% height 编辑器的高度 max 编辑器最多可输入的字符数 placeholder 编辑器未输入时显示的提示字符 UI 展示如下： 主要实现基本结构 准备表情合成的雪碧图、表情字符和对应类名间的映射文件 基本 HTML 结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;div class=&quot;cus-emoji-editor&quot; :style=&quot;styleObj&quot; @click.stop=&quot;&quot;&gt; &lt;!-- 工具栏：插入表情的按钮 --&gt; &lt;div class=&quot;cus-emoji-editor__toolbar&quot;&gt; &lt;span id=&quot;emojiBtn&quot; class=&quot;cus-emoji-editor__btn-emoji&quot; @click=&quot;insertAutoFocus&quot;&gt;&lt;/span&gt; &lt;ui-popover target=&quot;#emojiBtn&quot; ref=&quot;emojiPopover&quot; placement=&quot;top&quot; trigger=&quot;click&quot;&gt; &lt;div&gt; &lt;ui-menu :menu=&quot;menu&quot; class=&quot;cus-emoji-editor__emoji-menu line&quot; @emit=&quot;menuChange&quot; current-menu=&quot;emoji&quot;&gt;&lt;/ui-menu&gt; &lt;div class=&quot;cus-emoji-editor__emoji-body&quot;&gt; &lt;i v-for=&quot;(item, key) in emojData&quot; :key=&quot;key&quot; :class=&quot;item&quot; :title=&quot;key + &apos;_web&apos;&quot; @click=&quot;insertEmoji(key, item)&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;/ui-popover&gt; &lt;/div&gt; &lt;!-- 编辑区域--&gt; &lt;div class=&quot;cus-emoji-editor__content&quot;&gt; &lt;div class=&quot;cus-emoji-editor__placeholder&quot; v-if=&quot;placeholder &amp;&amp; !hasVal &amp;&amp; !isFocus&quot; @click=&quot;focus&quot;&gt;&#123;&#123;placeholder&#125;&#125;&lt;/div&gt; &lt;div class=&quot;cus-emoji-editor__input&quot; v-html=&quot;content&quot; contenteditable=&quot;true&quot; ref=&quot;input&quot; @focus=&quot;isFocus = true&quot; @blur=&quot;isFocus = false&quot; @compositionstart=&quot;isComplete = false&quot; @compositionend=&quot;isComplete = true&quot; @input=&quot;handleInput&quot; @paste=&quot;handlePaste&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cus-emoji-editor__len&quot; v-if=&quot;max&quot;&gt; &#123;&#123;len&#125;&#125;/&#123;&#123;max&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 通过背景图位置的设置控制表情图的显示，比如： 1234567891011121314.qqemoji &#123; display: inline-block; width: 28px; height: 28px; background: url(xxx.png) 0 0 no-repeat; zoom: 1; background-size: 1900%; cursor: pointer; vertical-align: middle; box-sizing: content-box;&#125;.qqemoji-1 &#123; background-position: -4px -4px;&#125; 编辑器的主体功能相关属性及 api 复习想要了解所有 API，可见文档. Selection 对象：表示用户选择的文本范围或插入符号的当前位置，可能横跨多个元素。 Range 对象：用户选择的某个区域（某个连续的一部分），通常情况下用户只能选择一个范围，但是用户也可以通过 control 键并选多个区域（chrome 中禁止了这个动作）。 anchor：一个选区的起始点，即鼠标按下瞬间的那个点。 focus：一个选区的终点，即鼠标松开瞬间所记录的那个点 window.getSelection() 获取选中对象，在firefox、safari、chrome、opera、ie9+下使用 document.selection 获取选中对象,在 ie9 以下使用 selection.getRangeAt(0) 选中的第一个区域 selection.removeAllRanges() 将所有区域从选区中移除 selection.addRange() 添加一个区域对象到选区 range.insertNode(el) 在选中位置起点处插入元素 range.cloneRange() 克隆一个选中区域 range.setStart(el, 1) 设置 range 对象的起点，el 为 range 的起始位置，1 为从 el 开始位置算起的偏移量 range.setEnd(el, 1) 设置 range 对象的终点 range.setStartBefore(el) 将某个节点的起点位置设置为 range 对象的起点位置 range.setStartAfter(el) 将某个节点的终点位置设置为 range 对象的起点位置 range.setEndBefore(el) 将某个节点的起点位置设置为 range 对象的终点位置 range.setEndAfter(el) 将某个节点的终点位置设置为 range 对象的终点位置 range.collapse(true) true 光标向 start 折叠为一个点，false 光标向 end 折叠为一个点 range.deleteContents() 从文档中移除 range 中的内容 主体功能实现一个表情编辑器主要考虑三点，一是输入文字、二是插入表情、三是复制粘贴。整个流程是这样的： 输入文字 -&gt; 计算字符数 -&gt; 组件内部设置 value -&gt; 反应到组件外 插入表情 -&gt; 组件内部设置 value -&gt; 反应到组件外 复制粘贴 -&gt; 组件内部设置 value -&gt; 反应到组件外 用户设置 value -&gt; 触发 content 的设置 下面是细节实现： 输入文字是上面三个点中最简单的一个，它只需要保证光标是在一个 div 中（用于分行），并且考虑输入中文时应该到输入完成才触发值的改变。 123456789101112131415161718192021222324252627282930handleInput(ev) &#123; setTimeout(() =&gt; &#123; // 中文是否输完 if (!this.isComplete) &#123; return; &#125; let firstChild = this.$refs.input.firstChild; if (!firstChild || firstChild.nodeName !== &apos;DIV&apos;) &#123; this.$refs.input.innerHTML = &apos;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&apos;; &#125; if (this.max || this.max === 0) &#123; this.setVal(); &#125; else &#123; this.debounceSetVal(); &#125; &#125;, 0);&#125;,setVal() &#123; this.isInner = true; const children = this.$refs.input.children; let val = &apos;&apos;; // 分行 for (let i = 0; i &lt; children.length; i++) &#123; val = i !== children.length - 1 ? `$&#123;val&#125;$&#123;children[i].textContent&#125;\\n` : `$&#123;val&#125;$&#123;children[i].textContent&#125;`; &#125; this.value = val; this.$emit(&apos;input&apos;, this.value); this.$emit(&apos;change&apos;, this.value);&#125;, 插入表情里有很多需要注意的点: 当没有进入编辑器的焦点时，选择表情也应该可以插入表情，并且要考虑到编辑器是否有值，默认聚焦光标会在编辑器的起始点，所以需要我们手动将光标移动到文本最后。 当编辑器插入表情或者粘贴时，它会被添加到 &lt;br&gt; 后面，这个 &lt;br&gt; 不会被自动去掉。&lt;br&gt; 的作用是光标定位，在 &lt;div&gt; 里面加一个 &lt;br&gt; 可以让光标定位到 &lt;div&gt; 里面，但是要注意的是输入字符浏览器会自动去掉 &lt;br&gt;，而插入表情和复制粘贴需要我们自己手动去除。 表情图片的展示必须使用 img 标签，否则光标没法正确的展示，但是 img 标签还是会有一个问题，由于没有设置 src 属性，它会有一个边框，通过设置 border 也没有办法去掉，只能通过在 src 上添加一个透明图片。 表情字符要存在一个标签中，这样之后就可以通过 textContent 属性获取所有文本内容，它包含了子孙元素中的文本。 每个编辑器的类名必须要区分开来，否则若一个编辑器设置了 this.range，另一个编辑器也会拿到那个 range 的值，导致 range 混乱，插入表情出现问题（我这里是加了一个 manage.js，管理所有编辑器的 uid）。 选中文本插入表情，选中文本应该被清除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 处理首次进入页面，还没有保存 range 对象的情况，解决第一个问题insertAutoFocus() &#123; if (!this.range) &#123; this.$refs.input.focus(); // 默认进入焦点焦点会在内容区的起始位置，所以要将光标移到内容区的最后 this.moveCursorToLast(this.$refs.input); &#125;&#125;,moveCursorToLast(el) &#123; if (!el.lastChild) &#123; return; &#125; if (window.getSelection) &#123; let range = window.getSelection(); range.selectAllChildren(el.lastChild); // range 选择obj下所有子内容 range.collapseToEnd(); // 光标移至最后 &#125; else if (document.selection) &#123; // 兼容 IE let range = document.selection.createRange(); range.moveToElementText(el.lastChild); range.collapse(false); range.select(); &#125;&#125;,// 若选区是在编辑区的，则保存这个选区getCursor() &#123; const selection = this.getSelection(); const anchorNode = selection.anchorNode; const inputClass = `cus-emoji-editor__input--$&#123;this.uid&#125;`; const placeholderClass = `cus-emoji-editor__placeholder--$&#123;this.uid&#125;`; const aNCls = anchorNode.className || &apos;&apos;; const aNParentCls = anchorNode.parentNode.className || &apos;&apos;; const ancestorCls = anchorNode.parentNode.parentNode.className || &apos;&apos;; // 这里要区分不同编辑器 if (anchorNode &amp;&amp; (aNCls.indexOf(inputClass) &gt; -1 || aNCls.indexOf(placeholderClass) &gt; -1 || aNParentCls.indexOf(inputClass) &gt; -1 || ancestorCls.indexOf(inputClass) &gt; -1)) &#123; this.range = selection.getRangeAt(0); &#125;&#125;,insertEmoji(key, className) &#123; this.$refs.emojiPopover.hide(); let range = this.range; if (!range) &#123; return; &#125; // 显示表情图 let el = document.createElement(&apos;img&apos;); el.className = className; // 存放表情字符 let elText = document.createElement(&apos;span&apos;); elText.style.display = &apos;none&apos;; elText.innerText = key; // 删除之前选中区域的内容 range.deleteContents(); // 插入表情和字符 range.insertNode(el); range.insertNode(elText); // 将光标位置移动到插入的表情后 this.moveRange(el); this.setVal(); this.removeBr(el, elText);&#125;,removeBr(el, elText) &#123; // 当首次没有进入编辑器焦点，点击插入表情，表情会插入到 &lt;br&gt; 后 if (elText) &#123; const prev = elText.previousSibling; if (prev &amp;&amp; prev.nodeName === &apos;BR&apos; &amp;&amp; prev.parentNode.nodeName === &apos;DIV&apos;) &#123; prev.parentNode.removeChild(prev); &#125; &#125; // 当编辑器插入表情或者粘贴时，后面的 &lt;br&gt; 不会自动被去掉 const next = el.nextSibling; if (next &amp;&amp; next.nodeName === &apos;BR&apos; &amp;&amp; next.parentNode.nodeName === &apos;DIV&apos;) &#123; next.parentNode.removeChild(next); &#125;&#125;,moveRange(el, range) &#123; range = (range || this.range).cloneRange(); if (el) &#123; range.setStartAfter(el); &#125; range.collapse(true); let selection = this.getSelection(); selection.removeAllRanges(); selection.addRange(range);&#125;, 复制粘贴： 复制粘贴要考虑的是不需要将样式，图片等一起粘贴过来，我们只需要文本和表情，而表情就是一个图片，这一点暂时还没有处理，目前只支持复制文本。 小细节：toolbar 中表情 tool 可以使用 button 按钮，当你选中某些文本的时候就会有选中的效果，如果使用 span 标签，选中效果会被清除 123456789101112131415handlePaste(ev) &#123; ev.preventDefault(); let data = ev.clipboardData.getData(&apos;text&apos;); let selection = this.getSelection(); if (selection &amp;&amp; data !== &apos;&apos; &amp;&amp; data !== null) &#123; let textNode = document.createTextNode(data); // 删除选中文本 this.range.deleteContents(); // 插入文本 this.range.insertNode(textNode); this.moveRange(textNode); this.setVal(); this.removeBr(textNode); &#125;&#125;, 其他实现及注意点 有这样一个场景：在表格列表中点击某条记录中的编辑，打开编辑 dialog，dialog 中有表情编辑器，那么多条记录是共用的一个 dialog，编辑器也是同一个，只是编辑器的值会改变，此时需要在每次 dialog 打开时（即用户设置值的时候），将 range 清空，否则在没有聚焦时插入表情就会出现问题。 12345678910111213141516171819202122232425watch: &#123; value(newVal, oldVal) &#123; if (this.isInner) &#123; this.isInner = false; return; &#125; this.setContent(newVal); &#125;,&#125;,methods: &#123; setContent(val) &#123; let parseVal = parseEmojiMessage(val); let eles = parseVal.split(/\\n/); let ele = &apos;&apos;; for (let index = 0; index &lt; eles.length; index++) &#123; const element = eles[index]; if (element) &#123; ele += `&lt;div&gt;$&#123;element&#125;&lt;/div&gt;`; &#125; &#125; this.$refs.input.innerHTML = ele || &apos;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&apos;; // 一定要清空 this.range = null; &#125;,&#125; 文本删除时，div会被一并删除，所以当文本为空时要手动加上 &lt;div&gt;&lt;br&gt;&lt;/div&gt; &lt;br&gt; 的作用只能是光标定位，换行会新增 &lt;div&gt;&lt;br/&gt;&lt;/div&gt;，但是当换行后又添加文字时 &lt;br&gt; 会被去掉，所以不能通过替换 &lt;br&gt; 为 \\n 传到数据库，我们需要确保每一行都在一个 div 中，通过 div 来换行 列表中显示表情编辑器的内容时，需要将 emoji 字符 替换为表情图。由于 replace 会替换掉所有符合的字符串，所以一定要加匹配到的表情字符去重，以防止二次替换（将 中的表情字符再次替换掉）。 12345678910111213141516171819202122 const parseEmojiMessage = (content) =&gt; &#123; if (!content) &#123; return &apos;&apos;; &#125; let regx = /\\[[\\u2E80-\\u9FFF|BQXK|BQTS|BQHL|BQJX|BQBA|BQMS|BQBG|BQBT|BQJR|BQQZ|BQLW]+\\]/g; // 匹配文本中表情相关信息 let matchList = content.match(regx); let noRepeatMatch = []; // 去重，防止替换过的在 span 标签中的表情字符被再次替换 matchList &amp;&amp; matchList.forEach((item) =&gt; &#123; if (noRepeatMatch.indexOf(item) &lt;= -1) &#123; noRepeatMatch.push(item); &#125; &#125;); noRepeatMatch.forEach((item) =&gt; &#123; let className = qqEmoj[item] || wxEmoj[item]; let str = `\\\\$&#123;item.substring(0, item.length - 1)&#125;\\\\]`; // 替换的标签不要换行，否则表情中的\\n处理会出问题 content = content .replace(new RegExp(str, &apos;g&apos;), `&lt;span style=&quot;display: none;&quot;&gt;$&#123;item&#125;&lt;/span&gt;&lt;img src=&quot;http://h0.hucdn.com/open201926/c94e6ea80e94bba4_10x10.png&quot; class=&quot;$&#123;className&#125;&quot; /&gt;`); &#125;); return content;&#125;; 由于宽度设置的是百分比，当英文单词放不下时，width会自动拉长，想要自动换行可以： 1234.cus-emoji-editor__input &#123; width: xxxpx; word-wrap: break-word;&#125; 未实现的优化 复制 emoji 表情 目前点击表情 tool 时编辑器会失焦，光标消失，最好让编辑器在点击的时候还是聚焦的状态 每次符合条件的 range 对象都会被记录下来以至于之后失焦时点击插入表情都会插入在失焦时的位置，而首次没有 range 对象时点击插入表情会插入到文本末尾，这里可以考虑统一插入到最后（由于点击表情的时候编辑器就会失焦，所以没办法去区分是聚焦的时候点击的表情，还是失焦的时候点击的表情） 总结看似简单的表情编辑器在真正开发的过程中遇到的问题还挺多的，并且结合场景还会发现一些平时注意不到的问题。以上只是一个表情编辑器的简单实现，还有很多细节需要去继续优化，后续再补充。","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://gromimiss.github.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"由于分页组件引发的一些思考","date":"2019-05-20T16:00:00.000Z","path":"2019/05/21/page/","text":"之前在写组件库的时候就一直想不好对传入的不同的 prop 应该做怎么样的处理，最近总结了一下。 prop 有哪些处理情况？前不久，在使用公司内部的组件库时遇到一个问题：它默认初始化时会触发一次页码 change 事件，而我在进入页面时会调用一次获取列表数据的接口，并且在页码 change 事件中也会调用一次获取列表数据的接口，这就导致了页面进入时会触发两次获取列表数据的接口，去找架构组同事沟通了下，他说这是考虑到了前端将列表数据存在本地，通过页码 change 事件去获取列表数据，这让我想到了关于组件 prop 的一些问题： 在组件中会使用到很多的 prop，通过传入的 prop 去判断是否要支持某个功能或者是作为一个组件的值。以 page 当前页为例，有以下3种情况： page 是一个双向绑定的值，在组件内部和外部传入的变量是永远保持一致的，即内部改变则外部也改变，外部改变内部也改变（双向） page 由外部传入，组件内部通过 watch 这个属性来做一些内部数据的更新（不会影响到外部的数据，单向） page 是外部传入的一个初始值，组件内部会在初次传入时将值赋给内部的一个变量，后期即便外部改变传入的变量值，内部也不再接收这个改变（首次有效） 而分页组件中的 page 一般是作为一个初始值，在页码 change 事件中会携带一个当前页码的值，以供外部获取，而作为一个默认初始值，它后来没有改变，也就不应该去触发页码 change 事件。即便有一种特殊情况，用户将数据存在本地，通过获取页码信息的接口返回的页码信息来获取到本地对应页，也应该由用户通过 js 去改变 page 来触发 页码 change 事件然后获取列表数据。 什么情况下应该触发 change 事件在组件中一个值改变有 3 种情况： 用户改变（比如在 input 中输入文字） 组件内部改变（比如开发者通过组件暴露的一个方法去设置值） 它是一个双向绑定的值，开发者直接改变传入的变量则组件内部也接收到了改变 change 事件是只要值改变就应该触发而不考虑是哪种情况下改变的值，但是这样会有一个问题：有部分业务场景下，我们只需要用户通过输入/选择改变值才触发 change 事件，然后去做一些特殊的处理，这个时候若只是原来那个 change 事件就没有办法去区分了，所以是否有必要去再添加一个额外的 change 事件更合适呢。 总结虽然，vue 中对数据的订阅发布触发视图的更新也是不考虑数据是哪里改变的，如何改变的，但是作为开发者，我们是可以知道在哪里做了数据的改变的，并且在代码中可以做一些额外的处理，而组件库作为基于 vue 的一些组件的封装，我们是没有办法在特定的场景做一些特定的操作的，因为 vue 是面向开发者的，而业务开发是面向用户的。","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://gromimiss.github.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"组件库","slug":"组件库","permalink":"https://gromimiss.github.io/tags/组件库/"}]},{"title":"浏览器渲染过程及前端页面性能分析优化","date":"2019-04-28T16:00:00.000Z","path":"2019/04/29/performance/","text":"当我们在浏览器输入网站域名，并按下回车之后的一段时间里，其实发生了很多事情，比如协议补全、域名解析、TCP 三次握手、发送请求、页面解析等等，因此这一过程可优化的点也很多。本文旨在阐述浏览器渲染网页时的一系列过程，在对浏览器如何工作足够了解的基础上，使用调试工具来分析页面性能，借此找到阻碍浏览器性能的问题点，从而做出相应优化。 输入 URL 并回车后发生了什么浏览器解析 URL当输入 URL 并回车后，浏览器首先会对 URL 进行解析，获取协议、主机、端口、路径，根据不同协议进行不同的处理。 浏览器检查本地缓存浏览器通过 Expires 和 Cache-control 来检查缓存是否新鲜，若命中缓存则直接从缓存中拉取资源信息，否则则发送新的请求。 Expires：HTTP 1.0 中提供，会比对此字段返回的时间和客户端时间，若在此之前则命中缓存。 Cache-control：HTTP 1.1 中新增，通过设置 max-age 指定缓存多久后过期（它会根据第一次请求的时间和设置的有效期计算出过期时间，在过期时间之前就能命中缓存）。若同时有 Cache-control 和 Expires，则Cache-control 的优先级更高，因为 Expires 设置的是服务器的时间，可能会和客户端时间不一致，导致缓存出错。其他常见配置项： no-cache：每次使用缓存前都先向服务端验证，若服务端表示资源仍可用，则使用缓存 no-store：禁止浏览器缓存数据，每次请求资源都会向服务器发送请求，并重新下载完整资源 public：可被所有用户缓存，包括终端用户和 CDN 等中间代理服务器 private：只能被终端用户的浏览器缓存 具体参考这篇文章，解释的特别清楚。 浏览器组装一个 HTTP 请求报文一个 HTTP 请求报文包含了请求行、请求头、请求体，这一步浏览器会组装一个完整的请求报文以备后续发送请求。 请求行：包含了请求方法、请求 url、http 版本。 请求头：用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。服务器会以此获取客户端信息。 常见请求头： Accept：告诉服务器，客户端接受什么类型的响应 Cookie：通过这个请求头将 cookie 传递给服务器 Referer：表示这个请求是从哪个 URL 过来的 Cache-Control：对缓存进行控制 User-Agent：告诉服务器发起请求的应用程序名称 Host：给出接受请求的服务器的主机名和端口号 请求体：传递请求数据，比如图片、视频等等。 DNS 域名解析，获取 ip 地址因为计算机更擅长处理一长串数字，而 ip 地址又不方便用户记忆和沟通，所以就诞生了域名，用户可以通过域名来访问网站，通过 DNS 服务解析为 ip 地址，最后访问到网站所在的 ip 地址。DNS 用于 TCP/IP 网络，它会将主机名和域名转换为 ip 地址。 浏览器获取 ip 地址会有以下过程，若查找到则不会再执行后面的几步： 从浏览器中检查缓存 在 chrome 中可以通过 chrome://net-internals/#dns 查看各域名的 DNS 缓存信息，默认每个域名缓存 60 s。在 firefox 中可以通过 about:config 查看 DNS 的缓存数量及缓存时间，默认每个域名缓存 60 s。注：DNS 记录会有一个 TTL 值（记录最大有效期，单位：s），os 缓存会参考此值，但是不完全等于此值，而浏览器 DNS 缓存的时间和此值无关，每种浏览器都使用了一个固定值。（参考此文章） 从系统中检查缓存 检查本地的 hosts 文件是否有这个网址的映射关系 路由器缓存 ISP（电信运营商） DNS 缓存 DNS 递归查询 本地 DNS 一般是指电脑上网时 IPv4 或 IPv6 设置中填写的 DNS，这个可以手动指定也可以由 DHCP 自动分配。如果电脑是直连运营商网络的，一般默认情况下 DNS 为 DHCP 分配到的运营商的服务器地址，若电脑和运营商之间还加了路由器，则它分配给下面电脑的 DNS 地址就是它自身，一般是 192.168.1.1，并且很有可能路由器本身还内置了一个 DNS 转发器，它会将发往它所有的 DNS 请求转发到上层 ISP 的 DNS。 在设置路由器的时候一般都会在 WAN 口设置中看到一个选项：手动设置 DNS 服务器，当我们未设置 DNS 服务器时，访问网络的情况如下（未转发）： 而当我们设置了本地网络供应商提供的 DNS 地址，则可以最大限度提升电脑与网络的交换速度，提高网络访问速度（转发）： DNS 服务器查询过程： 主机向本地域名服务器递归查询：主机所询问的本地域名服务器若不知道被查询域名的 ip 地址，它就会以客户的身份，向其他根域名服务器继续发出查询请求，主机不用管后续过程，只会接收最终结果。 本地域名服务器向根域名服务器迭代查询:当本地域名服务器向根域名服务器查询时，根域名服务器若查询到了具体的 ip 地址则会直接给出，若未查询到则会告诉本地域名服务器下一步要去哪个域名服务器下进行查询，让本地域名服务器进行后续的查询。（全球 DNS 根服务器只有 13 台） 这个过程，主机就相当于是老板，而本地域名服务器是秘书，老板只需要接收最终的结果，秘书则负责和部门同事 A 沟通，若沟通无果则和部门同事 B 沟通，直到问出结果，再将结果告诉老板。 TCP 三次握手HTTP 基于 TCP 协议，浏览器需要在三次握手后才能捎带 HTTP 请求报文，达到真正的建立连接。 TCP 三次握手图示： ACK 标志位：标志确认号 ack 是否有效，当 ACK = 1 时，确认号有效。 SYN 标志位：连接建立时用于同步序号。SYN = 1，ACK = 0 表示是一个连接请求报文段，如同意连接，则在响应报文段中使 SYN = 1，ACK = 1，握手完成后会被重新置为0。 序列号 seq：标记数据段的顺序，TCP 把连接中发送的所有数据字节都编上序号，发送给另一端。这个序号主要是用来保证有序的，当 A 向 B 发送一个数据包的时候，seq 会叠加，每一个传输方在传送数据时都会带上这个信息，另一端按照这个序号来排序收到信息的顺序，从而保证信息的传递是有序的，也可以确认有没有丢包的情况。 确认号 ack：确认号是另一端对对方 seq 的一个回应，一般会把对方给的 seq + 1 然后下一次发包的时候带上，这样对方就知道我们是收到了前面的消息的。 这个过程就是这样的：客户端向服务端发起建立连接的请求，携带了一个 SYN 标志位，服务端收到请求后携带一个 SYN 和一个 ACK 回复客户端，表示收到了请求，客户端再携带 ACK 回复服务端表示收到请求并建立连接。 为什么要是 3 次握手？ 3 次握手可以确保数据已经被客户端接收到，是一个互相确认信息可被正确接收的过程。若是 2 次，则服务端不知道是否有没有将数据成功传给客户端。这里写的很详细。 SSL/TLS 连接若使用的 HTTPS 协议就需要建立 SSL/TLS 连接。 HTTP 的内容是明文传输的，数据会经过中间代理服务器、路由器、通信服务商等多个节点，传输过程中就可能被劫持数据。SSL/TLS 就是为了对传输的数据进行加密。 HTTPS 通过 CA 机构颁发的数字证书来标识网站的身份，包括了证书持有者、证书持有者公钥等信息。它会通过对比数字签名和浏览器拿到对的证书进行对比： CA 拥有非对称加密的私钥和公钥(非对称加密指的是通过公钥加密的数据只能通过这个私钥来解密，而私钥加密的数据也只能通过公钥来解密) CA 对证书明文信息进行 hash，使用私钥加密，得到数字签名 明文和数字签名组成了数字证书，颁发给网站 浏览器拿到证书之后得到明文 T，数字签名 S 使用 CA 机构的公钥对 S 解密 用证书里说明的 hash 算法对明文 T 进行 hash 比较这两者是否一致 具体参考这篇文章。 服务器检查缓存HTTP 请求发送成功后服务器会检查缓存： Last-Modified：HTTP 1.0 中提供，浏览器第一次发起请求时，服务器会在 Last-Modified 响应头中携带文件最后更新的时间（服务器时间），而后浏览器再次发起请求时，就会在 If-Mofified-Since 请求头中将之前 Last-Modified 中的时间传递给服务器，服务器检查缓存后发生若文件没有更新，则直接返回一个 304 的响应头，减少响应数据量，提高响应速度。 ETag：HTTP 1.1 中新增，它是文件的一个唯一标识符，只要文件发生改变，这个标识就会发生改变。服务器会将比对 If-None-Match 请求头，若文件没有更新，也直接返回一个 304 响应头。若同时有 Last-Modified 和 ETag，则 ETag 的优先级更高，因为在一些特殊的情况下 Last-Modified 可能会缓存出错：服务器时钟出错，服务器时钟进行了修改，在本地打开了缓存文件，但并没有进行修改，又或者在不可感知的时间内对文件进行了修改（Last-Modified 只能以 s 计时）。 处理请求处理程序接收请求并做处理，比如一些数据库增删查改操作，然后将响应报文通过 tcp 连接发送回浏览器。 浏览器接收 HTTP 响应在 HTTP 1.0 中使用的是短连接，每次请求都会使用新的 TCP 连接，而在 HTTP 1.1 中使用的是长连接，当并发请求时最多会创建 6 个 TCP 连接，之后的请求就需要等待前面的请求完成才能开始（在 HTTP 1.0 和 HTTP 1.1 中浏览器在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数的请求会被阻塞，在 chrome 中这个限制数是 6 个），而在 HTTP 2.0 中则新增了多路复用，基于二进制分层， 可以在共享 TCP 连接的基础上同时发送请求和响应。HTTP 消息被分解为独立的帧而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。 HTTP 1.1 图示： 现在一般默认都是 HTTP 1.1，所以浏览器接收 HTTP 响应后会根据情况来选择是否要关闭 tcp 连接，关闭 tcp 连接的话就要进行 4 次挥手。 TCP 4 次挥手图示： FIN：释放一个连接，FIN = 1 表示此报文段的发送方的数据已经发送完毕，要求释放连接。 为什么挥手需要 4 次？ 因为 tcp 是全双工的，即 A 在给 B 发信息的同时，B 同时也在给 A 发信息，所以当断开的时候，必须要求双方都得知道。客户端发送一个 FIN 信号给服务器端，表示想要关闭连接，服务器端收到关闭信息告诉客户端还有数据没发好，让客户端等一下，然后服务器端再发送一个信息给客户端，表示可以关闭连接了，客户端回应服务端你关闭吧，不用理我，然后进入 time_wait 状态，服务器端收到 ack 信息就关闭了，客户端在等待 2MSL 后，服务端没东西给过来就也关闭连接。 浏览器检查响应状态码常见状态码： 200 请求成功 301 永久重定向，浏览器需要重新发送一个 HTTP 请求到服务器返回的新地址 302 临时重定向 304 请求资源并没有改变 400 错误请求，语法或参数有误 401 未授权 403 禁止，拒绝请求 404 找不到资源 405 请求方法不被允许 500 服务器内部错误 502 错误网关 504 网关超时 对响应进行解码若文件很大，那下载就会比较慢，特别是网速慢的时候，所以一般会对响应数据进行压缩。浏览器发送请求一般都会携带 Accept-Encoding: gzip,deflate，若服务器对响应内容进行压缩，则会在响应头中返回 Content-Encoding: gzip，浏览器接收到响应，发现响应头中包含了 Content-Encoding 就会将响应内容进行解压。 资源下载、处理浏览器收到响应数据，进行渲染： DOM 树构建（parse HTML）：浏览器接收到网络传输的字节数据，会将这些字节数据转换为字符串，之后再将这些字符串通过词法分析转换为标记，标记化后将这些标记转换为 node，最后这些 node 会根据不同 node 之间的联系构建为一颗 DOM 树。 构建 CSSOM 树（Recaculate Style）：这个过程其实是一个样式的重新计算，因为浏览器本身有一套内置样式表，所以最终的 CSSOM 树其实是浏览器样式和页面所有样式的重新计算。（浏览器确定节点的样式是自右向左的，比如 div span 会先找到所有的 span，再去找到 div，然后给复合条件的 span 标签设置样式，所以我们应该尽可能避免写过于具体的 CSS） 合并 DOM 树和 CSSOM 树为 Render 树：只包括渲染页面需要的节点（不包括 display: none 的节点还有 &lt;head&gt; &lt;meta&gt; 等节点）。 布局（Layout）：各元素尺寸、位置的计算。 绘制（Paint）：结合渲染树和布局信息绘制实际像素。 复合图层化（Composite）：渲染层合并，由于对页面中 DOM 元素的绘制是在多个层上进行的，所以在每个层绘制完后，浏览器会将所有层按照合理的顺序合并成一个图层，显示到屏幕上。图层化是浏览器为了充分利用已有的渲染成果，最小化 GPU 运算，将 “脏区” 提升为复合图层，隔离变化影响的操作（GPU 有自己的处理器和存储器及数据处理模型）。 浏览器将元素提升为一个复合层有多种原因： 3D 或透视变换 css 属性，如 translate3d &lt;video&gt;、&lt;iframe&gt;、&lt;canvas&gt;、&lt;webgl&gt; 等元素 元素自身的 opacity 和 transform 做 css 动画 使用 will-change 属性：提前告诉浏览器要变化，这样浏览器会做一些优化工作 filters position:fixed 元素在复合层上渲染（隐式合成） 性能优化要点输入 URL 之后的过程其实做了很多处理，因此在这个过程中，其实可以发现很多可以优化的地方。 对资源进行强缓存，若页面代码更新，则通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新的资源 域名预解析，对页面中不在同一个域的域名进行预获取，并且缓存结果。 1&lt;link ref=&quot;dns-prefetch&quot; href=&quot;域名&quot;&gt; 使用 HTTP 2.0 （HTTP 2.0 做了很多优化，比如首部压缩、多路复用、二进制分帧等） 协商缓存 启用 GZIP 将静态资源部署到 CDN 节点上，避免图片、js、css等资源文件的请求携带 cookie 减少页面请求，如：合并 css/js 文件；将背景图合并成一个文件，通过 background-image 和 background-position 来显示；行内图片使用 Data URI Scheme，它不会被浏览器缓存，但若放在 css 的 background 中，会随着 css 被一起缓存，并且它的体积是原数据体积的 4/3，在图片很小、网络受限的时候使用最好 延迟加载：对于首屏不需显示的资源可以延迟加载 css 不会阻塞 DOM 的解析，但是会阻塞 DOM 的渲染和 js 的执行，所以应尽量扁平层级，优化选择器，对于不是首屏需要的样式可以通过 preload 来预加载（不会被立即执行）。 js 会阻塞 DOM 的解析和渲染，所以应该将 js 放在 body 底部，或者使用 defer 延迟加载，使用 async 异步执行 压缩 js、css、图片等资源 尽量避免重排（影响布局，需要重新计算每个元素的尺寸和位置）和重绘（元素更改外观但不影响布局，不影响其他元素，比如 color）：不一条条的去修改 dom 样式，尽量使用 className 一次修改；当必须要改变一个节点会导致重排的样式时，尽量让重排次数减少，可以将节点设置 dispaly: none，做完大量修改后，再让这个元素显示，或者克隆一个节点，做完修改后，再替换文档树中的节点；避免强制同步布局（在获取某个样式——比如高度之前做了样式的更改，就会导致浏览器去提前执行布局的计算，造成多次重排），应该尽量批量读取样式，然后执行样式的修改；避免布局抖动（循环读取一个样式值，然后使用此值来更新样式，造成重复重排)；动画使用 transform，而不是修改 left 或 top 不使用 table 布局，一次小改动导致整个 table 重新布局 尽量使用 flexbox，它的运行速度更快 避免隐式合成导致的额外内存占用 尽量避免使用 setTimeout 和 setInterval，而是使用 requestAnimationFrame 强制同步布局： 1234567// 错误写法el.classList.add(&apos;test&apos;);console.log(el.offsetWidth);// 正确写法console.log(el.offsetWidth);el.classList.add(&apos;test&apos;); 布局抖动： 12345678910// 错误写法for (let i = 0; i &lt; list.length; i++) &#123; list[i].style.width = el.offsetWidth + &apos;px&apos;;&#125;// 正确写法let width = el.offsetWidth;for (let i = 0; i &lt; list.length; i++) &#123; list[i].style.width = width + &apos;px&apos;;&#125; 性能分析chrome 开发者工具附上开发者工具文档 network 中请求的 waterfall 列详解： Queueing。 浏览器在以下情况下对请求排队： 存在更高优先级的请求。 此源已打开六个 TCP 连接，达到限值。 仅适用于 HTTP/1.0 和 HTTP/1.1。 浏览器正在短暂分配磁盘缓存中的空间Stalled。 请求可能会因 Queueing 中描述的任何原因而停止。DNS Lookup。 浏览器正在解析请求的 IP 地址。Proxy negotiation。 浏览器正在与代理服务器协商请求。Request sent。 正在发送请求。ServiceWorker Preparation。 浏览器正在启动 Service Worker。Request to ServiceWorker。 正在将请求发送到 Service Worker。Waiting (TTFB)。 浏览器正在等待响应的第一个字节。 TTFB 表示 Time To First Byte（至第一字节的时间）。 此时间包括 1 次往返延迟时间及服务器准备响应所用的时间。Content Download。 浏览器正在接收响应。Receiving Push。 浏览器正在通过 HTTP/2 服务器推送接收此响应的数据。Reading Push。 浏览器正在读取之前收到的本地数据。 Performance 面板：结合 FPS、CPU、Main等来分析页面存在什么性能问题。 蓝色(Loading)：网络通信和 HTML 解析 黄色(Scripting)：JavaScript执行 紫色(Rendering)：样式计算和布局，即重排 绿色(Painting)：重绘 灰色(other)：其它事件花费的时间 白色(Idle)：空闲时间 注意 FPS 中的红色区块和 Main 中事件右上角的小三角，它们都表示对应的事件可能存在性能问题。 总结浏览器渲染网页的过程涵盖了很多内容，这其中的每一块内容都值得我们花费更多的精力深入理解。基于底层和原理的探索，能让我们更快地在工作中定位问题，找到更好更快的解决方案，节约项目团队的开发和执行成本，或许仅仅是某个微小的进步与改变，都能给团队带来不可估量的效益与价值。同时，建立在对浏览器原理的理解上，我们能更好地与运维、后端同事进行跨职业的沟通，进一步提升工作效率，也可以更容易的寻找到项目优化的突破点，提升用户体验。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"chrome","slug":"chrome","permalink":"https://gromimiss.github.io/tags/chrome/"},{"name":"优化","slug":"优化","permalink":"https://gromimiss.github.io/tags/优化/"}]},{"title":"移动端的一些小问题","date":"2019-04-10T16:00:00.000Z","path":"2019/04/11/autofocus/","text":"刚接到一个需求，只是一个很简单的页面，只包含一个输入框，却遇到了挺多的问题，有些甚至还没解决，在这里记录一下。 问题： autofocus 在 ios 上有什么解决方案吗 尝试了网上的一些解决方案，发现并不起作用。 placeholder 设置不生效（在公司原生 APP 上） 因为要在 input 中有值并且聚焦状态时显示删除 icon，所以需要去判断是否聚焦 1&lt;input type=\"text\" @focus=\"focus\" @blur=\"blur\" autofocus=\"autofocus\"/&gt; 12345678910111213data() &#123; return &#123; isFocus: false &#125;&#125;,methods: &#123; focus() &#123; this.isFocus = true; &#125;, blur() &#123; this.isFocus = false; &#125;&#125; 但是这样会有一个问题：在 ios 上 autofocus 在页面上并不会产生聚焦的效果，但是会触发 focus 事件，所以它也会显示 icon。 刚开始打算用以下方式解决的： 1&lt;input type=\"text\" @focus=\"focus\" @blur=\"blur\" autofocus=\"autofocus\"/&gt; 12345678910111213141516171819data() &#123; return &#123; isFocus: false, isFirstEnter: true &#125;&#125;,methods: &#123; focus() &#123; const isIOS = !!navigator.userAgent.match(/(i[^;]+;( U;)? CPU.+Mac OS X/); if (IOS &amp;&amp; this.isFirstEnter) &#123; this.isFirstEnter = false; return; &#125; this.isFocus = true; &#125;, blur() &#123; this.isFocus = false; &#125;&#125; 但是试了之后发现 ios 在第一次用户点击触发页面上的聚焦效果时，并不会触发 focus 事件，这就导致只能通过判断系统决定是否要设置 autofocus了。 1&lt;input type=\"text\" @focus=\"focus\" @blur=\"blur\" :autofocus=\"isIOS ? 'autofocus' : undefined\"/&gt; 123456789data() &#123; return &#123; isFocus: false, isIOS: false &#125;&#125;,created() &#123; this.isIOS = !!navigator.userAgent.match(/(i[^;]+;( U;)? CPU.+Mac OS X/);&#125; 自此，就算基本的解决了这个问题，但是从根本上来讲，还是应该解决在 ios 上不 autofocus 的问题，没了这个问题也就不会有之后的一系列问题了，目前是考虑可以用 div 去模拟一个 input，这样的话样式，聚焦就都可控了，后期优化再补上。 因为这个页面是在公司原生 APP 上使用的，修改之后需要返回到之前的页面，再让之前的页面的数据能够刷新，这是两个页面，返回不会刷新页面，所以也没法去触发更新数据,目前是进入修改页B前会关闭当前页A，修改完成后关闭B打开A，但是这样会有一个问题——这样是一个打开新页面的效果，而不是一个返回的效果，在移动端打开一个页面时从左到右的切换效果，而返回则是从右到左的切换效果，并且不会有刷新的问题，目前在想有没有什么两个页面间的通讯方式。 localStorage：因为是完全独立的两个页面，所以 localStorage 无效window.openerpostMessage 但是是切换页面，不是两个窗口，不知道还可不可行","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"移动端","slug":"移动端","permalink":"https://gromimiss.github.io/tags/移动端/"}]},{"title":"移动端——吸顶滚动","date":"2019-04-10T16:00:00.000Z","path":"2019/04/11/h5Scroll/","text":"最近接到一个需求，要求页面滚动到一定区域时，tab悬浮，换下面的区域滚动，现在记录下当时做的过程中遇到的问题。 需求 当滚动到一定位置时，设置内容区滚动 刚看到这个需求的时候脑子里第一个想法就是来判断 scrollTop，当它大于 banner 的高度时，禁止容器滚动，设置下面的 content 区域滚动，这样子 tab 对应的两个 content 区域都有自己的滚动高度，也不需要存储滚动位置。在浏览器，短屏设备上都没问题，但是测试一下子就发现了一个问题：当滚动正好超过 banner 高度的时候，因为长屏已经显示了所有的内容，用户就会直接往上拉，这时会发现，没办法滚动了。这其实就是因为刚吸顶的那一下，容器禁止滚动了，下面的内容区也还没有触发scroll事件，就开始往上滑，以至于容器滚动和下面内容区滚动都触发不了。 当滚动到一定位置时，将 tab 设为 fixed，并增加一个和 tab 相同高度的占位元素，当 tab 固定位置时，此元素显示，滚动回来时再重置。 注意点1：对内容区设置 marginTop 会导致页面滚动后 scrollTop 会往后回退，猜测是引起了重新计算 scrollTop 注意点2：tab 切换时内容区的滚动条位置不变以至于滚动位置异常，所以需要去记录滚动条的位置。若在 scroll 事件中，将 scrollTop 保存会导致浏览器重新计算 scrollTop，就会出现往上回退的问题。所以要使用节流，50ms 中只触发一次保存。并且设置 scrollTop 时要记得使用 nextTick。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"移动端","slug":"移动端","permalink":"https://gromimiss.github.io/tags/移动端/"}]},{"title":"记录 OAuth 机制","date":"2019-03-28T16:00:00.000Z","path":"2019/03/29/oauth/","text":"之前在 H5 上使用过微信的网页授权，但只是按着文档中写的流程完成了一下，并没有去注意文档中写的 OAuth 机制，最近面试被提问到，所以就去了解了下，在此记录。（本文是看了阮一峰的 oAuth 2.0 记录的，原文在这里）。 为什么使用 OAuthOAuth 可以用来解决第三方应用获取服务提供商的资源时所需的权限问题。 第三方应用获取服务提供商的资源，有以下两种方式： 普通方式：将服务提供商上的用户名和密码告诉第三方应用，这样就会有以下几个问题： 第三方应用会保存用户的密码，导致安全问题 服务供应商需要部署密码登录，但是单纯的密码登录并不安全 第三方应用拥有了获取用户存在服务供应商上所有资料的权利，但是用户并不能限制第三方应用获得授权的范围和有效期 用户只有修改密码，才能收回权利，但是若这样做，会导致其他获得了用户授权的第三方应用也都全部失效 只要其中一个第三方应用程序被破解，就会导致用户密码泄露，以及所有的资料被泄露 OAuth 方式：它会通过一个授权服务器，让第三方应用安全可控的获取用户的授权，和服务提供商进行互动 OAuth 的大概思路在第三方应用和服务提供商之间设置一个授权服务器，第三方应用不能直接登录到服务提供商，而是只能登录到授权服务器，通过得到的令牌去获取服务供应商上用户的资料，并且用户可以指定授权令牌的权限范围和有效期。 OAuth 的四种授权方式 授权码模式 是功能最完整、流程最严密的授权模式，通过第三方应用的后台服务器与服务提供商的授权服务器进行互动。 步骤： 用户访问第三方应用 第三方应用将用户导向授权服务器 让用户选择是否授权，若用户同意授权，则授权服务器会重定向到第三方应用事先指定的重定向 uri 上，并且在 uri 的后面加上参数授权码 第三方应用收到授权码，带着应用的唯一标识、密钥、授权码以及重定向的 uri，向授权服务器申请令牌（在第三方应用的后台和服务器上完成，用户不可见） 授权服务器核对授权码和 uri，确认无误后，向第三方应用返回 access token 和 refresh token 隐式授权模式 不通过第三方应用的服务器，直接在浏览器中向认证服务器申请令牌，跳过了授权码这个步骤，令牌对访问者是可见的。 步骤： 第三方应用将用户导向授权服务器 用户选择是否给予第三方应用授权 若用户给予授权，则授权服务器会将用户导向之前第三方应用指定的重定向 uri，并在 uri 的 hash 部分包含了 access_token 浏览器向服务供应商发出请求，服务供应商返回一个网页，其中包含了可以获取 hash 值中的令牌 浏览器执行上一步获得的脚本，提取出令牌，将令牌发给客户端 密码模式 用户向第三方应用提供自己的用户名和密码，第三方应用使用这些信息向服务提供商索要授权，但不能存储密码，通常在用户对第三方应用高度信任的时候使用。 客户端认证模式 第三方应用以自己的名义，向服务提供商进行认证，这种模式下，用户直接在第三方应用注册，第三方应用以自己的名义要求服务提供商提供服务，其实是不存在授权问题的 更新令牌若第三方应用的 access_token 过期，则要使用之前返回的 refresh_token 来重新申请一个新的 access_token。 微信授权流程微信公众号就是通过 OAuth2.0 机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权 access_token），通过网页授权的 access_token 进行授权后接口调用，如获取用户基本信息。 若开发者有多个公众号，或者在公众号、移动应用之间有统一用户账号的需求，需要前往开发者平台绑定公众号后，利用 UnionID 机制来满足上述需求：开发者拥有多个移动应用、公众账号，可通过获取用户基本信息中的 UnionID 来区分用户的唯一性，因为同一用户，对同一个微信开发平台下的不同应用 unionid 是相同的。 微信授权步骤如下： 引导用户进入授权页面同意授权，（传入 scope、redirect_url、appid、response_type、state）调用接口后会跳转到传入的 redirect_url，url 的后面会带上 code 和 state 参数 code作为换取 access_token 的票据，每次用户授权带上的 code 都不一样，只能使用一次，5分钟未使用就会自动过期，通过 code 换取网页授权 access_token 和 openid（要传入 appid、secret、code、grant_type） 若需要，可以刷新网页授权 access_token，避免过期（使用之前获取到的 refresh_token 进行刷新，它的有效期是 30 天） 通过网页授权 access_token 和 openid 获取用户基本信息（若 scope 为 snsapi_userinfo，通过传入参数 open_id 和 access_token拉取用户信息，包含了 unionid） scope 有两种：snsapi_base 静默授权，可以获取 openid，用户感知不到，能感知到的就是直接进入了回调页，snsapi_userinfo 是用来获取用户的基本信息的，但是这种授权需要用户手动同意，并且如果已经关注公众号的用户，如果从公众号的会话或者是自定义菜单中进入本公众号的网页授权页，即便 scope 是 snapi_userinfo 也是静默授权，用户无感知。","comments":true,"tags":[{"name":"OAuth","slug":"OAuth","permalink":"https://gromimiss.github.io/tags/OAuth/"},{"name":"微信授权","slug":"微信授权","permalink":"https://gromimiss.github.io/tags/微信授权/"}]},{"title":"自己手写一个 Promise","date":"2019-03-22T16:00:00.000Z","path":"2019/03/23/promise/","text":"Promise 作为异步回调地狱的解决方案，在项目中用到的特别多。但是之前从来没有去研究过它的实现原理，这次就想对照着规范一步步的实现，加深对 Promise 的理解，也可以了解到更多可能平常项目中很少遇到的情况。 Promise/A+ 规范：规范原文在这里。 术语 promise 是一个符合这个规范的拥有 then 方法的对象或是函数 thenable 是声明了 then 方法的对象或函数 value 可以是任意合法的 js 值（包括了 undefined，thenable 对象或者是一个 promise） exception 是使用 throw 语法抛出的一个值 reason 是指明为什么 promise 被 rejected 的一个值 要求 Promise 状态：一个 promise 必须是 3 个状态中的一个（pending，fullfilled，rejected） 当 pending，一个 promise 可能转变为 fullfilled 或是 rejected 当 fulfilled，一个 promise 不能再转变成其他状态，并且会得到一个也不能改变的 value（不包括对象的属性改变） 当 rejected，一个 promise 不能再转变成其他状态，并且会得到一个也不能改变的 reason（不包括对象的属性改变） then 方法：一个 promise 需要提供一个 then 方法去访问它当前或是最终的 value 或 reason，它接受两个参数 onFulfilled 和 onRejected onFulfilled 和 onRejected 都是可选的参数，当它们不是一个函数或者没有传入时，都会被包装为一个函数 若 onFulfilled 是一个函数，它必须在 promise 为 fulfilled 状态后被调用，并且将 promise 的 value 作为它的第一个参数，并且不能被调用多次 若 onRejected 是一个函数，它必须在 promise 为 rejected 状态后被调用，并且将 promise 的 reason 作为它的第一个参数，并且不能被调用多次 在下一个 stack 中被调用 then 在相同的 promise 上可能会被多次调用（定义一个 promise， 在这个 promise 上多次调用 then），当 promise 是 fulfilled 状态时，会按绑定时 then 的顺序来依次调用 onFulfilled 回调；当 promise 是 rejected 状态时，也会按绑定时 then 的顺序来依次调用 onRejected 回调 1234567let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(200); &#125;, 200);&#125;);p1.then(data =&gt; console.log(data));p1.then(data =&gt; console.log(data)); // 执行多次会被存放在回调列表中 then 必须返回一个 promise 1promise2 = peomise1.then(onFulfilled, onRejected) 若 onFulfilled 或者 onRejected 返回一个值 x，则执行 promise 解决程序 若它们抛出一个异常 e 则 promise2 必须将 e 作为原因被 rejected 如果 onFulfilled 不是一个函数并且 promise1 已经 fulfilled，promise2 必须用 promise1 中的值作为参数传给 promise2 中的 then 1234567let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(200); &#125;, 200);&#125;);let p2 = p1.then(2);p2.then(data =&gt; console.log(data)); // 200 如果 onRejected 不是一个函数并且 promise1 已经 rejected，promise2 必须用 promise1 中的错误原因作为参数传给 promise2 中的 then promise 解决程序：promise 解决程序会将 promise 和 x 作为参数，若 x 是一个 thenable 对象，它会尝试让 promise 采用 x 的状态，不然就会用 x 来完成 promise（thenable 允许我们可以实现 promise 间的互操作，只要它们提供 Promise/A+ 规范的 then 方法，并且使用合理的方法同化不一致的实现）。 若 promise 和 x 是同一个对象，则将一个 TypeError 作为 promise reject 的原因 1234567891011let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(200);&#125;);let p2 = p1.then(data =&gt; &#123; return p2;&#125;);p2.then(data =&gt; &#123; console.log(data)&#125;, err =&gt; &#123; console.log(err);&#125;); // 会执行 onRejected 回调，打印 TypeError: Chaining cycle detected for promise #&lt;Promise&gt; 若 x 是一个 promise 并且还在 pending 状态时，会继续验证 x 中的值 y，递归调用 resolution(promise, y)，直到最后是一个不为对象或函数的值，而若 x 已经是 fulfilled 或 rejected 时，则说明 x 的值肯定为一个最后的值了，就将 promise2 的 resolve 传递给 x.then 的 onFulfilled，promise2 的 reject 传递给 x.then 的 onRejected（由 x 去调用 promise2 的处理） 若 x 是一个对象或者是函数 若 x.then 的结果抛出一个异常 e，则将 e 作为参数 reject promise 若 x.then 是一个函数，则将 x 作为 this ，resolvePromise 作为第一个参数，rejectPromise 作为第二个参数执行，当 resolvePromise 将 y 作为参数被调用时， 执行 resolution(promise, y)，当 rejectPromise 将 r 作为参数被调用时，将 r 作为参数 reject promise，并且 resolvePromise 和 rejectPromise 中只有一个会被调用，晚调用的会被忽略，若 x.then 调用时抛出了异常，resolvePromise 和 rejectPromise 会被忽略，将异常作为参数 reject promise 若 x 不是一个对象或者函数，则直接fulfill promise 基本的 Promise根据上面 Promise/A+ 来写一个规范的 Promise。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144// 定义三个常量状态const PENDING = 'pending';const RESOLVED = 'resolved';const REJECTED = 'rejected';function Promise(fn) &#123; this.state = PENDING; this.value = null; this.resolvedCbs = []; this.rejectedCbs = []; // 调用在 Promise 的构造函数中传入的函数：所以 Promise 传入函数中的代码是立即执行的 try &#123; fn(resolve, reject); &#125; catch (err) &#123; reject(err); &#125; let self = this; function resolve(value) &#123; if (value instanceof Promise) &#123; return value.then(resolve, reject); &#125; // 在下个事件循环中改变state、value的值，并且执行之前在等待状态时未调用的函数 setTimeout(() =&gt; &#123; if (self.state === PENDING) &#123; self.state = RESOLVED; self.value = value; self.resolvedCbs.map(cb =&gt; cb(self.value)); &#125; &#125;, 0); &#125; function reject(value) &#123; setTimeout(() =&gt; &#123; if (self.state === PENDING) &#123; self.state = REJECTED; self.value = value; self.rejectedCbs.map(cb =&gt; cb(self.value)); &#125; &#125;, 0); &#125;&#125;// 1. then 中传入的函数就是需要在状态变为完成后调用的（即回调）// 2. 若状态还是等待中，会在当前 promise 对象中缓存 resolved/rejected 回调// 回调里面会将 value 作为参数传给传入的函数并执行传入的函数// 执行解决程序// 再返回一个新的promise对象// 3. 若状态已经是完成，则返回一个 promise 对象，promise 中会在下一个事件循环执行传入的函数，最终 resolve/reject 出结果Promise.prototype.then = function(onFulfilled, onRejected) &#123; let self = this; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled: v =&gt; v; onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125;; if (self.state === PENDING) &#123; const promise2 = new Promise((resolve, reject) =&gt; &#123; self.resolvedCbs.push(() =&gt; &#123; try &#123; const x = onFulfilled(self.value); // 兼容不同的Promise，如JQuery和ES6的 _resolutionProcedure(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); self.rejectedCbs.push(() =&gt; &#123; try &#123; const x = onRejected(self.value); _resolutionProcedure(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); return promise2; &#125; if (self.state === RESOLVED) &#123; return (promise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(self.value); _resolutionProcedure(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;)); &#125; if (self.state === REJECTED) &#123; return (promise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(self.value); _resolutionProcedure(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;)) &#125;&#125;function _resolutionProcedure(promise2, x, resolve, reject) &#123; // 防止循环引用 if (promise2 === x) return reject(new TypeError('Error')); if (x instanceof Promise) &#123; x.then(value =&gt; &#123; _resolutionProcedure(promise2, value, resolve, reject); &#125;, reject); &#125; // 是否已经调用过函数 let called = false; if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call( x, val =&gt; &#123; if (called) return; called = true; _resolutionProcedure(promise2, val, resolve, reject); &#125;, e =&gt; &#123; if (called) return; called = true; reject(e); &#125; ) &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;// 所以若 then 中有 reject 回调，则 catch 将不会被触发Promise.prototype.catch = function(onRejected) &#123; this.then(null, onRejected);&#125;; 检验检验自己手写的 Promise 是否写的规范，可以使用 promises-aplus-tests。 下载 promises-aplus-tests 1npm i promises-aplus-tests -g 在 promise.js 中添加一个方法 12345678Promise.deferred = Promise.defer = function() &#123; let defer = &#123;&#125;; defer.promise = new Promise(function(resolve, reject) &#123; defer.resolve = resolve; defer.reject = reject; &#125;); return defer;&#125;; 在项目中执行命令 1promises-aplus-tests promise.js Promise 上的其他方法添加在类上的一些方法。 Promise.resolve返回一个给定值解析后的 Promise 对象。 12345Promise.resolve = function(value) &#123; return new Promise(resolve =&gt; &#123; resolve(value); &#125;);&#125; Promise.reject返回一个带有拒绝原因的 Promise 对象。 12345Promise.reject = function(reason) &#123; return new Promise((resolve,reject) =&gt; &#123; reject(reason); &#125;);&#125; Promise.all当 Promise.all 传入的 promises 数组中都成功的时候才会执行 onFulfilled 回调，并且回调中会带一个参数 —— promises 解析后的值组成的数组（按传入 promises 的顺序），只有其中有一个 promise 失败，就会执行 onRejected 回调。 12345678910111213141516Promise.all = function(promises) &#123; return new Promise(function(resolve, reject) &#123; let result = []; let count = 0; function done(i, data) &#123; // 按存入的 promise 顺序存放结果 result[i] = data; if (++count === promises.length) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(done.bind(this, i), reject); &#125; &#125;); &#125;; Promise.race当其中有一个 promise 成功或失败就会返回，当多个接口都不稳定时，可取多个接口，谁先回来用谁的。 1234567Promise.race = function(promises) &#123; return new Promise(function(resolve, reject) &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;);&#125;; 总结Promise 中的 resolutionProcedure 还是挺绕的，有的时候真的是想不到这么多情况，所以还是需要多思考多学习，不断的加深印象，当理解之后使用它就变得特别轻松了。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"异步","slug":"异步","permalink":"https://gromimiss.github.io/tags/异步/"}]},{"title":"Webpack 4 总结","date":"2019-03-18T16:00:00.000Z","path":"2019/03/19/webpack/","text":"以前用的 webpack 版本还是 2.6.1，现在 webpack 都更新到 4.29.6 了。所以最近学习了下 webpack 4，并且动手使用了下，其中改变还是挺大的，就此作出一个总结。 背景为什么要使用 webpack？随着功能点的增加，浏览器本身又不提供模块管理的机制，为了简化开发的复杂度，提升开发效率，模块化、CSS 预处理器、各种框架层出不穷，并且还有 JS 的一些还没被浏览器支持的新特性，所以一整个项目里会包含着一大堆的 JS 代码和依赖包，前端项目越来越臃肿，越来越难以维护，而这个时候 webpack 出现了。 什么是 webpackwebpack 可以看做是一个模块打包机，它会分析你的项目结构，将一堆文件中的每个文件都作为一个模块，找出他们的依赖关系，将 js 模块以及其他一些浏览器不能直接运行的拓展语言（typescript、sass等）打包为合适的格式供浏览器来使用。 它拥有着庞大的社区，可以用来进行代码转换、文件优化、代码分割、模块合并、自动刷新、代码校验、自动发布等。 与其他工具的对比Grunt/Gulp: 都属于 Task Runner，一般用来优化前端工作流程，比如自动刷新页面、压缩 css、压缩 js、编译 sass 等。它的工作方式是：在一个配置文件中，指明对某些文件进行类似编译、组合、压缩等任务的具体步骤，之后工具就会自动完成这些任务。 Webpack: 是一种模块化的解决方案，通过项目中的依赖关系产出最后的静态资源，它能拆分依赖树并按需加载，上面工具完成的工作它都可以胜任。 webpack 的使用核心概念 Entry：入口，作为 webpack 构建的第一步来找出依次的依赖关系 Module：模块，在 webpack 中一切皆模块，一个模块对应着一个文件，webpack 会通过 Entry 开始递归找出所有依赖的模块 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并及分割 Loader：模块转换器，将模块原内容按需转换成新内容，它能让 webpack 能够去处理那些非 js 文件 Plugin：扩展插件，在构建流程中的特定时机注入扩展逻辑来改变构建结果 Output：输出结果，在经过一系列处理并得到最终想要的代码后输出结果，该属性告诉 webpack 在哪里输出结果并且如何命名这些模块 Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module，每找到一个 Module，就会根据配置的 Loader 去找对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 会被分到一个 Chunk。最后 webpack 会将所有 Chunk 转换成文件输出，在整个流程中 webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 基本配置 webpack 安装 1npm i --save-dev webpack webpack-cli 执行 webpack 可以通过两种方式： npx 可以直接运行 node_modules/.bin目录下面的命令 通过配置 package.json 中的 script: { “build”: “webpack”} 相关配置 mode: 模式，有两种（production development），默认是 production，它会告知 webpack 使用什么模式的内置优化 entry: 打包的入口文件 单入口(只打包一个文件)： 1entry: './src/index.js' 多入口打包成多个文件： 1234entry: &#123; index: './src/index.js', base: './src/base.js'&#125; 多入口打包成一个文件： 1entry: ['./src/index.js', 'jquery'] // 相当于 entry: &#123; main: ['./src/index.js', 'jquery']&#125; output: 输出配置filename 中的 name 是 entry 中对象的属性名，若 entry 是字符串或者是数组，则默认会是 main。 在这里需要讲一下 hash、chunkhash、contenthash 的区别： hash： 根据打包后的文件内容计算出来的 hash 值，它跟整个项目相关，所以所有的文件被打包出来都用的同一个 hash 值，这也就意味着项目中任何一个文件的改动都会导致 hash 值改变，导致缓存失效。由于打包出来的 runtime 运行时文件会改变，所以会导致 hash 值也因此改变。 chunkhash：根据不同的入口进行依赖解析，构建对应的 chunk，生成对应的 hash 值。我们往往会把公共库和业务代码分开，单独打包，这样业务代码的改动就不会影响到公共库的 hash 值受影响。 contenthash：由文件内容产生的 hash 值。我们的入口文件中往往依赖了 css 文件，若按 chunkhash 来打包，那么 css 和 js 其实用的是同一个 hash 值，这就导致 css 没有改动的情况下也会跟着受影响，这个时候就可以将 css 抽离出来并使用按 css 文件内容的计算产生的 hash 值。 12345output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'build') // 打包后的文件的输出目录 publicPath: '' // 当资源托管到 CDN 时可使用&#125; module: 在 module 中可以配置 loader，loader 的执行顺序是从右向左，从下向上的；也可以配置 noParse，让 Webpack 忽略对部分没采用模块化文件的递归解析和处理，比如 jqeury、chartJS 等没有采用模块化标准的库。 devServer：开发服务器的配置 123456devServer: &#123; port: 8080, // 端口号 progress: true, // 是否显示进度条 contentBase: './build', compress: true, // 启动服务器的 gzip 压缩&#125; externals：指定某些包是外部引入的，不需要打包。它和 noParse 的区别是：noParse 虽然不会对指定的库进行处理解析，但还是会被打包进最后的输出文件中。 devtool：增加映射文件，帮我们调试源代码 source-map：会单独生成一个 sourcemap 文件，出错了会显示当前报错的行和列 eval-source-map：不会产生单独的文件（集成到源文件中），但是可以显示行和列 cheap-module-source-map：不会显示列，会生成一个单独的映射文件，没有调试的功能，产生后可以保留起来以便之后调试 cheap-module-eval-source-map：不会产生文件，集成在打包文件中，会定位到行，不会定位到列 inline-source-map：生成一个 DataUrl 形式的 sourcemap 文件 resolve：解析第三方包 12345678910resolve: &#123; modules: [path.resolve(__dirname, 'node_modules')], // 只需要从这个目录中查找第三方包 extensions: ['.js', '.css'], // 若导入时没有添加扩展名，会根据这里的配置顺序去查找文件 alias: &#123; // 别名 bootstrap: 'bootstrap/dist/css/bootstrap.css' &#125;, // 按数组中的顺序查找 package.json // jsnext:main 指采用 ES6 语法的代码入口文件 mainFields: ['jsnext:main', 'browser', 'main'] &#125; optimization：优化 比如：多页应用可以将公共的代码抽离出来 123456789101112131415161718optimization: &#123; splitChunks: &#123; // 分割代码块 cacheGroups: &#123; // 缓存组 common: &#123; // 公共的代码 chunks: 'initial', minSize: 0, minChunks: 2 // 引入 2 次及以上就被抽离 &#125;, vendor: &#123; priority: 1, // 先抽离第三方模块 test: /node_modules/, chunks: 'initial', minSize: 0, minChunks: 2 &#125; &#125; &#125;&#125; watch: 在初始构建之后，webpack 将继续监听任何已解析文件的更改，若有更新就重新打包 12345watch: true,watchOptions: &#123; aggregateTimeout: 300, // 当第一个文件更改，会在重新构建前增加延迟，它允许 webpack 将这段时间内进行的任何其他更改都聚合到一次重新构建里 poll: 1000 // 每秒检查一次变动&#125; 常用的 loaderloader 一般都是单个 loader 负责单一的功能。 expose-loader：把一个模块暴露为一个全局变量 expose-loader?$!jquery file-loader：解析图片地址，会将图片从原位置拷贝到目标位置并且修改原引用位置 url-loader：可以在文件较小的时候，直接变成 base64 字符串内嵌到页面中（体积会比源文件大 1/3，但是可以减少 http 请求）。当文件大于阈值时，会使用 file-loader 进行处理。 12345678910&#123; test: /\\.(png|jpg|gif|bmp|svg)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 9 * 1024, outputPath: 'images/'// 输出目录 &#125; &#125;,&#125; html-withimg-loader：将 html 中引用的图片地址替换为实际的路径 1234&#123; test: /\\.html$/, use: 'html-withimg-loader'&#125; css-loader：webpack 本身只能识别 js 文件，需要另外的 loader 来解析 @import/require 导入 css的代码 sass-loader：把 sass 解析为 css style-loader：将 css 内容用 js 里的字符串存储起来，网页执行 js 时通过 dom 操作动态的将 css 插入到 html 的 head 中 postcss-loader：使用 PostCSS 加载和转译 CSS 文件，可以用来添加浏览器前缀（当然不止这个功能） 1234567891011121314&#123; test: /\\.css$/, use: [ 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [ require('autoprefixer') ] &#125; &#125; ]&#125; babel-loader：将 ES6 语法转换成浏览器都支持的 ES5 1234567891011&#123; test: /\\.js$/, exclude: /node_modules/, // 排除不需要转译的目录 use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'], plugins: ['@babel/plugin-transform-runtime'] // 引入 babel runtime 作为一个独立模块，来避免重复引入（若不使用，babel 会自动对每个文件 runtime 注入） &#125; &#125;&#125; babel 中的plugins： - @babel/core: 核心 api - @babel/preset-flow: 删除静态类型注释 - @babel/cli: 允许你从终端使用 babel - @babel/preset-env: 将 ES6+ 转换为 ES5，默认转换语法，不转换新的 API - @babel/polyfill: 会污染全局环境，在不支持某些 API 的浏览器中添加全局函数，比如像 Array.from 或 Object.assign，它是需要在源代码之前运行的 polyfill，下载时要 --save，可以配合 useBuiltIns 选项，当它设置为 usage 时，Babel 将检查你的所有代码，以查找目标环境中缺少的功能，并仅包含所需的 polyfill - @babel/runtime: 只包含 helpers，要和 @babel/plugin-transform-runtime 一起用，使用 babel 转换代码的时候，可能会在多个模块用到新特性，比如多个地方使用了 class，那用到 class 的每个模块都会注入一段 _createClass 的代码，导致代码冗余。使用 @babel/plugin-transform-runtime 会将原本注入模块文件中的辅助函数替换为一条导入语句：`var _createClass = require(&apos;babel-runtime/helpers/_createClass)`，所以需要安装 @babel/runtime 依赖。 presets: - ES2015 - ES2016 - ES2017 - Env: 包含当前所有 ECMAScript 标准里的最新特性，包含了 ES2015, ES2016, ES2017 - stage0: 还不确定是否会被定为标准 - stage1: 值得被纳入标准的特性 - stage2: 已被起草将被纳入标准里的特性 - stage3: 已定稿，各大浏览器厂商和 Node.js 社区已开始着手实现 - stage4: 在接下来的一年里将会被加入标准里 eslint-loader: 校验 js 代码 vue-loader: 解析 vue 文件，将其中的 script、style、template 提取出来，交给对应的 loader 去处理（它会根据 lang 特性以及你 webpack 配置中的规则自动推断出要使用的 loader） 常用的 plugin html-webpack-plugin: 自动产出 html 文件，配置了 title，则可以在模板文件的 title 标签中添加 &lt;%= htmlWebpackPlugin.options.title %&gt; 1234567891011new HtmlWebpackPlugin(&#123; template: './src/index.html', // 模板文件 filename: 'index.html', // 产出 html 的文件名称 title: 'hello world', // html 中 title 标签存放的标题 hash: true, // 资源文件后会加一串 hash 值，若引入的资源文件有更新，则会重新加载，而不是从缓存中取 chunks: ['index', 'vendor'], // 在产出的 html 中引入的代码块 minify: &#123; // 对 html 做压缩处理 removeAttributeQuotes: true, // 删除属性的双引号 collapseWhitespace: true // 一行显示 &#125;&#125;) mini-css-extract-plugin: 将 css 抽离出来输出到一个文件中，若要抽离成多个可以多 new 几个（原来都是用 extract-text-webpack-plugin，但如今这个插件和 webpack 4 不太兼容，会报错 Error: Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead） 12345678910111213141516module: &#123; rules: [ &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader' ] &#125; ]&#125;,plugins: [ new MiniCssExtractPlugin(&#123; filename: 'index.css' &#125;)] optimize-css-assets-webpack-plugin：压缩 CSS 12345optimizations: &#123; minimizer: [ new OptimizeCss() ]&#125; uglifyjs-webpack-plugin: 压缩 js 123456789optimizations: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, // 是否使用缓存 paraller: true, // 是否并发打包 sourceMap: true // 是否添加映射文件 &#125;) ]&#125; webpack.ProvidePlugin: 在每个模块中注入一个变量 123new webpack.ProvidePlugin(&#123; $: 'jquery'&#125;) clean-webpack-plugin：在打包之前删除原先打包的文件 123new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns: path.resolve(__dirname, 'build')&#125;) copy-webpack-plugin: 将某文件夹复制一份到打包目录下 1234new CopyWebpackPlugin([&#123; from: './doc', to: './doc'&#125;]) webpack.BannerPlugin: 在打包后的 js 文件中添加版权声明 1new webpack.BannerPlugin('hello') webpack.DefinePlugin: 定义全局变量 123new webpack.DefinePlugin(&#123; DEV: JSON.stringify('production')&#125;) webpack.DLLPlugin: 抽离第三方库（比较稳定、不会轻易改变），这样在浏览器中就只会在第一次加载，之后都会缓存，它只需要初构建的时候打包一次(经测试速度快了 2 倍多，但就是两个地方不好：一是需要自己手动在模板文件中引入第三方库，二则是若第三方包有更新，还要自己手动再去执行第三方库的打包，有时候可能会忘记)，而 commons-chunk-plugin 主要用来提取公共包，它每次构建都会重新打包，就会增加编译时间（现使用 splitChunks） 在另一个打包配置文件下： 1234567891011121314entry: &#123; vendor: ['vue', 'vuex', 'vue-router']&#125;,output: &#123; filename: '_dll_[name].js', path: path.resolve(__dirname, 'build'), library: '_dll_[name]' // 产生的变量名&#125;,plugins: [ new webpack.DLLplugin(&#123; name: '_dll_[name]', // name === library path: path.resolve(__dirname, 'build', 'manifest.json') // 输出的清单目录 &#125;)] 在主打包配置文件中引入打包出来的第三方库： 123new webpack.DLLReferencePlugin(&#123; // 先去清单中找变量，找不到再去真正打包 manifest: path.resolve(__dirname, 'build', 'manifest.json')&#125;) happypack：可以实现多线程打包(项目大的时候可以使用，项目小的时候可能打包时间反而会更久，因为分配线程的过程中也会浪费一些性能) 1234567891011121314151617181920module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: 'Happypack/loader?id=js' &#125; ]&#125;new Happypack(&#123; id: 'js', use: [&#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' ] &#125; &#125;]&#125;) webpack.HotModuleReplacementPlugin: 热更新插件 1234devServer: &#123; hot: true&#125;,new webpack.HotModuleReplacementPlugin() webpack.HashedModuleIdsPlugin：将模块 ID 的命名方式改为基于文件内容的 hash 值。为了缓存不经常变动的代码，我们一般会把第三方库另外输出到一个 vendor chunk 中，但如果只是分离 vendor chunk，在 vendor chunk 中会包含 webpack runtime 部分代码，导致即便没有更改第三方库 vendor 的 chunkhash 值依然会改变，这个时候就需要再单独生成一个 manifest chunk，把 webpack runtime 部分代码给单独抽离出来。但是我们发现如果后来在入口文件中又新增了一个模块，这个时候 vendor chunkhash 值又改变了，因为模块 ID 是以顺序来命名的，如果从中插入了一个模块就会导致后面的模块 ID 都发生了变化导致 vendor chunkhash 也因此发生改变，而 webpack.HashedModuleIdsPlugin 就是为了解决这个问题的，它会将模块 ID 以内容 的 hash 值来命名。（看了下 webpack 4 默认会以文件路径作为模块的 id，所以不需要使用此插件） scope hostingscope hosting: 作用域提升，在 webpack 3 中新增的功能，它会分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中去，并且只有那些被引用了一次的模块才能被合并。 mode 模式使用 production 就可以开启作用域提升。 123456789// a.jsexport default 'hello';// b.jsimport str from './a.js';console.log(str);// 编译后console.log('hello'); 懒加载vue 异步组件 + webpack 代码分割 + import() 实现 vue 路由懒加载，详见官方。 import(): 属于 es6 草案中的语法，通过 jsonp 实现动态加载，会返回一个 Promise 对象 123import('./src/index.js').then(data =&gt; &#123; console.log(data.default); // ./src/index.js' 中导出的数据&#125;) 适用于 vue 项目的优化配置将开发环境与生产环境分离： 开发时产生的 debug 或者是测试的代码不应出现在生产环境中 将页面部署到服务器时，会对代码进行各种优化，破坏代码可读性，不利于 debug 等工作 数据源差异，开发时，读取的往往是本地 mock 的数据 配置DllPlugin + DllReferencePlugin 和 splitChunks 可以一起使用，通过 splitChunks 把公共的部分抽离出来，DllPlugin 则抽离不易变动的第三方库，本来想尝试下在开发环境上加上 DllPlugin ，但是由于起服务使用内存来存储 webpack 开发环境下的打包文件，找不到另外打包出来的第三方库，并且开发环境上本来也是热更新的，所以就不再加了。 先创建一个基础的配置文件 webpack.base.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const path = require('path');const resolveCur = function(...p) &#123; return path.resolve(__dirname, ...p);&#125;;const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = function() &#123; return &#123; resolve: &#123; modules: [resolveCur('../node_modules')], extensions: ['.js', '.vue', '.json'], alias: &#123; vue$: 'vue/dist/vue.common.js' &#125;, &#125;, resolveLoader: &#123; modules: [resolveCur('../node_modules')] &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, use: 'vue-loader' &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, use: [ &#123; loader: 'babel-loader' &#125;, &#123; loader: 'eslint-loader', options: &#123; ignorePattern: eslintIgnore, // 不需要检验的正则匹配 formatter: require('eslint-friendly-formatter'), useEslintrc: false, parser: 'babel-eslint', parserOptions: &#123; sourceType: 'module' &#125;, env: ['browser'], plugins: [ 'html' ], rules: eslintRules // rules 配置文件 &#125; &#125; ] &#125;, &#123; test: /\\.html$/, use: 'html-withimg-loader' &#125;, &#123; test: /\\.(png|jpe?g|gif|bmp|svg)(\\?.*)?$/, use: &#123; loader: 'url-loader', options: &#123; limit: 9 * 1024, outputPath: 'images/[name].[hash:7].[ext]' &#125; &#125; &#125;, &#123; test: /\\.(woff2|eot|ttf|otf)(\\?.*)?$/, use: &#123; loader: 'url-loader', options: &#123; limit: 9 * 1024, outputPath: 'fonts/[name].[hash:7].[ext]' &#125; &#125; &#125; ] &#125;, plugins: [ new VueLoaderPlugin(), // 会将你定义过的其它规则复制并应用到 .vue 文件里相应语言的块 ] &#125;;&#125;; 创建开发环境的配置文件 webpack.dev.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const merge = require('webpack-merge');const webpack = require('webpack');const path = require('path');const baseWebpackConfig = require('./webpack.base')();const HtmlWebpackPlugin = require('html-webpack-plugin');const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin');module.exports = merge(baseWebpackConfig, &#123; mode: 'development', entry: &#123; app: [ 'webpack-hot-middleware/client?reload=true&amp;quiet=true', path.resolve(__dirname, '../src/dev/index.js') ] &#125;, output: &#123; filename: 'js/[name].js', path: path.resolve(__dirname, '../dist'), publicPath: '/' &#125;, devtool: 'source-map', optimization: &#123; noEmitOnErrors: true, //在编译出现错误时跳过输出阶段,确保输出资源不会包含错误 &#125;, module: &#123; rules: [ &#123; test: /\\.scss$/, use: [ 'vue-style-loader', 'css-loader', 'postcss-loader', // 会从样式文件所在目录慢慢往上找，直到根目录 'sass-loader' ] &#125;, &#123; test: /\\.css$/, use: [ 'vue-style-loader', 'css-loader', 'postcss-loader' ] &#125;, ] &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(), new HtmlWebpackPlugin(&#123; template: 'template.html', filename: 'index.html', // 产出 html 的文件名称 &#125;), new FriendlyErrorsPlugin() ]&#125;); 创建起服务的文件 dev-server.js 123456789101112131415161718192021222324252627282930313233343536373839404142require('./check-version')();const ora = require('ora');const Koa = require('koa');const app = new Koa();const staticMiddleware = require('koa-static');const webpackMiddleware = require('koa-webpack');const historyFallback = require('koa2-history-api-fallback');const webpackConfig = require('./webpack.dev');const webpack = require('webpack');const compiler = webpack(webpackConfig);const path = require('path');const staticPath = path.posix.join(process.cwd(), webpackConfig.output.publicPath); app.use(staticMiddleware(staticPath));app.use(historyFallback());const webpackMiddlewareInstance = webpackMiddleware(&#123; compiler, hot: &#123; log: false &#125;, dev: &#123; quiet: true, publicPath: webpackConfig.output.publicPath &#125;&#125;);app.use(webpackMiddlewareInstance);const spinner = new ora('等待 webpack 打包完成...');spinner.start();let port = 8080;app.listen(port).on('error', err =&gt; &#123; if (err.code === 'EADDRINUSE') &#123; port += 1; app.listen(port); &#125;&#125;);webpackMiddlewareInstance.dev.waitUntilValid(() =&gt; &#123; spinner.stop(); const url = `http://localhost:$&#123;port&#125;`; require('opn')(url);&#125;); 创建 vendor 的配置文件 webpack.vendor.js 1234567891011121314151617181920const webpack = require('webpack');const path = require('path');module.exports = &#123; entry: &#123; vendor: ['vue/dist/vue.common.js', 'vue-router'] &#125;, output: &#123; filename: '_dll_[name].js', path: path.resolve(__dirname, '../dist'), library: '_dll_[name]' // 产生的变量名 &#125;, plugins: [ new webpack.DllPlugin(&#123; name: '_dll_[name]', // name === library context: __dirname, path: path.resolve(__dirname, '../dist', 'manifest.json') // 输出的清单目录 &#125;) ] &#125;; 创建生产环境的配置文件 webpack.prod.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const merge = require('webpack-merge');const webpack = require('webpack');const path = require('path');const baseWebpackConfig = require('./webpack.base')();const HtmlWebpackPlugin = require('html-webpack-plugin');const UglifyJsPlugin = require('uglifyjs-webpack-plugin');const OptimizeCssPlugin = require('optimize-css-assets-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = merge(baseWebpackConfig, &#123; mode: 'production', entry: &#123; app: path.resolve(__dirname, '../src/dev/index.js') &#125;, output: &#123; path: path.resolve(__dirname, '../dist'), filename: 'js/[name].[chunkhash:8].js' // hash：每次重新编译都会变化 chunkhash：内容不变就不会 &#125;, optimization: &#123; splitChunks: &#123; cacheGroups: &#123; common: &#123; chunks: 'initial', minSize: 0, minChunks: 2 &#125;, vendor: &#123; priority: 1, // 先抽离第三方模块 test: /node_modules/, chunks: 'initial', minSize: 0, minChunks: 1 &#125; &#125; &#125;, minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true, uglifyOptions: &#123; output: &#123; // 删除注释 comments: false, &#125;, compress: &#123; // 删除 config 和 debugger 以及警告 warnings: false, drop_debugger: true, drop_console: true &#125; &#125; &#125;), new OptimizeCssPlugin() ] &#125;, module: &#123; rules: [ &#123; test: /\\.scss$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', // 会从样式文件所在目录慢慢往上找，直到根目录 'sass-loader' ] &#125;, &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader' ] &#125;, ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: 'template.html', filename: 'index.html', minify: &#123; removeComments: true, removeEmptyAttributes: true, removeAttributeQuotes: true, collapseWhitespace: true &#125; &#125;), new webpack.DllReferencePlugin(&#123; manifest: path.resolve(__dirname, '../dist', 'manifest.json'), context: __dirname &#125;), new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns: ['**/*', '!_dll_vendor.js', '!manifest.json'] &#125;), new MiniCssExtractPlugin(&#123; filename: 'css/[name].[chunkhash:8].css' &#125;), ]&#125;); 遇到的问题 在这里遇到了个问题，一直报错，解析不了 jsx，一开始还以为是 babel 版本的问题，结果后来发现把项目中的 babel 相关降到原来的样子也还是报错，仔细一看是因为 babel-loader 中的规则增加了 jsx 的缘故，只包含 js，问题就没有了（我觉得应该是因为 vue-loader 中会解析 vue 文件，将相应的模块交给适合的 loader 去解析，而 vue 文件中的 render 函数部分就交给了 jsx，但是并没有相关的插件能去解析它，所以就报错了） exports is not defined 去查了下看到说是因为在 .babelrc 中的 modules: false 阻止了 babel 进行模块转化，于是去掉之后发现还是报错，没法把 commonjs 解析成功，也试过 babel-plugin-transform-commonjs 插件，但是会报新的错误：Duplicate export ‘default’，好像是因为我项目里也用了 ES6 Module，所以导致重复编译？最后决定将那几个使用了 commonjs 的代码都变成 ES6 的，问题就解决了 使用 DllPlugin + DllReferencePlugin 时碰到一个问题：最后打包时还是将依赖打包了进去，之后发现我在项目中用的是 vue.common.js，但是第三方库中 vendor 引用 vue 会自动引入 vue 中的 vue.runtime.esm.js，所以导致第三方还是被一起打包在了里面，所以要在配置文件中添加上 vue/dist/vue.common.js 总结webpack 4 中改动还是挺大的，也导致了挺多插件不能用了，所以在插件的使用上可能会碰到很多问题，需要花上挺多的时间，若之后发现新的好用的插件再补充。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"webpack","slug":"webpack","permalink":"https://gromimiss.github.io/tags/webpack/"},{"name":"打包","slug":"打包","permalink":"https://gromimiss.github.io/tags/打包/"}]},{"title":"记对 Vue 中 nextTick 的理解及总结","date":"2019-03-15T16:00:00.000Z","path":"2019/03/16/next-tick/","text":"前段时间面试被问到对 nextTick 的理解，虽说之前有看过源码，但是一来内容多，看的较浅，二来时间过去挺久了，脑海中只模糊记得用了 setTimeout。说到底，还是理解不够深，所以这次决定整理一下，把它彻底搞明白！ 基础介绍nextTick: 在下次 DOM 更新循环结束之后执行延迟回调。 最近又看了下更新的源码，发现 MutationObserver 又被使用上了，MessageChannel 被移除了(捂脸)。先简单介绍下 nextTick 中用到的一些 api以及事件循环的概念，知道了这些才能更好的理解 nextTick。 PromisePromise：用于表示一个异步操作的最终状态，以及该异步操作的结果值。可以解决回调函数的异步执行和嵌套问题。它接受一个带 resolve函数和 reject 函数两个参数的函数，有三种状态： pending、 fulfilled、 rejected。 resolve 会将对象的状态从 pending 变为 fulfilled，异步操作成功时调用，并将异步操作的结果，作为参数传递出去。 reject 会将对象的状态从 pending 变为 rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 但它也有一些缺点： 一旦新建就会立即执行，无法中途取消 若不设置回调，内部抛出的错误不会反应到外部 当处于 pending 状态时无法得知目前进展到哪个阶段 兼容性见这里。 MutationObserverMutationObserver：监听页面中 DOM 元素的变化。它和事件很接近，但本质上不同，事件是同步触发，一有变动就立刻触发相应事件，而 MutationObserver 则是异步触发， DOM 的变动会等到当前所有 DOM 操作都结束才触发。 特点如下： 等待所有脚本任务完成后，才会运行 当有多个 DOM 操作时，会把 DOM 变动记录封装成一个数组进行处理（只会触发一次回调，回调中会将变动记录作为参数传进来） 可以观察 DOM 的所有类型变动 123456789var outer = document.querySelector('outer');new MutationObserver(function(mutations, observer) &#123; console.log(mutations);&#125;).observe(outer, &#123; attributes: true&#125;);// 只会触发一次outer.setAttribute('data-random', Math.random());outer.setAttribute('data-random', Math.random()); 很强大，但是它也有挺严重的兼容性问题，并且在 ie11 中也存在 bug，兼容性看这里。 setImmediatesetImmediate：将一些需要长时间运行的操作放在一个回调函数里面，在浏览器完成后面的其他语句后，立刻执行这个回调函数。它只在 IE 上支持，兼容性看这里。 事件循环JS 是一种单线程语言，所有任务都在一个线程上完成，这样一旦遇到大量任务或者是一个耗时的任务，网页就会出现“假死”。那为什么 js 不能实现多线程呢 —— 作为浏览器脚本语言，若多线程的话，一个线程添加 DOM，一个线程删除 DOM，浏览器就不好判断了。而单线程就意味着所有的任务都需要排队，前一个任务执行完，才会执行后一个任务，若前一个任务耗时很长，后面的任务都会一直等着，直到前一个任务完成。并且有时并不是因为计算量大，CPU 忙不过来，而是因为 IO 设备很慢，所以之后就引入了事件循环的机制。 首先在主线程上排队执行任务，而任务队列由异步任务在有了运行结果后放置的事件组成，一旦主线程中的任务执行完，就会读取任务队列，对应的异步任务在结束等待状态之后进入主线程，开始执行。每次主线程空了就会去读取任务队列。任务队列是一个先进先出的数据结构，排在前面的事件优先读取。 具体运行机制如下： 所有同步任务都在主线程上执行，形成一个执行栈 主线程外存在一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件 当执行栈中的任务完成，就会读取任务队列中的任务，依次进入执行栈执行 下一次事件循环开始 （参考了阮一峰的 eventloop） 事件队列中有两种任务源：微任务 (microtask) 和宏任务(macrotask)，当执行完同步代码后执行栈为空，会先执行微任务，执行完所有的微任务后，如有必要渲染页面，然后再执行任务队列中的宏任务，也意味着新一轮事件循环的开始。 (macro)task -&gt; microtask -&gt; 渲染 -&gt; (macro)task (macro)task：script setTimeout MessageChannel postMessage setInterval setImmediate I/O UI渲染microtask：process.nextTick promise.then MutationObserver 小总结：看了这篇文章，从第二个例子中才发现用户触发 click 和 js 调用 click 事件是不同的，js 调用 click 就导致会等到两次 click 结束，主线程才算是清空，才开始执行任务队列中的事件，这也就让两次 click 中推到任务队列的那些微任务在同一个事件循环中了，因此 MutationObserver 就只会触发一次（一个事件循环中多次 DOM 操作只会增加变动记录，而不会触发多次事件）。 源码解析了解完涉及到的知识点后，开始进入主题 —— 看 nextTick 的源码。 flushCallbacks从头往下看，先是 flushCallbacks，上代码： 12345678function flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125; 这段代码是在异步任务被执行的时候触发的回调：将 pending 状态重新设置为 false，执行回调列表，清空回调列表（为下一次异步队列做准备）。 异步的选择重点就是关于异步 api 使用的选择了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // In problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // \"force\" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true &#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]' )) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true &#125; else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; // Fallback to setImmediate. // Techinically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125; &#125; else &#123; // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 为什么要优先使用 microtask 呢？macrotask 中两个不同任务之间可能穿插着 UI 的重渲染，所以需要在 microtask 中把所有 UI 重渲染之前将需要更新的数据全部更新，这样只需要一次重渲染就可以得到最新的 DOM。microtask 中最优的选择是使用 Promise，当浏览器不支持 Promise 再降级为 MutationObserver，要注意的是 MutationObserver 在 IE11 中是存在 Bug 的：当同时按下3个按钮时，部分字符会丢失，具体见 issue #6466，所以在非 IE 的时候并且支持这个 API 才会使用，若这两个 microtask 都不支持，那只能退而求其次，使用 macrotask 了。macrotask 中首选是 setImmediate，它比 setTimeout 拥有更好的性能，不需要不停的做超时检测，但是它只有 IE 兼容，其次是 MessageChannel，一个 MessageChannel 实例对象拥有两个属性 port1 和 port2，我们只需要将其中一个 port 监听message 事件，另一个 port 通过 postMessage 向前一个 port 发送消息，这样前一个 port 的 message 事件就会被注册为 macrotask，由于它也不需要做任何检测工作，所以性能也比 setTimeout 好，最后的选择则是setTimeout。 但是这里我又想到了一个问题，既然 nextTick 是为了在数据更新后解决操作最新 DOM 的问题，那这必然就需要先进行一次重渲染，才可以再去获取最新的 DOM，而从这里看又希望把数据更新尽量放在一起重渲染，这不是相矛盾了吗？于是我又仔细的看了下源码，发现当数据赋新的值时，通知相关依赖响应更新时，除非将 sync 设置为 true 了，否则会调用 scheduler.js 中的 queueWathcer 方法，若队列中没有保存这个更新 watcher，则将更新 watcher 给保存到一个队列中，并且使用 waiting 来保证每次的 scheduleQueue，waiting 初始为 false，执行 queueWatcher 时会 nextTick(flushScheduleQueue)，即将 flushScheduleQueue 放到一个任务队列中，除非 flushScheduleQueue 被执行，重置了 waiting 状态，否则其间的 watcher 都会被存到到一个 queue 变量中，当 flushScheduleQueue 被执行时，才会真正调用 queue 中的 wachter。当真正调用 watcher 时，则会触发视图的重新渲染(run() -&gt; getAndInvoke() -&gt; get() -&gt; getter() -&gt; updateComponent())。用户执行的 nextTick 只是和 flushSchedulerQueue 放在了一个回调列表中，并且 flushSchedulerQueue 会先执行，所以后面的回调能获取到更新后的 DOM。 来个例子，直观一点。 123456789this.name = 'Tom';console.log('1');setTimeout(() =&gt; &#123; console.log('2');&#125;, 0);Promise.resove().then(() =&gt; &#123;console.log('3');&#125;this.$nextTick(() =&gt; &#123; console.log('4');&#125; 这段代码的运行结果为：1 -&gt; 4 -&gt; 3 -&gt; 2。 123456789101112131415161718192021222324export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 因为 nextTick 函数一开始 pending 为 false，会执行 timerFunc，也就是说把回调放到了任务队列中，然后将 pending 设置为true（这里其实在生命周期中已经执行了一次 nextTick），接下来调用的 this.$nextTick 其实还是在调用 nextTick，此时 timerFunc 早就已经调用，也就是说已经被放置到了任务队列中，它只会把传入的 cb 放到 callbacks 中，此时 callbacks 中就会有 2 个成员，flushSchedulerQueue 和另一个 cb，按进入队列的顺序执行，所以这里的顺序会先打印 1，再打印 4，接着执行 3 和 2。 为什么移除 MessageChannel见这里。 总结 可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个事件循环 “tick” 中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个 “tick” 更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 在 beforeMount 生命周期后会创建一个 watcher 观察者实例，这个 watcher 中会把 updateComponent 函数传入，watcher 实例就会对 updateComponent 函数求值，而执行 updateCompontnt 函数会间接触发渲染函数(vm.$options.render)的执行，继而触发数据属性的 get 拦截器函数，从而将依赖收集。当依次有多个属性更改时，比如 this.name 修改值，就会收集渲染函数的观察者，然后又修改了 this.age，就又会收集一次渲染函数的观察者，但是因为队列中已经收集了渲染函数的观察者了，就不会再重复添加，所以最后只会触发一次重渲染。 后面添加的 this.$nextTick 会和 flushSchedulerQueue(即渲染函数观察者或者还有定义的 watch 等)一起被加到回调函数中。","comments":true,"tags":[{"name":"vue","slug":"vue","permalink":"https://gromimiss.github.io/tags/vue/"},{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"},{"name":"源码","slug":"源码","permalink":"https://gromimiss.github.io/tags/源码/"}]},{"title":"JS 中的基本类型和引用类型","date":"2019-03-14T16:00:00.000Z","path":"2019/03/15/type/","text":"JS 中包含了两种类型：基本类型（原始类型）和引用类型。本文主要来总结下这两种类型的区别以及类型转换。 介绍基本数据类型基本数据类型：按值访问，可操作保存在变量中实际的值，指的是简单的数据段。它有6种： undefined、 null、 string、 number、 boolean、 symbol、bigInt。 引用类型引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。除了基本类型，其他都是引用类型，包括了：Object、 Array、 RegExp、 Date、 Function、 特殊的基本包装类型（String、 Number、Boolean）以及单体内置对象（Global、 Math）。引用类型变量存放的是地址，当创建一个对象类型的时候，计算机会在内存中开辟一个空间来存放值，我们需要通过一个地址来找到这个空间。所以当复制这个变量的时候其实复制的是存放这个对象空间的地址，当修改数据的时候，就导致了两个变量的值都发生了改变。 区别 基本类型按值访问，引用类型按址访问 123456789101112131415161718192021// 基本类型值var a = 'a';var b = a;a = 'b';alert(b); // a//引用类型值,以数组为例// 1. 对其中一个变量直接赋值不会影响到另一个变量（并未操作引用的对象）var a = [1, 2, 3];var b = a;a = [1, 2, 3, 4]; // 重新赋值，指向的就不是原来的哪个对象了alert(a); // 1,2,3,4alert(b); // 1,2,3// 2. 使用push(操作了引用的对象)var a = [1, 2, 3];var b = a;a.push(4);alert(a); // 1,2,3,4alert(b); // 1,2,3,4 引用类型可添加属性和方法，而基本类型不可以 123456789// 为引用类型值添加属性var p = new Object();p.age = 11;alert(p.age); // 11//为基本类型值添加属性var name = 'a';name.age = 11;alert(name.age); // undefined 传递参数：当变量为基本类型时，将变量赋值作为函数的参数（局部变量），在里面对局部变量进行操作时，不会影响到函数外部的值，而若参数为引用类型时，除非在内部重写了参数，否则外部的变量和函数内局部变量会引用同一个对象，内部发生改变也会影响到外部的变量 123456789101112131415161718192021// 基本类型function add(a) &#123; a += 10; return a;&#125;var num = 10;var result = add(num);alert(num); //10alert(result); //20// 引用类型function setName(obj) &#123; obj.name = 'a'; obj = new Object(); obj.name = 'b'; return obj;&#125;var p = new Object();var p2 = setName(p);alert(p.name); // aalert(p2.name); // b typeof vs instanceoftypeoftypeof 可用于判断基本类型，除了 null，其他都可以显示正确的类型。 1234567891011121314var num = 1;var a = 'a';var b;var flag = true;var o = null;var fn = function()&#123;&#125;;var rg = /hello/;alert(typeof num); // numberalert(typeof a); // stringalert(typeof b); // undefinedalert(typeof flag); // booleanalert(typeof o); // objectalert(typeof fn); // functionalert(typeof rg); // object(sarari5、chrome7前返回function) instanceofinstanceof 可以判断一个对象的正确类型。 1234var a = [1, 2,3 ];alert(a instanceof Object); //truealert(a instanceof Array); //truealert(a instanceof RegExp); //false 但它也不是完全可信的，因为通过 Symbol.hasInstance 我们可以自定义 instanceof 的行为。 12345class PrimitiveString &#123; static [Symbol.hasInstance](x) &#123; return typeof x === 'string'; &#125;&#125; isPrototypeOf 和 instanceof 的区别： A.isPrototypeOf(B)：A 有没有在 B 的原型链上 A instanceof B：A 对象的原型链上有没有 B.prototype 类型转换JS中的类型转换JS 中类型转换只有三种情况： 转为布尔值 转为字符串 转为数字 在转 Boolean 中，除了 null/undefined/0/-0/NaN/false/‘’，其他值都转为 true。 转换对象时，会调用内置的 [[ToPrimitive]] 函数，先调用 valueOf，若未返回基本类型，再调用 toString。 四则运算符 加法运算符 若运算中其中一方为字符串，则将另一方也转换为字符串； 若双方都不是字符串并且不是对象，运算中其中一方为数字，则将另一方也转换成数字 若双方都不是字符串，其中一方是对象，则会将对象先转换为基本类型，再通过以上2点比较 1234561 + '1' // '11'true + true // 24 + [1, 2] // '41,2'0 + &#123;&#125; // '0[object Object]'&#123;&#125; + 0 // 0 &#123;&#125; 会被当做一个空代码块，相当于计算 +0 ,所以结果不是 '[object Object]0' 而是 0a + + 'b' // 'NaN' 相当于 a 加上 + 'b' 其他运算符，只要其中一方是数字，另一方就会转成数字 比较运算符基本转换规则： 当使用 == 时的类型转换，会将两值都转成数字，见下图： 使用上图规则解析 [] == ![], !会将变量转换成 boolean 类型，所以 ![] 会转成 false, [] == false -&gt; [] == 0 -&gt; ‘’ == 0 -&gt; 0 == 0 -&gt; true 特殊问题 null 不是一个对象类型，虽然 typeof null === &#39;object&#39;，但是这只是 JS 存在的一个悠久 Bug。因为最初 JS 使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头的代表对象，而 null 表示为全零，所以就错误的判断了。 0.1 + 0.2 !== 0.3 在计算机中数字都是以多位二进制存储的，而除了那些可以表示成x / 2^n的数可以被精确表示，其余小数都是以近似值的方式存在，可以使用以下方式计算浮点数。 12345678910111213141516// 计算浮点数function addFloat(a, b) &#123; var aLen,bLen; try &#123; aLen = a.toString().split('.')[1].length; &#125; catch(e) &#123; aLen = 0; &#125; try &#123; bLen = b.toString().split('.')[1].length; &#125; catch(e) &#123; bLen = 0; &#125; var max = Math.pow(10, Math.max(aLen, bLen)); return (a * max + b * max) / max;&#125; 为什么需要包装对象？当我们调用基本数据上的属性或者是方法时其实都隐式的调用了其包装对象。由于 null 和 undefined 不需要属性和方法，所以并不需要包装对象。 12'foo'.length // 3'foo'.toLocaleUpperCase() // 'FOO' 新加入的 symbol、bigInt 虽然也都有包装对象，但是在 ES6 中背设计为不能再通过 new Symbol 或 new BigInt 来创建了，使用 new 将会抛出异常。若要转换为包装对象可以通过 Object()，保留这种方式是因为目前已经有代码用 Object(value) === value 来判断一个值是否是对象值了。不过虽然 Object(value) === value 不相等，但是当 symbol 包装对象被误作为属性来使用时，会有自动解包装的逻辑，所以可以直接使用。","comments":true,"tags":[{"name":"js","slug":"js","permalink":"https://gromimiss.github.io/tags/js/"}]},{"title":"记录 hexo + github pages 搭建博客过程","date":"2019-03-13T16:00:00.000Z","path":"2019/03/14/hexo/","text":"一直想搞个博客，总是被各种事情阻扰，然后继续被搁置着。现在闲了，终于决定自己动手做一个。本文主要记录使用 hexo + github pages 搭建博客的过程及遇到的一些小问题（cu xin）。 背景为什么用 hexo + github pages？hexo: 一个快速、简洁且高效的博客框架，目前拥有 288 个插件以及 246 个主题可供选择。github pages：由 github 提供的一项功能，可以创建一个专属域名来展示自己的一些项目，考虑到域名备案还是比较麻烦，所以还是选择了这个。 准备工作 确保已经下载安装了 Node 以及 git 安装 Hexo 1npm i -g hexo-cli 新建一个 github 仓库，利用这个仓库来使用 github pages功能 建立本地和远程仓库的关联 创建 ssh，id_rsa 是个人电脑上的私人密钥，id_rsa.pub 是公共密钥，将公共密钥放到 github 上，这样连接 github 账户时，就会根据公钥来匹配电脑上的私钥，相互匹配时，才能顺利通过 git 上传文件到 github 上。 可以先检查本机是否已经存在 ssh。 12cd ~/. sshls 若不存在，则创建: 12ssh-keygen -t rsa -C \"youremail\"Enter file in which to save the key # 输入用于保存生成的SSH key的文件名，按回车则使用默认的 将 id_rsa.pub 文件中的密钥复制到 github -&gt; settings -&gt; SSH and GPGkeys -&gt; New SSH key 中 验证是否关联成功（注意：这个就是 git@github.com，不要把 git 换成自己的 username），显示 hi, your username 就说明成功了 1ssh -T git@github.com 创建博客项目这里可以选择先创建一个博客文件夹，再进入到这个文件夹执行命令 hexo init，也可以在指定文件夹中 hexo init blogname。 init后会出现一个目录： 12345678.├── _config.yml # 配置文件├── package.json├── scaffolds # 模板文件夹├── source # 资源文件夹| ├── _drafts # 草稿箱| └── _posts # 发布└── themes # 主题文件夹 根据自己的需求去修改配置文件中的信息。 主题主题可以自行去 官网 寻找自己喜欢的，本人更喜欢简约一点的，所以选择了 yilia。 1git clone https://github.com/litten/hexo-theme-yilia.git 将主题下载下来后放到 themes 目录中，再将站点中 _config.yml 的 theme 属性改成新添加的主题名。 1hexo s 这样就可以看到效果了。在 themes/新添加的主题 目录下也会有个 _config.yml，在里面可以根据个人的需求来调整，具体见 这里。 要特别说一下的是，如果要使用首页只显示前几行的话可以在文章中通过 &lt;!-- more --&gt; 来自定义自己想在首页显示的内容，并且需要将主题配置文件中的 excerpt_link: more 注释掉，并且要注意的是文章中 &lt;!-- more --&gt; 上面需要有内容（注释掉的也可以），否则会发现文章又显示全部内容了。 live2d 动画已经记不得是在哪个博客中看到了 live2d，觉得很可爱，就想着也加一个。 先下载 live2d 包 1npm i --save hexo-helper-live2d 选择自己喜欢的 模型 1npm i --save live2d-widget-model-模型名 在站点的 _config.yml 中添加配置信息,将 model 改为你选择的模型包名 123456789101112131415161718192021live2d:enable: truescriptFrom: localpluginRootPath: live2dw/pluginJsPath: lib/pluginModelPath: assets/tagMode: falsedebug: falsemodel: use: live2d-widget-model-tororodisplay: position: right width: 100 height: 200 hOffset: 30 vOffset: -60mobile: show: truereact: opacityDefault: 1 opacityOnHover: 0.7 可以根据自己想要的样子去调整一些属性，如位置、透明度等，详细见 这里。 评论系统评论系统我使用了 Valine，为什么选择它 —— 好吧，我完全只是喜欢它的颜值而已。看了我使用的 yilia 主题，发现配置文件中只有多说、网易云跟帖、畅言、Disqus、Gitment这五种评论系统可以配置，就去 github 上看一下，发现在2017年的时候就新增了对 Valine 的支持，使用如下： 注册 Leancloud，创建应用 在站点的 _config.yml 中增加配置信息，appId和 appKey 可以在 创建的应用 -&gt; 设置 -&gt; 应用 key 中找到。 12345678#6、Valine https://valine.js.orgvaline: appid: #Leancloud应用的appIdappkey: #Leancloud应用的appKeyverify: false #验证码notify: false #评论回复提醒avatar: mm #评论列表头像样式：''/mm/identicon/monsterid/wavatar/retro/hideplaceholder: Just go go #评论框占位符 在主题中的 layout/_partial/article.ejs 中添加代码（注意：要加在 &lt;% if (!index &amp;&amp; post.comments){ %&gt; 后 面，否则会出现首页也出现评论框的问题）。 12345678910111213&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt;&lt;section id=\"comments\" class=\"comments\"&gt; &lt;style&gt; .comments&#123;margin:30px;padding:10px;background:#fff&#125; @media screen and (max-width:800px)&#123;.comments&#123;margin:auto;padding:10px;background:#fff&#125;&#125; &lt;/style&gt; &lt;%- partial('post/valine', &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt;&lt;/section&gt;&lt;% &#125; %&gt; 添加 layout/_partial/post/valine.ejs 文件，文件内容如下: 123456789101112131415161718&lt;div id=\"vcomment\" class=\"comment\"&gt;&lt;/div&gt;&lt;script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/valine/dist/Valine.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var notify = '&lt;%= theme.valine.notify %&gt;' == true ? true : false; var verify = '&lt;%= theme.valine.verify %&gt;' == true ? true : false; window.onload = function() &#123; new Valine(&#123; el: '#vcomment', notify: notify, verify: verify, app_id: \"&lt;%= theme.valine.appid %&gt;\", app_key: \"&lt;%= theme.valine.appkey %&gt;\", placeholder: \"&lt;%= theme.valine.placeholder %&gt;\", avatar:\"&lt;%= theme.valine.avatar %&gt;\" &#125;); &#125;&lt;/script&gt; 开启智能菜单中所有文章及标签的搜索 下载 hexo-generator-json-content 包 1npm i --save hexo-generator-json-content 在站点的 _config.yml 中添加配置信息 123456789101112131415161718jsonContent:meta: falsepages: falseposts:title: truedate: truepath: truetext: trueraw: falsecontent: falseslug: falseupdated: falsecomments: truelink: falsepermalink: falseexcerpt: falsecategories: falsetags: true 添加归档 在文件夹中 hexo new page archives 在主题下的 _config.yml 中添加 menu 字数/阅读时长/阅读量统计在文章标题下增加字数/阅读时长/阅读量统计这些内容。 阅读量统计阅读量统计我使用了不蒜子： 在主题下的 layout/_partial/after-footer.ejs 中最后添加代码： 1&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 在 after-footer 后面使用： 12本站总访问量 &lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt; 次&amp;nbsp&amp;nbsp&amp;nbsp本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次 不过我只希望在文章中添加阅读量，所以放的位置也不一样，我会把它和字数/阅读时长一起放到头部，所以稍后在字数/阅读时长的内容中一起讲。 字数/阅读时长字数和阅读时长的统计我使用了插件 hexo-wordcount。 下载 hexo-wordcount 包 1npm i --save hexo-wordcount 在主题目录下 layout/_partial/post 中新建 word.ejs 文件，把之前的阅读量统计和字数及阅读时长的内容一起放到这个文件里(注意：首页中的每篇文章也会显示，但是那里只会统计站点访问量，所以要判断首页则不显示这些信息，暂时使用了 index 来区分是否是首页) 1234567891011121314151617181920212223242526272829&lt;% if (!index)&#123; %&gt; &lt;div style=\"margin-top:10px;font-size: 12px; color: #999;\"&gt; &lt;span class=\"post-time\"&gt; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fa fa-keyboard-o icon-acfun\" style=\"font-size: 12px;\"&gt;&lt;/i&gt; &lt;span class=\"post-meta-item-text\"&gt; 字数统计: &lt;/span&gt; &lt;span class=\"post-count\"&gt;&lt;%= wordcount(post.content) %&gt;字&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;span class=\"post-time\"&gt; &amp;nbsp; | &amp;nbsp; &lt;span class=\"post-meta-item-icon\"&gt; &lt;i class=\"fa fa-hourglass-half icon-clock\" style=\"font-size: 12px;\"&gt;&lt;/i&gt; &lt;span class=\"post-meta-item-text\"&gt; 阅读时长: &lt;/span&gt; &lt;span class=\"post-count\"&gt;&lt;%= min2read(post.content) %&gt;分&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;span class=\"post-time\"&gt; &amp;nbsp; | &amp;nbsp; &lt;i class=\"icon-book\" style=\"font-size: 12px;\"&gt;&lt;/i&gt; &lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量 &lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt; 次 &lt;/span&gt; &lt;/span&gt; &lt;/div&gt;&lt;% &#125; %&gt; 在文章中插入图片考虑到性能问题，打算把图片放到 七牛云 中，通过外链的形式插入。 注册七牛云，免费领取对象存储，新建存储空间（需要实名认证，包括支付宝、身份证等绑定，并且免费的话只能用测试域名，有效期30 天） 复制上传的图片外链，在文章中引入外链，居中设置宽度（默认的太大了） 123456&lt;center&gt; &lt;img src=\"外链地址\" width=\"80%\" /&gt;&lt;/center&gt; 添加 RSS可以使用一个插件 —— hexo-generator-feed 下载插件 1npm i --save hexo-generator-feed 在站点的 _config.yml 中添加以下代码 1234feed: type: atom path: atom.xml limit: 20 在主题下的 _config.yml 中添加以下代码 1rss: /atom.xml 部署 在站点 _config.yml 中配置部署 github 仓库信息 1234deploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master 通过指令生成页面后使用指令 hexo d 部署若发生错误：Deployer not found: Git，则说明要下载 hexo-deployer-git 1npm i --save hexo-deployer-git 结束语到这里，搭建博客就结束了，内容比较简单，就是自己想要的功能可以要自己花时间去找，还有就是 markdown 的语法一定要注意空格、tab，不要有多余的空格（之前代码块一直显示错乱，找了好久才发现 ~~~ 后面多了个空格）！！！","comments":true,"tags":[{"name":"hexo","slug":"hexo","permalink":"https://gromimiss.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://gromimiss.github.io/tags/github-pages/"}]}]